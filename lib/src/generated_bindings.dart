// ignore_for_file: type=lint
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Holds bindings to Z3
class NativeZ3Library {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeZ3Library(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeZ3Library.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdin =
      _lookup<ffi.Pointer<FILE>>('stdin');

  ffi.Pointer<FILE> get stdin => _stdin.value;

  set stdin(ffi.Pointer<FILE> value) => _stdin.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdout =
      _lookup<ffi.Pointer<FILE>>('stdout');

  ffi.Pointer<FILE> get stdout => _stdout.value;

  set stdout(ffi.Pointer<FILE> value) => _stdout.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stderr =
      _lookup<ffi.Pointer<FILE>>('stderr');

  ffi.Pointer<FILE> get stderr => _stderr.value;

  set stderr(ffi.Pointer<FILE> value) => _stderr.value = value;

  int remove(
    ffi.Pointer<ffi.Char> __filename,
  ) {
    return _remove(
      __filename,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int renameat(
    int __oldfd,
    ffi.Pointer<ffi.Char> __old,
    int __newfd,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _renameat(
      __oldfd,
      __old,
      __newfd,
      __new,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int fclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fclose(
      __stream,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tmpnam_r(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _tmpnam_r(
      __s,
    );
  }

  late final _tmpnam_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam_r');
  late final _tmpnam_r = _tmpnam_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __pfx,
  ) {
    return _tempnam(
      __dir,
      __pfx,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fflush(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush(
      __stream,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush_unlocked(
      __stream,
    );
  }

  late final _fflush_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush_unlocked');
  late final _fflush_unlocked =
      _fflush_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fopen(
      __filename,
      __modes,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
    ffi.Pointer<FILE> __stream,
  ) {
    return _freopen(
      __filename,
      __modes,
      __stream,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fdopen(
    int __fd,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fdopen(
      __fd,
      __modes,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __s,
    int __len,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fmemopen(
      __s,
      __len,
      __modes,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufloc,
    ffi.Pointer<ffi.Int> __sizeloc,
  ) {
    return _open_memstream(
      __bufloc,
      __sizeloc,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Int>)>();

  void setbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _setbuf(
      __stream,
      __buf,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __modes,
    int __n,
  ) {
    return _setvbuf(
      __stream,
      __buf,
      __modes,
      __n,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  void setbuffer(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _setbuffer(
      __stream,
      __buf,
      __size,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  void setlinebuf(
    ffi.Pointer<FILE> __stream,
  ) {
    return _setlinebuf(
      __stream,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fprintf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fprintf(
      __stream,
      __format,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int printf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _printf(
      __format,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sprintf(
      __s,
      __format,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfprintf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vfprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int vprintf(
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vprintf(
      __format,
      __arg,
    );
  }

  late final _vprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'vprintf');
  late final _vprintf =
      _vprintfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vsprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __s,
      __maxlen,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vsnprintf(
      __s,
      __maxlen,
      __format,
      __arg,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int vdprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
    int __arg,
  ) {
    return _vdprintf(
      __fd,
      __fmt,
      __arg,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('vdprintf');
  late final _vdprintf =
      _vdprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int dprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
  ) {
    return _dprintf(
      __fd,
      __fmt,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int fscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf(
      __stream,
      __format,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf(
      __format,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf(
      __s,
      __format,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fscanf1(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf1(
      __stream,
      __format,
    );
  }

  late final _fscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf1 = _fscanf1Ptr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf1(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf1(
      __format,
    );
  }

  late final _scanf1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf1 =
      _scanf1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf1(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf1(
      __s,
      __format,
    );
  }

  late final _sscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf1 = _sscanf1Ptr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vfscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vscanf(
      __format,
      __arg,
    );
  }

  late final _vscanfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'vscanf');
  late final _vscanf =
      _vscanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vsscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int vfscanf1(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vfscanf1(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('vfscanf');
  late final _vfscanf1 = _vfscanf1Ptr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int vscanf1(
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vscanf1(
      __format,
      __arg,
    );
  }

  late final _vscanf1Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'vscanf');
  late final _vscanf1 =
      _vscanf1Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int vsscanf1(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    int __arg,
  ) {
    return _vsscanf1(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanf1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('vsscanf');
  late final _vsscanf1 = _vsscanf1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int fgetc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc(
      __stream,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc(
      __stream,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  int getc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc_unlocked(
      __stream,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int fgetc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc_unlocked(
      __stream,
    );
  }

  late final _fgetc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fgetc_unlocked');
  late final _fgetc_unlocked =
      _fgetc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fputc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc(
      __c,
      __stream,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc(
      __c,
      __stream,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int __c,
  ) {
    return _putchar(
      __c,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int fputc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc_unlocked(
      __c,
      __stream,
    );
  }

  late final _fputc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc_unlocked');
  late final _fputc_unlocked =
      _fputc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc_unlocked(
      __c,
      __stream,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int __c,
  ) {
    return _putchar_unlocked(
      __c,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getw(
      __stream,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int __w,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putw(
      __w,
      __stream,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> __s,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgets(
      __s,
      __n,
      __stream,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  int __getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Int> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return ___getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final ___getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<FILE>)>>('__getdelim');
  late final ___getdelim = ___getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Int>,
          int, ffi.Pointer<FILE>)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Int> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Int>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Int> __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __lineptr,
      __n,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputs(
      __s,
      __stream,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int puts(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _puts(
      __s,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _ungetc(
      __c,
      __stream,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __s,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __n,
      __s,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fread_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fread_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<FILE>)>>('fread_unlocked');
  late final _fread_unlocked = _fread_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fwrite_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<FILE>)>>('fwrite_unlocked');
  late final _fwrite_unlocked = _fwrite_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fseek(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseek(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftell(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftell(
      __stream,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void rewind(
    ffi.Pointer<FILE> __stream,
  ) {
    return _rewind(
      __stream,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, __off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Pointer<FILE>)>>(
          'ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fgetpos(
      __stream,
      __pos,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int fsetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fsetpos(
      __stream,
      __pos,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  void clearerr(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr(
      __stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof(
      __stream,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror(
      __stream,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void clearerr_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr_unlocked(
      __stream,
    );
  }

  late final _clearerr_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr_unlocked');
  late final _clearerr_unlocked =
      _clearerr_unlockedPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof_unlocked(
      __stream,
    );
  }

  late final _feof_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'feof_unlocked');
  late final _feof_unlocked =
      _feof_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror_unlocked(
      __stream,
    );
  }

  late final _ferror_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror_unlocked');
  late final _ferror_unlocked =
      _ferror_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void perror(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _perror(
      __s,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno(
      __stream,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fileno_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno_unlocked(
      __stream,
    );
  }

  late final _fileno_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno_unlocked');
  late final _fileno_unlocked =
      _fileno_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _pclose(
      __stream,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> __command,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _popen(
      __command,
      __modes,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _ctermid(
      __s,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void flockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _flockfile(
      __stream,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftrylockfile(
      __stream,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _funlockfile(
      __stream,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int __uflow(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___uflow(
      arg0,
    );
  }

  late final ___uflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__uflow');
  late final ___uflow =
      ___uflowPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __overflow(
    ffi.Pointer<FILE> arg0,
    int arg1,
  ) {
    return ___overflow(
      arg0,
      arg1,
    );
  }

  late final ___overflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>, ffi.Int)>>(
          '__overflow');
  late final ___overflow =
      ___overflowPtr.asFunction<int Function(ffi.Pointer<FILE>, int)>();

  /// @{*/
  /// /**
  /// \brief Set a global (or module) parameter.
  /// This setting is shared by all Z3 contexts.
  ///
  /// When a Z3 module is initialized it will use the value of these parameters
  /// when Z3_params objects are not provided.
  ///
  /// The name of parameter can be composed of characters [a-z][A-Z], digits [0-9], '-' and '_'.
  /// The character '.' is a delimiter (more later).
  ///
  /// The parameter names are case-insensitive. The character '-' should be viewed as an "alias" for '_'.
  /// Thus, the following parameter names are considered equivalent: "pp.decimal-precision"  and "PP.DECIMAL_PRECISION".
  ///
  /// This function can be used to set parameters for a specific Z3 module.
  /// This can be done by using <module-name>.<parameter-name>.
  /// For example:
  /// Z3_global_param_set('pp.decimal', 'true')
  /// will set the parameter "decimal" in the module "pp" to true.
  ///
  /// \sa Z3_global_param_get
  /// \sa Z3_global_param_reset_all
  ///
  /// def_API('Z3_global_param_set', VOID, (_in(STRING), _in(STRING)))
  void Z3_global_param_set(
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _Z3_global_param_set(
      param_id,
      param_value,
    );
  }

  late final _Z3_global_param_setPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string, Z3_string)>>(
          'Z3_global_param_set');
  late final _Z3_global_param_set =
      _Z3_global_param_setPtr.asFunction<void Function(Z3_string, Z3_string)>();

  /// \brief Restore the value of all global (and module) parameters.
  /// This command will not affect already created objects (such as tactics and solvers).
  ///
  /// \sa Z3_global_param_get
  /// \sa Z3_global_param_set
  ///
  /// def_API('Z3_global_param_reset_all', VOID, ())
  void Z3_global_param_reset_all() {
    return _Z3_global_param_reset_all();
  }

  late final _Z3_global_param_reset_allPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Z3_global_param_reset_all');
  late final _Z3_global_param_reset_all =
      _Z3_global_param_reset_allPtr.asFunction<void Function()>();

  /// \brief Get a global (or module) parameter.
  ///
  /// Returns \c false if the parameter value does not exist.
  ///
  /// \sa Z3_global_param_reset_all
  /// \sa Z3_global_param_set
  ///
  /// \remark This function cannot be invoked simultaneously from different threads without synchronization.
  /// The result string stored in param_value is stored in shared location.
  ///
  /// def_API('Z3_global_param_get', BOOL, (_in(STRING), _out(STRING)))
  int Z3_global_param_get(
    Z3_string param_id,
    Z3_string_ptr param_value,
  ) {
    return _Z3_global_param_get(
      param_id,
      param_value,
    );
  }

  late final _Z3_global_param_getPtr =
      _lookup<ffi.NativeFunction<Z3_bool Function(Z3_string, Z3_string_ptr)>>(
          'Z3_global_param_get');
  late final _Z3_global_param_get = _Z3_global_param_getPtr.asFunction<
      int Function(Z3_string, Z3_string_ptr)>();

  /// \brief Create a configuration object for the Z3 context object.
  ///
  /// Configurations are created in order to assign parameters prior to creating
  /// contexts for Z3 interaction. For example, if the users wishes to use proof
  /// generation, then call:
  ///
  /// \ccode{Z3_set_param_value(cfg\, "proof"\, "true")}
  ///
  /// \remark In previous versions of Z3, the \c Z3_config was used to store
  /// global and module configurations. Now, we should use \c Z3_global_param_set.
  ///
  /// The following parameters can be set:
  ///
  /// - proof  (Boolean)           Enable proof generation
  /// - debug_ref_count (Boolean)  Enable debug support for Z3_ast reference counting
  /// - trace  (Boolean)           Tracing support for VCC
  /// - trace_file_name (String)   Trace out file for VCC traces
  /// - timeout (unsigned)         default timeout (in milliseconds) used for solvers
  /// - well_sorted_check          type checker
  /// - auto_config                use heuristics to automatically select solver and configure it
  /// - model                      model generation for solvers, this parameter can be overwritten when creating a solver
  /// - model_validate             validate models produced by solvers
  /// - unsat_core                 unsat-core generation for solvers, this parameter can be overwritten when creating a solver
  /// - encoding                   the string encoding used internally (must be either "unicode" - 18 bit, "bmp" - 16 bit or "ascii" - 8 bit)
  ///
  /// \sa Z3_set_param_value
  /// \sa Z3_del_config
  ///
  /// def_API('Z3_mk_config', CONFIG, ())
  Z3_config Z3_mk_config() {
    return _Z3_mk_config();
  }

  late final _Z3_mk_configPtr =
      _lookup<ffi.NativeFunction<Z3_config Function()>>('Z3_mk_config');
  late final _Z3_mk_config =
      _Z3_mk_configPtr.asFunction<Z3_config Function()>();

  /// \brief Delete the given configuration object.
  ///
  /// \sa Z3_mk_config
  ///
  /// def_API('Z3_del_config', VOID, (_in(CONFIG),))
  void Z3_del_config(
    Z3_config c,
  ) {
    return _Z3_del_config(
      c,
    );
  }

  late final _Z3_del_configPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_config)>>(
          'Z3_del_config');
  late final _Z3_del_config =
      _Z3_del_configPtr.asFunction<void Function(Z3_config)>();

  /// \brief Set a configuration parameter.
  ///
  /// The following parameters can be set for
  ///
  /// \sa Z3_mk_config
  ///
  /// def_API('Z3_set_param_value', VOID, (_in(CONFIG), _in(STRING), _in(STRING)))
  void Z3_set_param_value(
    Z3_config c,
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _Z3_set_param_value(
      c,
      param_id,
      param_value,
    );
  }

  late final _Z3_set_param_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_config, Z3_string, Z3_string)>>('Z3_set_param_value');
  late final _Z3_set_param_value = _Z3_set_param_valuePtr.asFunction<
      void Function(Z3_config, Z3_string, Z3_string)>();

  /// \brief Create a context using the given configuration.
  ///
  /// After a context is created, the configuration cannot be changed,
  /// although some parameters can be changed using #Z3_update_param_value.
  /// All main interaction with Z3 happens in the context of a \c Z3_context.
  ///
  /// In contrast to #Z3_mk_context_rc, the life time of \c Z3_ast objects
  /// are determined by the scope level of #Z3_solver_push and #Z3_solver_pop.
  /// In other words, a \c Z3_ast object remains valid until there is a
  /// call to #Z3_solver_pop that takes the current scope below the level where
  /// the object was created.
  ///
  /// Note that all other reference counted objects, including \c Z3_model,
  /// \c Z3_solver, \c Z3_func_interp have to be managed by the caller.
  /// Their reference counts are not handled by the context.
  ///
  /// \remark Thread safety: objects created using a given context should not be
  /// accessed from different threads without synchronization. In other words,
  /// operations on a context are not thread safe. To use Z3 from different threads
  /// create separate context objects. The \c Z3_translate, \c Z3_solver_translate,
  /// \c Z3_model_translate, \c Z3_goal_translate
  /// methods are exposed to allow copying state from one context to another.
  ///
  /// \remark
  /// - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
  /// - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
  /// Z3 will return the same pointer twice.
  ///
  /// \sa Z3_del_context
  ///
  /// def_API('Z3_mk_context', CONTEXT, (_in(CONFIG),))
  Z3_context Z3_mk_context(
    Z3_config c,
  ) {
    return _Z3_mk_context(
      c,
    );
  }

  late final _Z3_mk_contextPtr =
      _lookup<ffi.NativeFunction<Z3_context Function(Z3_config)>>(
          'Z3_mk_context');
  late final _Z3_mk_context =
      _Z3_mk_contextPtr.asFunction<Z3_context Function(Z3_config)>();

  /// \brief Create a context using the given configuration.
  /// This function is similar to #Z3_mk_context. However,
  /// in the context returned by this function, the user
  /// is responsible for managing \c Z3_ast reference counters.
  /// Managing reference counters is a burden and error-prone,
  /// but allows the user to use the memory more efficiently.
  /// The user must invoke #Z3_inc_ref for any \c Z3_ast returned
  /// by Z3, and #Z3_dec_ref whenever the \c Z3_ast is not needed
  /// anymore. This idiom is similar to the one used in
  /// BDD (binary decision diagrams) packages such as CUDD.
  ///
  /// Remarks:
  ///
  /// - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
  /// - After a context is created, the configuration cannot be changed.
  /// - All main interaction with Z3 happens in the context of a \c Z3_context.
  /// - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
  /// Z3 will return the same pointer twice.
  ///
  /// def_API('Z3_mk_context_rc', CONTEXT, (_in(CONFIG),))
  Z3_context Z3_mk_context_rc(
    Z3_config c,
  ) {
    return _Z3_mk_context_rc(
      c,
    );
  }

  late final _Z3_mk_context_rcPtr =
      _lookup<ffi.NativeFunction<Z3_context Function(Z3_config)>>(
          'Z3_mk_context_rc');
  late final _Z3_mk_context_rc =
      _Z3_mk_context_rcPtr.asFunction<Z3_context Function(Z3_config)>();

  /// \brief Delete the given logical context.
  ///
  /// \sa Z3_mk_context
  ///
  /// def_API('Z3_del_context', VOID, (_in(CONTEXT),))
  void Z3_del_context(
    Z3_context c,
  ) {
    return _Z3_del_context(
      c,
    );
  }

  late final _Z3_del_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context)>>(
          'Z3_del_context');
  late final _Z3_del_context =
      _Z3_del_contextPtr.asFunction<void Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST.
  /// The context \c c should have been created using #Z3_mk_context_rc.
  /// This function is a NOOP if \c c was created using #Z3_mk_context.
  ///
  /// def_API('Z3_inc_ref', VOID, (_in(CONTEXT), _in(AST)))
  void Z3_inc_ref(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_inc_ref(
      c,
      a,
    );
  }

  late final _Z3_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast)>>(
          'Z3_inc_ref');
  late final _Z3_inc_ref =
      _Z3_inc_refPtr.asFunction<void Function(Z3_context, Z3_ast)>();

  /// \brief Decrement the reference counter of the given AST.
  /// The context \c c should have been created using #Z3_mk_context_rc.
  /// This function is a NOOP if \c c was created using #Z3_mk_context.
  ///
  /// def_API('Z3_dec_ref', VOID, (_in(CONTEXT), _in(AST)))
  void Z3_dec_ref(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_dec_ref(
      c,
      a,
    );
  }

  late final _Z3_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast)>>(
          'Z3_dec_ref');
  late final _Z3_dec_ref =
      _Z3_dec_refPtr.asFunction<void Function(Z3_context, Z3_ast)>();

  /// \brief Set a value of a context parameter.
  ///
  /// \sa Z3_global_param_set
  ///
  /// def_API('Z3_update_param_value', VOID, (_in(CONTEXT), _in(STRING), _in(STRING)))
  void Z3_update_param_value(
    Z3_context c,
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _Z3_update_param_value(
      c,
      param_id,
      param_value,
    );
  }

  late final _Z3_update_param_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_string, Z3_string)>>('Z3_update_param_value');
  late final _Z3_update_param_value = _Z3_update_param_valuePtr.asFunction<
      void Function(Z3_context, Z3_string, Z3_string)>();

  /// \brief Retrieve description of global parameters.
  ///
  /// def_API('Z3_get_global_param_descrs', PARAM_DESCRS, (_in(CONTEXT),))
  Z3_param_descrs Z3_get_global_param_descrs(
    Z3_context c,
  ) {
    return _Z3_get_global_param_descrs(
      c,
    );
  }

  late final _Z3_get_global_param_descrsPtr =
      _lookup<ffi.NativeFunction<Z3_param_descrs Function(Z3_context)>>(
          'Z3_get_global_param_descrs');
  late final _Z3_get_global_param_descrs = _Z3_get_global_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context)>();

  /// \brief Interrupt the execution of a Z3 procedure.
  /// This procedure can be used to interrupt: solvers, simplifiers and tactics.
  ///
  /// def_API('Z3_interrupt', VOID, (_in(CONTEXT),))
  void Z3_interrupt(
    Z3_context c,
  ) {
    return _Z3_interrupt(
      c,
    );
  }

  late final _Z3_interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context)>>(
          'Z3_interrupt');
  late final _Z3_interrupt =
      _Z3_interruptPtr.asFunction<void Function(Z3_context)>();

  /// \brief Create a Z3 (empty) parameter set.
  /// Starting at Z3 4.0, parameter sets are used to configure many components such as:
  /// simplifiers, tactics, solvers, etc.
  ///
  /// \remark Reference counting must be used to manage parameter sets, even when the \c Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_params', PARAMS, (_in(CONTEXT),))
  Z3_params Z3_mk_params(
    Z3_context c,
  ) {
    return _Z3_mk_params(
      c,
    );
  }

  late final _Z3_mk_paramsPtr =
      _lookup<ffi.NativeFunction<Z3_params Function(Z3_context)>>(
          'Z3_mk_params');
  late final _Z3_mk_params =
      _Z3_mk_paramsPtr.asFunction<Z3_params Function(Z3_context)>();

  /// \brief Increment the reference counter of the given parameter set.
  ///
  /// def_API('Z3_params_inc_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
  void Z3_params_inc_ref(
    Z3_context c,
    Z3_params p,
  ) {
    return _Z3_params_inc_ref(
      c,
      p,
    );
  }

  late final _Z3_params_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_params)>>(
          'Z3_params_inc_ref');
  late final _Z3_params_inc_ref =
      _Z3_params_inc_refPtr.asFunction<void Function(Z3_context, Z3_params)>();

  /// \brief Decrement the reference counter of the given parameter set.
  ///
  /// def_API('Z3_params_dec_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
  void Z3_params_dec_ref(
    Z3_context c,
    Z3_params p,
  ) {
    return _Z3_params_dec_ref(
      c,
      p,
    );
  }

  late final _Z3_params_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_params)>>(
          'Z3_params_dec_ref');
  late final _Z3_params_dec_ref =
      _Z3_params_dec_refPtr.asFunction<void Function(Z3_context, Z3_params)>();

  /// \brief Add a Boolean parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_bool', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(BOOL)))
  void Z3_params_set_bool(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    int v,
  ) {
    return _Z3_params_set_bool(
      c,
      p,
      k,
      v,
    );
  }

  late final _Z3_params_set_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.Int)>>('Z3_params_set_bool');
  late final _Z3_params_set_bool = _Z3_params_set_boolPtr.asFunction<
      void Function(Z3_context, Z3_params, Z3_symbol, int)>();

  /// \brief Add a unsigned parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_uint', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(UINT)))
  void Z3_params_set_uint(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    int v,
  ) {
    return _Z3_params_set_uint(
      c,
      p,
      k,
      v,
    );
  }

  late final _Z3_params_set_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.UnsignedInt)>>('Z3_params_set_uint');
  late final _Z3_params_set_uint = _Z3_params_set_uintPtr.asFunction<
      void Function(Z3_context, Z3_params, Z3_symbol, int)>();

  /// \brief Add a double parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_double', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(DOUBLE)))
  void Z3_params_set_double(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    double v,
  ) {
    return _Z3_params_set_double(
      c,
      p,
      k,
      v,
    );
  }

  late final _Z3_params_set_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.Double)>>('Z3_params_set_double');
  late final _Z3_params_set_double = _Z3_params_set_doublePtr.asFunction<
      void Function(Z3_context, Z3_params, Z3_symbol, double)>();

  /// \brief Add a symbol parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_symbol', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(SYMBOL)))
  void Z3_params_set_symbol(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    Z3_symbol v,
  ) {
    return _Z3_params_set_symbol(
      c,
      p,
      k,
      v,
    );
  }

  late final _Z3_params_set_symbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              Z3_symbol)>>('Z3_params_set_symbol');
  late final _Z3_params_set_symbol = _Z3_params_set_symbolPtr.asFunction<
      void Function(Z3_context, Z3_params, Z3_symbol, Z3_symbol)>();

  /// \brief Convert a parameter set into a string. This function is mainly used for printing the
  /// contents of a parameter set.
  ///
  /// def_API('Z3_params_to_string', STRING, (_in(CONTEXT), _in(PARAMS)))
  Z3_string Z3_params_to_string(
    Z3_context c,
    Z3_params p,
  ) {
    return _Z3_params_to_string(
      c,
      p,
    );
  }

  late final _Z3_params_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_params)>>(
          'Z3_params_to_string');
  late final _Z3_params_to_string = _Z3_params_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_params)>();

  /// \brief Validate the parameter set \c p against the parameter description set \c d.
  ///
  /// The procedure invokes the error handler if \c p is invalid.
  ///
  /// def_API('Z3_params_validate', VOID, (_in(CONTEXT), _in(PARAMS), _in(PARAM_DESCRS)))
  void Z3_params_validate(
    Z3_context c,
    Z3_params p,
    Z3_param_descrs d,
  ) {
    return _Z3_params_validate(
      c,
      p,
      d,
    );
  }

  late final _Z3_params_validatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_params, Z3_param_descrs)>>('Z3_params_validate');
  late final _Z3_params_validate = _Z3_params_validatePtr.asFunction<
      void Function(Z3_context, Z3_params, Z3_param_descrs)>();

  /// \brief Increment the reference counter of the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_inc_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
  void Z3_param_descrs_inc_ref(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _Z3_param_descrs_inc_ref(
      c,
      p,
    );
  }

  late final _Z3_param_descrs_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_inc_ref');
  late final _Z3_param_descrs_inc_ref = _Z3_param_descrs_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_param_descrs)>();

  /// \brief Decrement the reference counter of the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_dec_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
  void Z3_param_descrs_dec_ref(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _Z3_param_descrs_dec_ref(
      c,
      p,
    );
  }

  late final _Z3_param_descrs_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_dec_ref');
  late final _Z3_param_descrs_dec_ref = _Z3_param_descrs_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_param_descrs)>();

  /// \brief Return the kind associated with the given parameter name \c n.
  ///
  /// def_API('Z3_param_descrs_get_kind', UINT, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
  int Z3_param_descrs_get_kind(
    Z3_context c,
    Z3_param_descrs p,
    Z3_symbol n,
  ) {
    return _Z3_param_descrs_get_kind(
      c,
      p,
      n,
    );
  }

  late final _Z3_param_descrs_get_kindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_param_descrs,
              Z3_symbol)>>('Z3_param_descrs_get_kind');
  late final _Z3_param_descrs_get_kind = _Z3_param_descrs_get_kindPtr
      .asFunction<int Function(Z3_context, Z3_param_descrs, Z3_symbol)>();

  /// \brief Return the number of parameters in the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_size', UINT, (_in(CONTEXT), _in(PARAM_DESCRS)))
  int Z3_param_descrs_size(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _Z3_param_descrs_size(
      c,
      p,
    );
  }

  late final _Z3_param_descrs_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_param_descrs)>>('Z3_param_descrs_size');
  late final _Z3_param_descrs_size = _Z3_param_descrs_sizePtr.asFunction<
      int Function(Z3_context, Z3_param_descrs)>();

  /// \brief Return the name of the parameter at given index \c i.
  ///
  /// \pre i < Z3_param_descrs_size(c, p)
  ///
  /// def_API('Z3_param_descrs_get_name', SYMBOL, (_in(CONTEXT), _in(PARAM_DESCRS), _in(UINT)))
  Z3_symbol Z3_param_descrs_get_name(
    Z3_context c,
    Z3_param_descrs p,
    int i,
  ) {
    return _Z3_param_descrs_get_name(
      c,
      p,
      i,
    );
  }

  late final _Z3_param_descrs_get_namePtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_param_descrs,
              ffi.UnsignedInt)>>('Z3_param_descrs_get_name');
  late final _Z3_param_descrs_get_name = _Z3_param_descrs_get_namePtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_param_descrs, int)>();

  /// \brief Retrieve documentation string corresponding to parameter name \c s.
  ///
  /// def_API('Z3_param_descrs_get_documentation', STRING, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
  Z3_string Z3_param_descrs_get_documentation(
    Z3_context c,
    Z3_param_descrs p,
    Z3_symbol s,
  ) {
    return _Z3_param_descrs_get_documentation(
      c,
      p,
      s,
    );
  }

  late final _Z3_param_descrs_get_documentationPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_param_descrs,
              Z3_symbol)>>('Z3_param_descrs_get_documentation');
  late final _Z3_param_descrs_get_documentation =
      _Z3_param_descrs_get_documentationPtr.asFunction<
          Z3_string Function(Z3_context, Z3_param_descrs, Z3_symbol)>();

  /// \brief Convert a parameter description set into a string. This function is mainly used for printing the
  /// contents of a parameter description set.
  ///
  /// def_API('Z3_param_descrs_to_string', STRING, (_in(CONTEXT), _in(PARAM_DESCRS)))
  Z3_string Z3_param_descrs_to_string(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _Z3_param_descrs_to_string(
      c,
      p,
    );
  }

  late final _Z3_param_descrs_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_to_string');
  late final _Z3_param_descrs_to_string = _Z3_param_descrs_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_param_descrs)>();

  /// \brief Create a Z3 symbol using an integer.
  ///
  /// Symbols are used to name several term and type constructors.
  ///
  /// NB. Not all integers can be passed to this function.
  /// The legal range of unsigned integers is 0 to 2^30-1.
  ///
  /// \sa Z3_get_symbol_int
  /// \sa Z3_mk_string_symbol
  ///
  /// def_API('Z3_mk_int_symbol', SYMBOL, (_in(CONTEXT), _in(INT)))
  Z3_symbol Z3_mk_int_symbol(
    Z3_context c,
    int i,
  ) {
    return _Z3_mk_int_symbol(
      c,
      i,
    );
  }

  late final _Z3_mk_int_symbolPtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, ffi.Int)>>(
          'Z3_mk_int_symbol');
  late final _Z3_mk_int_symbol =
      _Z3_mk_int_symbolPtr.asFunction<Z3_symbol Function(Z3_context, int)>();

  /// \brief Create a Z3 symbol using a C string.
  ///
  /// Symbols are used to name several term and type constructors.
  ///
  /// \sa Z3_get_symbol_string
  /// \sa Z3_mk_int_symbol
  ///
  /// def_API('Z3_mk_string_symbol', SYMBOL, (_in(CONTEXT), _in(STRING)))
  Z3_symbol Z3_mk_string_symbol(
    Z3_context c,
    Z3_string s,
  ) {
    return _Z3_mk_string_symbol(
      c,
      s,
    );
  }

  late final _Z3_mk_string_symbolPtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_string)>>(
          'Z3_mk_string_symbol');
  late final _Z3_mk_string_symbol = _Z3_mk_string_symbolPtr.asFunction<
      Z3_symbol Function(Z3_context, Z3_string)>();

  /// \brief Create a free (uninterpreted) type using the given name (symbol).
  ///
  /// Two free types are considered the same iff the have the same name.
  ///
  /// def_API('Z3_mk_uninterpreted_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
  Z3_sort Z3_mk_uninterpreted_sort(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _Z3_mk_uninterpreted_sort(
      c,
      s,
    );
  }

  late final _Z3_mk_uninterpreted_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_uninterpreted_sort');
  late final _Z3_mk_uninterpreted_sort = _Z3_mk_uninterpreted_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol)>();

  /// \brief Create the Boolean type.
  ///
  /// This type is used to create propositional variables and predicates.
  ///
  /// def_API('Z3_mk_bool_sort', SORT, (_in(CONTEXT), ))
  Z3_sort Z3_mk_bool_sort(
    Z3_context c,
  ) {
    return _Z3_mk_bool_sort(
      c,
    );
  }

  late final _Z3_mk_bool_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_bool_sort');
  late final _Z3_mk_bool_sort =
      _Z3_mk_bool_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the integer type.
  ///
  /// This type is not the int type found in programming languages.
  /// A machine integer can be represented using bit-vectors. The function
  /// #Z3_mk_bv_sort creates a bit-vector type.
  ///
  /// \sa Z3_mk_bv_sort
  ///
  /// def_API('Z3_mk_int_sort', SORT, (_in(CONTEXT), ))
  Z3_sort Z3_mk_int_sort(
    Z3_context c,
  ) {
    return _Z3_mk_int_sort(
      c,
    );
  }

  late final _Z3_mk_int_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_int_sort');
  late final _Z3_mk_int_sort =
      _Z3_mk_int_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the real type.
  ///
  /// Note that this type is not a floating point number.
  ///
  /// def_API('Z3_mk_real_sort', SORT, (_in(CONTEXT), ))
  Z3_sort Z3_mk_real_sort(
    Z3_context c,
  ) {
    return _Z3_mk_real_sort(
      c,
    );
  }

  late final _Z3_mk_real_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_real_sort');
  late final _Z3_mk_real_sort =
      _Z3_mk_real_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a bit-vector type of the given size.
  ///
  /// This type can also be seen as a machine integer.
  ///
  /// \remark The size of the bit-vector type must be greater than zero.
  ///
  /// def_API('Z3_mk_bv_sort', SORT, (_in(CONTEXT), _in(UINT)))
  Z3_sort Z3_mk_bv_sort(
    Z3_context c,
    int sz,
  ) {
    return _Z3_mk_bv_sort(
      c,
      sz,
    );
  }

  late final _Z3_mk_bv_sortPtr = _lookup<
          ffi.NativeFunction<Z3_sort Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_mk_bv_sort');
  late final _Z3_mk_bv_sort =
      _Z3_mk_bv_sortPtr.asFunction<Z3_sort Function(Z3_context, int)>();

  /// \brief Create a named finite domain sort.
  ///
  /// To create constants that belong to the finite domain,
  /// use the APIs for creating numerals and pass a numeric
  /// constant together with the sort returned by this call.
  /// The numeric constant should be between 0 and the less
  /// than the size of the domain.
  ///
  /// \sa Z3_get_finite_domain_sort_size
  ///
  /// def_API('Z3_mk_finite_domain_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT64)))
  Z3_sort Z3_mk_finite_domain_sort(
    Z3_context c,
    Z3_symbol name,
    int size,
  ) {
    return _Z3_mk_finite_domain_sort(
      c,
      name,
      size,
    );
  }

  late final _Z3_mk_finite_domain_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_symbol, ffi.Uint64)>>('Z3_mk_finite_domain_sort');
  late final _Z3_mk_finite_domain_sort = _Z3_mk_finite_domain_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol, int)>();

  /// \brief Create an array type.
  ///
  /// We usually represent the array type as: \ccode{[domain -> range]}.
  /// Arrays are usually used to model the heap/memory in software verification.
  ///
  /// \sa Z3_mk_select
  /// \sa Z3_mk_store
  ///
  /// def_API('Z3_mk_array_sort', SORT, (_in(CONTEXT), _in(SORT), _in(SORT)))
  Z3_sort Z3_mk_array_sort(
    Z3_context c,
    Z3_sort domain,
    Z3_sort range,
  ) {
    return _Z3_mk_array_sort(
      c,
      domain,
      range,
    );
  }

  late final _Z3_mk_array_sortPtr = _lookup<
          ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort, Z3_sort)>>(
      'Z3_mk_array_sort');
  late final _Z3_mk_array_sort = _Z3_mk_array_sortPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_sort, Z3_sort)>();

  /// \brief Create an array type with N arguments
  ///
  /// \sa Z3_mk_select_n
  /// \sa Z3_mk_store_n
  ///
  /// def_API('Z3_mk_array_sort_n', SORT, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in(SORT)))
  Z3_sort Z3_mk_array_sort_n(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _Z3_mk_array_sort_n(
      c,
      n,
      domain,
      range,
    );
  }

  late final _Z3_mk_array_sort_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_sort>,
              Z3_sort)>>('Z3_mk_array_sort_n');
  late final _Z3_mk_array_sort_n = _Z3_mk_array_sort_nPtr.asFunction<
      Z3_sort Function(Z3_context, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Create a tuple type.
  ///
  /// A tuple with \c n fields has a constructor and \c n projections.
  /// This function will also declare the constructor and projection functions.
  ///
  /// \param c logical context
  /// \param mk_tuple_name name of the constructor function associated with the tuple type.
  /// \param num_fields number of fields in the tuple type.
  /// \param field_names name of the projection functions.
  /// \param field_sorts type of the tuple fields.
  /// \param mk_tuple_decl output parameter that will contain the constructor declaration.
  /// \param proj_decl output parameter that will contain the projection function declarations. This field must be a buffer of size \c num_fields allocated by the user.
  ///
  /// def_API('Z3_mk_tuple_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
  Z3_sort Z3_mk_tuple_sort(
    Z3_context c,
    Z3_symbol mk_tuple_name,
    int num_fields,
    ffi.Pointer<Z3_symbol> field_names,
    ffi.Pointer<Z3_sort> field_sorts,
    ffi.Pointer<Z3_func_decl> mk_tuple_decl,
    ffi.Pointer<Z3_func_decl> proj_decl,
  ) {
    return _Z3_mk_tuple_sort(
      c,
      mk_tuple_name,
      num_fields,
      field_names,
      field_sorts,
      mk_tuple_decl,
      proj_decl,
    );
  }

  late final _Z3_mk_tuple_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_tuple_sort');
  late final _Z3_mk_tuple_sort = _Z3_mk_tuple_sortPtr.asFunction<
      Z3_sort Function(
          Z3_context,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a enumeration sort.
  ///
  /// An enumeration sort with \c n elements.
  /// This function will also declare the functions corresponding to the enumerations.
  ///
  /// \param c logical context
  /// \param name name of the enumeration sort.
  /// \param n number of elements in enumeration sort.
  /// \param enum_names names of the enumerated elements.
  /// \param enum_consts constants corresponding to the enumerated elements.
  /// \param enum_testers predicates testing if terms of the enumeration sort correspond to an enumeration.
  ///
  /// For example, if this function is called with three symbols A, B, C and the name S, then
  /// \c s is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
  /// \c enum_consts. The array \c enum_testers has three predicates of type \ccode{(s -> Bool)}.
  /// The first predicate (corresponding to A) is true when applied to A, and false otherwise.
  /// Similarly for the other predicates.
  ///
  /// def_API('Z3_mk_enumeration_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _out_array(2, FUNC_DECL), _out_array(2, FUNC_DECL)))
  Z3_sort Z3_mk_enumeration_sort(
    Z3_context c,
    Z3_symbol name,
    int n,
    ffi.Pointer<Z3_symbol> enum_names,
    ffi.Pointer<Z3_func_decl> enum_consts,
    ffi.Pointer<Z3_func_decl> enum_testers,
  ) {
    return _Z3_mk_enumeration_sort(
      c,
      name,
      n,
      enum_names,
      enum_consts,
      enum_testers,
    );
  }

  late final _Z3_mk_enumeration_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_enumeration_sort');
  late final _Z3_mk_enumeration_sort = _Z3_mk_enumeration_sortPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_symbol, int, ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a list sort
  ///
  /// A list sort over \c elem_sort
  /// This function declares the corresponding constructors and testers for lists.
  ///
  /// \param c logical context
  /// \param name name of the list sort.
  /// \param elem_sort sort of list elements.
  /// \param nil_decl declaration for the empty list.
  /// \param is_nil_decl test for the empty list.
  /// \param cons_decl declaration for a cons cell.
  /// \param is_cons_decl cons cell test.
  /// \param head_decl list head.
  /// \param tail_decl list tail.
  ///
  /// def_API('Z3_mk_list_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(SORT), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL)))
  Z3_sort Z3_mk_list_sort(
    Z3_context c,
    Z3_symbol name,
    Z3_sort elem_sort,
    ffi.Pointer<Z3_func_decl> nil_decl,
    ffi.Pointer<Z3_func_decl> is_nil_decl,
    ffi.Pointer<Z3_func_decl> cons_decl,
    ffi.Pointer<Z3_func_decl> is_cons_decl,
    ffi.Pointer<Z3_func_decl> head_decl,
    ffi.Pointer<Z3_func_decl> tail_decl,
  ) {
    return _Z3_mk_list_sort(
      c,
      name,
      elem_sort,
      nil_decl,
      is_nil_decl,
      cons_decl,
      is_cons_decl,
      head_decl,
      tail_decl,
    );
  }

  late final _Z3_mk_list_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              Z3_sort,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_list_sort');
  late final _Z3_mk_list_sort = _Z3_mk_list_sortPtr.asFunction<
      Z3_sort Function(
          Z3_context,
          Z3_symbol,
          Z3_sort,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a constructor.
  ///
  /// \param c logical context.
  /// \param name constructor name.
  /// \param recognizer name of recognizer function.
  /// \param num_fields number of fields in constructor.
  /// \param field_names names of the constructor fields.
  /// \param sorts field sorts, 0 if the field sort refers to a recursive sort.
  /// \param sort_refs reference to datatype sort that is an argument to the constructor; if the corresponding
  /// sort reference is 0, then the value in sort_refs should be an index referring to
  /// one of the recursive datatypes that is declared.
  ///
  /// \sa Z3_del_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_query_constructor
  ///
  /// def_API('Z3_mk_constructor', CONSTRUCTOR, (_in(CONTEXT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(3, SYMBOL), _in_array(3, SORT), _in_array(3, UINT)))
  Z3_constructor Z3_mk_constructor(
    Z3_context c,
    Z3_symbol name,
    Z3_symbol recognizer,
    int num_fields,
    ffi.Pointer<Z3_symbol> field_names,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<ffi.UnsignedInt> sort_refs,
  ) {
    return _Z3_mk_constructor(
      c,
      name,
      recognizer,
      num_fields,
      field_names,
      sorts,
      sort_refs,
    );
  }

  late final _Z3_mk_constructorPtr = _lookup<
      ffi.NativeFunction<
          Z3_constructor Function(
              Z3_context,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_mk_constructor');
  late final _Z3_mk_constructor = _Z3_mk_constructorPtr.asFunction<
      Z3_constructor Function(
          Z3_context,
          Z3_symbol,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Reclaim memory allocated to constructor.
  ///
  /// \param c logical context.
  /// \param constr constructor.
  ///
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_del_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR)))
  void Z3_del_constructor(
    Z3_context c,
    Z3_constructor constr,
  ) {
    return _Z3_del_constructor(
      c,
      constr,
    );
  }

  late final _Z3_del_constructorPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_constructor)>>(
      'Z3_del_constructor');
  late final _Z3_del_constructor = _Z3_del_constructorPtr.asFunction<
      void Function(Z3_context, Z3_constructor)>();

  /// \brief Create datatype, such as lists, trees, records, enumerations or unions of records.
  /// The datatype may be recursive. Return the datatype sort.
  ///
  /// \param c logical context.
  /// \param name name of datatype.
  /// \param num_constructors number of constructors passed in.
  /// \param constructors array of constructor containers.
  ///
  /// \sa Z3_mk_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_mk_datatypes
  ///
  /// def_API('Z3_mk_datatype', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _inout_array(2, CONSTRUCTOR)))
  Z3_sort Z3_mk_datatype(
    Z3_context c,
    Z3_symbol name,
    int num_constructors,
    ffi.Pointer<Z3_constructor> constructors,
  ) {
    return _Z3_mk_datatype(
      c,
      name,
      num_constructors,
      constructors,
    );
  }

  late final _Z3_mk_datatypePtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_constructor>)>>('Z3_mk_datatype');
  late final _Z3_mk_datatype = _Z3_mk_datatypePtr.asFunction<
      Z3_sort Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_constructor>)>();

  /// \brief create a forward reference to a recursive datatype being declared.
  /// The forward reference can be used in a nested occurrence: the range of an array
  /// or as element sort of a sequence. The forward reference should only be used when
  /// used in an accessor for a recursive datatype that gets declared.
  ///
  /// Forward references can replace the use sort references, that are unsigned integers
  /// in the \c Z3_mk_constructor call
  ///
  /// def_API('Z3_mk_datatype_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
  Z3_sort Z3_mk_datatype_sort(
    Z3_context c,
    Z3_symbol name,
  ) {
    return _Z3_mk_datatype_sort(
      c,
      name,
    );
  }

  late final _Z3_mk_datatype_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_datatype_sort');
  late final _Z3_mk_datatype_sort = _Z3_mk_datatype_sortPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_symbol)>();

  /// \brief Create list of constructors.
  ///
  /// \param c logical context.
  /// \param num_constructors number of constructors in list.
  /// \param constructors list of constructors.
  ///
  /// \sa Z3_del_constructor_list
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_mk_constructor_list', CONSTRUCTOR_LIST, (_in(CONTEXT), _in(UINT), _in_array(1, CONSTRUCTOR)))
  Z3_constructor_list Z3_mk_constructor_list(
    Z3_context c,
    int num_constructors,
    ffi.Pointer<Z3_constructor> constructors,
  ) {
    return _Z3_mk_constructor_list(
      c,
      num_constructors,
      constructors,
    );
  }

  late final _Z3_mk_constructor_listPtr = _lookup<
      ffi.NativeFunction<
          Z3_constructor_list Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_constructor>)>>('Z3_mk_constructor_list');
  late final _Z3_mk_constructor_list = _Z3_mk_constructor_listPtr.asFunction<
      Z3_constructor_list Function(
          Z3_context, int, ffi.Pointer<Z3_constructor>)>();

  /// \brief Reclaim memory allocated for constructor list.
  ///
  /// Each constructor inside the constructor list must be independently reclaimed using #Z3_del_constructor.
  ///
  /// \param c logical context.
  /// \param clist constructor list container.
  ///
  /// \sa Z3_mk_constructor_list
  ///
  /// def_API('Z3_del_constructor_list', VOID, (_in(CONTEXT), _in(CONSTRUCTOR_LIST)))
  void Z3_del_constructor_list(
    Z3_context c,
    Z3_constructor_list clist,
  ) {
    return _Z3_del_constructor_list(
      c,
      clist,
    );
  }

  late final _Z3_del_constructor_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_constructor_list)>>('Z3_del_constructor_list');
  late final _Z3_del_constructor_list = _Z3_del_constructor_listPtr.asFunction<
      void Function(Z3_context, Z3_constructor_list)>();

  /// \brief Create mutually recursive datatypes.
  ///
  /// \param c logical context.
  /// \param num_sorts number of datatype sorts.
  /// \param sort_names names of datatype sorts.
  /// \param sorts array of datatype sorts.
  /// \param constructor_lists list of constructors, one list per sort.
  ///
  /// \sa Z3_mk_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_mk_datatype
  ///
  /// def_API('Z3_mk_datatypes', VOID, (_in(CONTEXT), _in(UINT), _in_array(1, SYMBOL), _out_array(1, SORT), _inout_array(1, CONSTRUCTOR_LIST)))
  void Z3_mk_datatypes(
    Z3_context c,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_constructor_list> constructor_lists,
  ) {
    return _Z3_mk_datatypes(
      c,
      num_sorts,
      sort_names,
      sorts,
      constructor_lists,
    );
  }

  late final _Z3_mk_datatypesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_constructor_list>)>>('Z3_mk_datatypes');
  late final _Z3_mk_datatypes = _Z3_mk_datatypesPtr.asFunction<
      void Function(Z3_context, int, ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_constructor_list>)>();

  /// \brief Query constructor for declared functions.
  ///
  /// \param c logical context.
  /// \param constr constructor container. The container must have been passed in to a #Z3_mk_datatype call.
  /// \param num_fields number of accessor fields in the constructor.
  /// \param constructor constructor function declaration, allocated by user.
  /// \param tester constructor test function declaration, allocated by user.
  /// \param accessors array of accessor function declarations allocated by user. The array must contain num_fields elements.
  ///
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_query_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR), _in(UINT), _out(FUNC_DECL), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
  void Z3_query_constructor(
    Z3_context c,
    Z3_constructor constr,
    int num_fields,
    ffi.Pointer<Z3_func_decl> constructor,
    ffi.Pointer<Z3_func_decl> tester,
    ffi.Pointer<Z3_func_decl> accessors,
  ) {
    return _Z3_query_constructor(
      c,
      constr,
      num_fields,
      constructor,
      tester,
      accessors,
    );
  }

  late final _Z3_query_constructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_constructor,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_query_constructor');
  late final _Z3_query_constructor = _Z3_query_constructorPtr.asFunction<
      void Function(Z3_context, Z3_constructor, int, ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Declare a constant or function.
  ///
  /// \param c logical context.
  /// \param s name of the constant or function.
  /// \param domain_size number of arguments. It is 0 when declaring a constant.
  /// \param domain array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.
  /// \param range sort of the constant or the return sort of the function.
  ///
  /// After declaring a constant or function, the function
  /// #Z3_mk_app can be used to create a constant or function
  /// application.
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_mk_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl Z3_mk_func_decl(
    Z3_context c,
    Z3_symbol s,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _Z3_mk_func_decl(
      c,
      s,
      domain_size,
      domain,
      range,
    );
  }

  late final _Z3_mk_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_func_decl');
  late final _Z3_mk_func_decl = _Z3_mk_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Create a constant or function application.
  ///
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_func_decl
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_mk_app', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
  Z3_ast Z3_mk_app(
    Z3_context c,
    Z3_func_decl d,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_app(
      c,
      d,
      num_args,
      args,
    );
  }

  late final _Z3_mk_appPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_app');
  late final _Z3_mk_app = _Z3_mk_appPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Declare and create a constant.
  ///
  /// This function is a shorthand for:
  /// \code
  /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
  /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
  /// \endcode
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_fresh_const
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_const', AST, (_in(CONTEXT), _in(SYMBOL), _in(SORT)))
  Z3_ast Z3_mk_const(
    Z3_context c,
    Z3_symbol s,
    Z3_sort ty,
  ) {
    return _Z3_mk_const(
      c,
      s,
      ty,
    );
  }

  late final _Z3_mk_constPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_symbol, Z3_sort)>>(
      'Z3_mk_const');
  late final _Z3_mk_const = _Z3_mk_constPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_symbol, Z3_sort)>();

  /// \brief Declare a fresh constant or function.
  ///
  /// Z3 will generate an unique name for this function declaration.
  /// If prefix is different from \c NULL, then the name generate by Z3 will start with \c prefix.
  ///
  /// \remark If \c prefix is \c NULL, then it is assumed to be the empty string.
  ///
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_fresh_func_decl', FUNC_DECL, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl Z3_mk_fresh_func_decl(
    Z3_context c,
    Z3_string prefix,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _Z3_mk_fresh_func_decl(
      c,
      prefix,
      domain_size,
      domain,
      range,
    );
  }

  late final _Z3_mk_fresh_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_string, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_fresh_func_decl');
  late final _Z3_mk_fresh_func_decl = _Z3_mk_fresh_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_string, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Declare and create a fresh constant.
  ///
  /// This function is a shorthand for:
  /// \code Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0); \endcode
  ///
  /// \remark If \c prefix is \c NULL, then it is assumed to be the empty string.
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_const
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_fresh_const', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
  Z3_ast Z3_mk_fresh_const(
    Z3_context c,
    Z3_string prefix,
    Z3_sort ty,
  ) {
    return _Z3_mk_fresh_const(
      c,
      prefix,
      ty,
    );
  }

  late final _Z3_mk_fresh_constPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>>(
      'Z3_mk_fresh_const');
  late final _Z3_mk_fresh_const = _Z3_mk_fresh_constPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_string, Z3_sort)>();

  /// \brief Declare a recursive function
  ///
  /// \param c logical context.
  /// \param s name of the function.
  /// \param domain_size number of arguments. It should be greater than 0.
  /// \param domain array containing the sort of each argument. The array must contain domain_size elements.
  /// \param range sort of the constant or the return sort of the function.
  ///
  /// After declaring recursive function, it should be associated with a recursive definition #Z3_add_rec_def.
  /// The function #Z3_mk_app can be used to create a constant or function
  /// application.
  ///
  /// \sa Z3_add_rec_def
  /// \sa Z3_mk_app
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_rec_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl Z3_mk_rec_func_decl(
    Z3_context c,
    Z3_symbol s,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _Z3_mk_rec_func_decl(
      c,
      s,
      domain_size,
      domain,
      range,
    );
  }

  late final _Z3_mk_rec_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_rec_func_decl');
  late final _Z3_mk_rec_func_decl = _Z3_mk_rec_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Define the body of a recursive function.
  ///
  /// \param c logical context.
  /// \param f function declaration.
  /// \param n number of arguments to the function
  /// \param args constants that are used as arguments to the recursive function in the definition.
  /// \param body body of the recursive function
  ///
  /// After declaring a recursive function or a collection of  mutually recursive functions, use
  /// this function to provide the definition for the recursive function.
  ///
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_add_rec_def', VOID, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST), _in(AST)))
  void Z3_add_rec_def(
    Z3_context c,
    Z3_func_decl f,
    int n,
    ffi.Pointer<Z3_ast> args,
    Z3_ast body,
  ) {
    return _Z3_add_rec_def(
      c,
      f,
      n,
      args,
      body,
    );
  }

  late final _Z3_add_rec_defPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, Z3_ast)>>('Z3_add_rec_def');
  late final _Z3_add_rec_def = _Z3_add_rec_defPtr.asFunction<
      void Function(
          Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// @name Propositional Logic and Equality */
  /// /**@{*/
  /// /**
  /// \brief Create an AST node representing \c true.
  ///
  /// def_API('Z3_mk_true', AST, (_in(CONTEXT), ))
  Z3_ast Z3_mk_true(
    Z3_context c,
  ) {
    return _Z3_mk_true(
      c,
    );
  }

  late final _Z3_mk_truePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_true');
  late final _Z3_mk_true =
      _Z3_mk_truePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create an AST node representing \c false.
  ///
  /// def_API('Z3_mk_false', AST, (_in(CONTEXT), ))
  Z3_ast Z3_mk_false(
    Z3_context c,
  ) {
    return _Z3_mk_false(
      c,
    );
  }

  late final _Z3_mk_falsePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_false');
  late final _Z3_mk_false =
      _Z3_mk_falsePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create an AST node representing \ccode{l = r}.
  ///
  /// The nodes \c l and \c r must have the same type.
  ///
  /// def_API('Z3_mk_eq', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_eq(
    Z3_context c,
    Z3_ast l,
    Z3_ast r,
  ) {
    return _Z3_mk_eq(
      c,
      l,
      r,
    );
  }

  late final _Z3_mk_eqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_eq');
  late final _Z3_mk_eq =
      _Z3_mk_eqPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{distinct(args[0], ..., args[num_args-1])}.
  ///
  /// The \c distinct construct is used for declaring the arguments pairwise distinct.
  /// That is, \ccode{Forall 0 <= i < j < num_args. not args[i] = args[j]}.
  ///
  /// All arguments must have the same sort.
  ///
  /// \remark The number of arguments of a distinct construct must be greater than one.
  ///
  /// def_API('Z3_mk_distinct', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_distinct(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_distinct(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_distinctPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_distinct');
  late final _Z3_mk_distinct = _Z3_mk_distinctPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{not(a)}.
  ///
  /// The node \c a must have Boolean sort.
  ///
  /// def_API('Z3_mk_not', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_not(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_mk_not(
      c,
      a,
    );
  }

  late final _Z3_mk_notPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_not');
  late final _Z3_mk_not =
      _Z3_mk_notPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create an AST node representing an if-then-else: \ccode{ite(t1, t2, t3)}.
  ///
  /// The node \c t1 must have Boolean sort, \c t2 and \c t3 must have the same sort.
  /// The sort of the new node is equal to the sort of \c t2 and \c t3.
  ///
  /// def_API('Z3_mk_ite', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_ite(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    Z3_ast t3,
  ) {
    return _Z3_mk_ite(
      c,
      t1,
      t2,
      t3,
    );
  }

  late final _Z3_mk_itePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_ite');
  late final _Z3_mk_ite = _Z3_mk_itePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 iff t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_iff', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_iff(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_iff(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_iffPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_iff');
  late final _Z3_mk_iff =
      _Z3_mk_iffPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 implies t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_implies', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_implies(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_implies(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_impliesPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_implies');
  late final _Z3_mk_implies = _Z3_mk_impliesPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 xor t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_xor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_xor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_xor(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_xorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_xor');
  late final _Z3_mk_xor =
      _Z3_mk_xorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{args[0] and ... and args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have Boolean sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_and', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_and(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_and(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_andPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_and');
  late final _Z3_mk_and = _Z3_mk_andPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] or ... or args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have Boolean sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_or', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_or(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_or(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_orPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_or');
  late final _Z3_mk_or = _Z3_mk_orPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// @name Integers and Reals */
  /// /**@{*/
  /// /**
  /// \brief Create an AST node representing \ccode{args[0] + ... + args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_add', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_add(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_add(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_addPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_add');
  late final _Z3_mk_add = _Z3_mk_addPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] * ... * args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark Z3 has limited support for non-linear arithmetic.
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_mul', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_mul(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_mul(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_mulPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_mul');
  late final _Z3_mk_mul = _Z3_mk_mulPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] - ... - args[num_args - 1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_sub', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_sub(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_sub(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_subPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_sub');
  late final _Z3_mk_sub = _Z3_mk_subPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{- arg}.
  ///
  /// The arguments must have int or real type.
  ///
  /// def_API('Z3_mk_unary_minus', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_unary_minus(
    Z3_context c,
    Z3_ast arg,
  ) {
    return _Z3_mk_unary_minus(
      c,
      arg,
    );
  }

  late final _Z3_mk_unary_minusPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_unary_minus');
  late final _Z3_mk_unary_minus =
      _Z3_mk_unary_minusPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 div arg2}.
  ///
  /// The arguments must either both have int type or both have real type.
  /// If the arguments have int type, then the result type is an int type, otherwise the
  /// the result type is real.
  ///
  /// def_API('Z3_mk_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_div(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_div(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_divPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_div');
  late final _Z3_mk_div =
      _Z3_mk_divPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 mod arg2}.
  ///
  /// The arguments must have int type.
  ///
  /// def_API('Z3_mk_mod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_mod(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_mod(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_modPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_mod');
  late final _Z3_mk_mod =
      _Z3_mk_modPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 rem arg2}.
  ///
  /// The arguments must have int type.
  ///
  /// def_API('Z3_mk_rem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_rem(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_rem(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_remPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_rem');
  late final _Z3_mk_rem =
      _Z3_mk_remPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 ^ arg2}.
  ///
  /// The arguments must have int or real type.
  ///
  /// def_API('Z3_mk_power', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_power(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_power(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_powerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_power');
  late final _Z3_mk_power =
      _Z3_mk_powerPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create less than.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_lt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_lt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_lt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_lt');
  late final _Z3_mk_lt =
      _Z3_mk_ltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_le(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_le(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_le');
  late final _Z3_mk_le =
      _Z3_mk_lePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_gt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_gt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_gt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_gtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_gt');
  late final _Z3_mk_gt =
      _Z3_mk_gtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_ge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_ge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_ge(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_gePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ge');
  late final _Z3_mk_ge =
      _Z3_mk_gePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create division predicate.
  ///
  /// The nodes \c t1 and \c t2 must be of integer sort.
  /// The predicate is true when \c t1 divides \c t2. For the predicate to be part of
  /// linear integer arithmetic, the first argument \c t1 must be a non-zero integer.
  ///
  /// def_API('Z3_mk_divides', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_divides(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_divides(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_dividesPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_divides');
  late final _Z3_mk_divides = _Z3_mk_dividesPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Coerce an integer to a real.
  ///
  /// There is also a converse operation exposed.
  /// It follows the semantics prescribed by the SMT-LIB standard.
  ///
  /// You can take the floor of a real by
  /// creating an auxiliary integer constant \c k and
  /// and asserting \ccode{mk_int2real(k) <= t1 < mk_int2real(k)+1}.
  ///
  /// The node \c t1 must have sort integer.
  ///
  /// \sa Z3_mk_real2int
  /// \sa Z3_mk_is_int
  ///
  /// def_API('Z3_mk_int2real', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_int2real(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_int2real(
      c,
      t1,
    );
  }

  late final _Z3_mk_int2realPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_int2real');
  late final _Z3_mk_int2real =
      _Z3_mk_int2realPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Coerce a real to an integer.
  ///
  /// The semantics of this function follows the SMT-LIB standard
  /// for the function to_int
  ///
  /// \sa Z3_mk_int2real
  /// \sa Z3_mk_is_int
  ///
  /// def_API('Z3_mk_real2int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_real2int(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_real2int(
      c,
      t1,
    );
  }

  late final _Z3_mk_real2intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_real2int');
  late final _Z3_mk_real2int =
      _Z3_mk_real2intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check if a real number is an integer.
  ///
  /// \sa Z3_mk_int2real
  /// \sa Z3_mk_real2int
  ///
  /// def_API('Z3_mk_is_int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_is_int(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_is_int(
      c,
      t1,
    );
  }

  late final _Z3_mk_is_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_is_int');
  late final _Z3_mk_is_int =
      _Z3_mk_is_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Bit-vectors */
  /// /**@{*/
  /// /**
  /// \brief Bitwise negation.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnot', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_bvnot(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_bvnot(
      c,
      t1,
    );
  }

  late final _Z3_mk_bvnotPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvnot');
  late final _Z3_mk_bvnot =
      _Z3_mk_bvnotPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Take conjunction of bits in vector, return vector of length 1.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvredand', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_bvredand(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_bvredand(
      c,
      t1,
    );
  }

  late final _Z3_mk_bvredandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvredand');
  late final _Z3_mk_bvredand =
      _Z3_mk_bvredandPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Take disjunction of bits in vector, return vector of length 1.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvredor', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_bvredor(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_bvredor(
      c,
      t1,
    );
  }

  late final _Z3_mk_bvredorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvredor');
  late final _Z3_mk_bvredor =
      _Z3_mk_bvredorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Bitwise and.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvand(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvand(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvand');
  late final _Z3_mk_bvand =
      _Z3_mk_bvandPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise or.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvor(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvor');
  late final _Z3_mk_bvor =
      _Z3_mk_bvorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise exclusive-or.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvxor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvxor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvxor(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvxorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvxor');
  late final _Z3_mk_bvxor =
      _Z3_mk_bvxorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise nand.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvnand(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvnand(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvnandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvnand');
  late final _Z3_mk_bvnand = _Z3_mk_bvnandPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise nor.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvnor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvnor(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvnorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvnor');
  late final _Z3_mk_bvnor =
      _Z3_mk_bvnorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise xnor.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvxnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvxnor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvxnor(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvxnorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvxnor');
  late final _Z3_mk_bvxnor = _Z3_mk_bvxnorPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement unary minus.
  ///
  /// The node \c t1 must have bit-vector sort.
  ///
  /// def_API('Z3_mk_bvneg', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_bvneg(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_bvneg(
      c,
      t1,
    );
  }

  late final _Z3_mk_bvnegPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvneg');
  late final _Z3_mk_bvneg =
      _Z3_mk_bvnegPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Standard two's complement addition.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvadd', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvadd(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvadd(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvaddPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvadd');
  late final _Z3_mk_bvadd =
      _Z3_mk_bvaddPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement subtraction.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsub(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsub(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsubPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsub');
  late final _Z3_mk_bvsub =
      _Z3_mk_bvsubPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement multiplication.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvmul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvmul(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvmul(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvmulPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvmul');
  late final _Z3_mk_bvmul =
      _Z3_mk_bvmulPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned division.
  ///
  /// It is defined as the \c floor of \ccode{t1/t2} if \c t2 is
  /// different from zero. If \ccode{t2} is zero, then the result
  /// is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvudiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvudiv(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvudiv(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvudivPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvudiv');
  late final _Z3_mk_bvudiv = _Z3_mk_bvudivPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed division.
  ///
  /// It is defined in the following way:
  ///
  /// - The \c floor of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 >= 0}.
  ///
  /// - The \c ceiling of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 < 0}.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsdiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsdiv(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsdiv(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsdivPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsdiv');
  late final _Z3_mk_bvsdiv = _Z3_mk_bvsdivPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned remainder.
  ///
  /// It is defined as \ccode{t1 - (t1 /u t2) * t2}, where \ccode{/u} represents unsigned division.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvurem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvurem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvurem(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvuremPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvurem');
  late final _Z3_mk_bvurem = _Z3_mk_bvuremPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed remainder (sign follows dividend).
  ///
  /// It is defined as \ccode{t1 - (t1 /s t2) * t2}, where \ccode{/s} represents signed division.
  /// The most significant bit (sign) of the result is equal to the most significant bit of \c t1.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// \sa Z3_mk_bvsmod
  ///
  /// def_API('Z3_mk_bvsrem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsrem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsrem(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsremPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsrem');
  late final _Z3_mk_bvsrem = _Z3_mk_bvsremPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed remainder (sign follows divisor).
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// \sa Z3_mk_bvsrem
  ///
  /// def_API('Z3_mk_bvsmod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsmod(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsmod(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsmodPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsmod');
  late final _Z3_mk_bvsmod = _Z3_mk_bvsmodPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned less than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvult', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvult(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvult(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvultPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvult');
  late final _Z3_mk_bvult =
      _Z3_mk_bvultPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed less than.
  ///
  /// It abbreviates:
  /// \code
  /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
  /// (= (extract[|m-1|:|m-1|] t2) bit0))
  /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
  /// (bvult t1 t2)))
  /// \endcode
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvslt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvslt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvslt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvslt');
  late final _Z3_mk_bvslt =
      _Z3_mk_bvsltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvule', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvule(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvule(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvulePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvule');
  late final _Z3_mk_bvule =
      _Z3_mk_bvulePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsle', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsle(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsle(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvslePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsle');
  late final _Z3_mk_bvsle =
      _Z3_mk_bvslePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvuge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvuge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvuge(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvugePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvuge');
  late final _Z3_mk_bvuge =
      _Z3_mk_bvugePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsge(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsgePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsge');
  late final _Z3_mk_bvsge =
      _Z3_mk_bvsgePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvugt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvugt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvugt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvugtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvugt');
  late final _Z3_mk_bvugt =
      _Z3_mk_bvugtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsgt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsgt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsgt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsgtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsgt');
  late final _Z3_mk_bvsgt =
      _Z3_mk_bvsgtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Concatenate the given bit-vectors.
  ///
  /// The nodes \c t1 and \c t2 must have (possibly different) bit-vector sorts
  ///
  /// The result is a bit-vector of size \ccode{n1+n2}, where \c n1 (\c n2) is the size
  /// of \c t1 (\c t2).
  ///
  /// def_API('Z3_mk_concat', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_concat(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_concat(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_concatPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_concat');
  late final _Z3_mk_concat = _Z3_mk_concatPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Extract the bits \c high down to \c low from a bit-vector of
  /// size \c m to yield a new bit-vector of size \c n, where \ccode{n = high - low + 1}.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_extract', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_extract(
    Z3_context c,
    int high,
    int low,
    Z3_ast t1,
  ) {
    return _Z3_mk_extract(
      c,
      high,
      low,
      t1,
    );
  }

  late final _Z3_mk_extractPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.UnsignedInt,
              Z3_ast)>>('Z3_mk_extract');
  late final _Z3_mk_extract = _Z3_mk_extractPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, Z3_ast)>();

  /// \brief Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of
  /// size \ccode{m+i}, where \c m is the size of the given
  /// bit-vector.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_sign_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_sign_ext(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_sign_ext(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_sign_extPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_sign_ext');
  late final _Z3_mk_sign_ext =
      _Z3_mk_sign_extPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Extend the given bit-vector with zeros to the (unsigned) equivalent
  /// bit-vector of size \ccode{m+i}, where \c m is the size of the
  /// given bit-vector.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_zero_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_zero_ext(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_zero_ext(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_zero_extPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_zero_ext');
  late final _Z3_mk_zero_ext =
      _Z3_mk_zero_extPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Repeat the given bit-vector up length \ccode{i}.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_repeat', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_repeat(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_repeat(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_repeatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_repeat');
  late final _Z3_mk_repeat =
      _Z3_mk_repeatPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Extracts the bit at position \ccode{i} of a bit-vector and
  /// yields a boolean.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bit2bool', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_bit2bool(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_bit2bool(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_bit2boolPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_bit2bool');
  late final _Z3_mk_bit2bool =
      _Z3_mk_bit2boolPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Shift left.
  ///
  /// It is equivalent to multiplication by \ccode{2^x} where \c x is the value of the
  /// third argument.
  ///
  /// NB. The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvshl', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvshl(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvshl(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvshlPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvshl');
  late final _Z3_mk_bvshl =
      _Z3_mk_bvshlPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Logical shift right.
  ///
  /// It is equivalent to unsigned division by \ccode{2^x} where \c x is the
  /// value of the third argument.
  ///
  /// NB. The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvlshr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvlshr(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvlshr(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvlshrPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvlshr');
  late final _Z3_mk_bvlshr = _Z3_mk_bvlshrPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Arithmetic shift right.
  ///
  /// It is like logical shift right except that the most significant
  /// bits of the result always copy the most significant bit of the
  /// second argument.
  ///
  /// The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvashr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvashr(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvashr(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvashrPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvashr');
  late final _Z3_mk_bvashr = _Z3_mk_bvashrPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the left \c i times.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_rotate_left', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_rotate_left(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_rotate_left(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_rotate_leftPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_rotate_left');
  late final _Z3_mk_rotate_left = _Z3_mk_rotate_leftPtr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the right \c i times.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_rotate_right', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_rotate_right(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _Z3_mk_rotate_right(
      c,
      i,
      t1,
    );
  }

  late final _Z3_mk_rotate_rightPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_rotate_right');
  late final _Z3_mk_rotate_right = _Z3_mk_rotate_rightPtr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the left \c t2 times.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_ext_rotate_left', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_ext_rotate_left(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_ext_rotate_left(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_ext_rotate_leftPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ext_rotate_left');
  late final _Z3_mk_ext_rotate_left = _Z3_mk_ext_rotate_leftPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the right \c t2 times.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_ext_rotate_right', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_ext_rotate_right(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_ext_rotate_right(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_ext_rotate_rightPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ext_rotate_right');
  late final _Z3_mk_ext_rotate_right = _Z3_mk_ext_rotate_rightPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an \c n bit bit-vector from the integer argument \c t1.
  ///
  /// The resulting bit-vector has \c n bits, where the i'th bit (counting
  /// from 0 to \c n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.
  ///
  /// The node \c t1 must have integer sort.
  ///
  /// def_API('Z3_mk_int2bv', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast Z3_mk_int2bv(
    Z3_context c,
    int n,
    Z3_ast t1,
  ) {
    return _Z3_mk_int2bv(
      c,
      n,
      t1,
    );
  }

  late final _Z3_mk_int2bvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_int2bv');
  late final _Z3_mk_int2bv =
      _Z3_mk_int2bvPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Create an integer from the bit-vector argument \c t1.
  /// If \c is_signed is false, then the bit-vector \c t1 is treated as unsigned.
  /// So the result is non-negative
  /// and in the range \ccode{[0..2^N-1]}, where N are the number of bits in \c t1.
  /// If \c is_signed is true, \c t1 is treated as a signed bit-vector.
  ///
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bv2int', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_ast Z3_mk_bv2int(
    Z3_context c,
    Z3_ast t1,
    int is_signed,
  ) {
    return _Z3_mk_bv2int(
      c,
      t1,
      is_signed,
    );
  }

  late final _Z3_mk_bv2intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, ffi.Int)>>(
          'Z3_mk_bv2int');
  late final _Z3_mk_bv2int =
      _Z3_mk_bv2intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Create a predicate that checks that the bit-wise addition
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvadd_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast Z3_mk_bvadd_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    int is_signed,
  ) {
    return _Z3_mk_bvadd_no_overflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _Z3_mk_bvadd_no_overflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, ffi.Int)>>('Z3_mk_bvadd_no_overflow');
  late final _Z3_mk_bvadd_no_overflow = _Z3_mk_bvadd_no_overflowPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Create a predicate that checks that the bit-wise signed addition
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvadd_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvadd_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvadd_no_underflow(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvadd_no_underflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvadd_no_underflow');
  late final _Z3_mk_bvadd_no_underflow = _Z3_mk_bvadd_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise signed subtraction
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsub_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsub_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsub_no_overflow(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsub_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsub_no_overflow');
  late final _Z3_mk_bvsub_no_overflow = _Z3_mk_bvsub_no_overflowPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise subtraction
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsub_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast Z3_mk_bvsub_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    int is_signed,
  ) {
    return _Z3_mk_bvsub_no_underflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _Z3_mk_bvsub_no_underflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.Int)>>('Z3_mk_bvsub_no_underflow');
  late final _Z3_mk_bvsub_no_underflow = _Z3_mk_bvsub_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Create a predicate that checks that the bit-wise signed division
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsdiv_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvsdiv_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvsdiv_no_overflow(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvsdiv_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsdiv_no_overflow');
  late final _Z3_mk_bvsdiv_no_overflow = _Z3_mk_bvsdiv_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check that bit-wise negation does not overflow when
  /// \c t1 is interpreted as a signed bit-vector.
  ///
  /// The node \c t1 must have bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvneg_no_overflow', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_bvneg_no_overflow(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _Z3_mk_bvneg_no_overflow(
      c,
      t1,
    );
  }

  late final _Z3_mk_bvneg_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvneg_no_overflow');
  late final _Z3_mk_bvneg_no_overflow = _Z3_mk_bvneg_no_overflowPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise multiplication
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvmul_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast Z3_mk_bvmul_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    int is_signed,
  ) {
    return _Z3_mk_bvmul_no_overflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _Z3_mk_bvmul_no_overflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, ffi.Int)>>('Z3_mk_bvmul_no_overflow');
  late final _Z3_mk_bvmul_no_overflow = _Z3_mk_bvmul_no_overflowPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Create a predicate that checks that the bit-wise signed multiplication
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvmul_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_bvmul_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_bvmul_no_underflow(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_bvmul_no_underflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvmul_no_underflow');
  late final _Z3_mk_bvmul_no_underflow = _Z3_mk_bvmul_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Arrays */
  /// /**@{*/
  /// /**
  /// \brief Array read.
  /// The argument \c a is the array and \c i is the index of the array that gets read.
  ///
  /// The node \c a must have an array sort \ccode{[domain -> range]},
  /// and \c i must have the sort \c domain.
  /// The sort of the result is \c range.
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_store
  ///
  /// def_API('Z3_mk_select', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_select(
    Z3_context c,
    Z3_ast a,
    Z3_ast i,
  ) {
    return _Z3_mk_select(
      c,
      a,
      i,
    );
  }

  late final _Z3_mk_selectPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_select');
  late final _Z3_mk_select = _Z3_mk_selectPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief n-ary Array read.
  /// The argument \c a is the array and \c idxs are the indices of the array that gets read.
  ///
  /// def_API('Z3_mk_select_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast Z3_mk_select_n(
    Z3_context c,
    Z3_ast a,
    int n,
    ffi.Pointer<Z3_ast> idxs,
  ) {
    return _Z3_mk_select_n(
      c,
      a,
      n,
      idxs,
    );
  }

  late final _Z3_mk_select_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_select_n');
  late final _Z3_mk_select_n = _Z3_mk_select_nPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Array update.
  ///
  /// The node \c a must have an array sort \ccode{[domain -> range]}, \c i must have sort \c domain,
  /// \c v must have sort range. The sort of the result is \ccode{[domain -> range]}.
  /// The semantics of this function is given by the theory of arrays described in the SMT-LIB
  /// standard. See http://smtlib.org for more details.
  /// The result of this function is an array that is equal to \c a (with respect to \c select)
  /// on all indices except for \c i, where it maps to \c v (and the \c select of \c a with
  /// respect to \c i may be a different value).
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_select
  ///
  /// def_API('Z3_mk_store', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_store(
    Z3_context c,
    Z3_ast a,
    Z3_ast i,
    Z3_ast v,
  ) {
    return _Z3_mk_store(
      c,
      a,
      i,
      v,
    );
  }

  late final _Z3_mk_storePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_store');
  late final _Z3_mk_store = _Z3_mk_storePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief n-ary Array update.
  ///
  /// def_API('Z3_mk_store_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in(AST)))
  Z3_ast Z3_mk_store_n(
    Z3_context c,
    Z3_ast a,
    int n,
    ffi.Pointer<Z3_ast> idxs,
    Z3_ast v,
  ) {
    return _Z3_mk_store_n(
      c,
      a,
      n,
      idxs,
      v,
    );
  }

  late final _Z3_mk_store_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, Z3_ast)>>('Z3_mk_store_n');
  late final _Z3_mk_store_n = _Z3_mk_store_nPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// \brief Create the constant array.
  ///
  /// The resulting term is an array, such that a \c select on an arbitrary index
  /// produces the value \c v.
  ///
  /// \param c logical context.
  /// \param domain domain sort for the array.
  /// \param v value that the array maps to.
  ///
  /// def_API('Z3_mk_const_array', AST, (_in(CONTEXT), _in(SORT), _in(AST)))
  Z3_ast Z3_mk_const_array(
    Z3_context c,
    Z3_sort domain,
    Z3_ast v,
  ) {
    return _Z3_mk_const_array(
      c,
      domain,
      v,
    );
  }

  late final _Z3_mk_const_arrayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, Z3_ast)>>(
          'Z3_mk_const_array');
  late final _Z3_mk_const_array = _Z3_mk_const_arrayPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_sort, Z3_ast)>();

  /// \brief Map f on the argument arrays.
  ///
  /// The \c n nodes \c args must be of array sorts \ccode{[domain_i -> range_i]}.
  /// The function declaration \c f must have type \ccode{ range_1 .. range_n -> range}.
  /// \c v must have sort range. The sort of the result is \ccode{[domain_i -> range]}.
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_store
  /// \sa Z3_mk_select
  ///
  /// def_API('Z3_mk_map', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
  Z3_ast Z3_mk_map(
    Z3_context c,
    Z3_func_decl f,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_map(
      c,
      f,
      n,
      args,
    );
  }

  late final _Z3_mk_mapPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_map');
  late final _Z3_mk_map = _Z3_mk_mapPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Access the array default value.
  /// Produces the default range value, for arrays that can be represented as
  /// finite maps with a default range value.
  ///
  /// \param c logical context.
  /// \param array array value whose default range value is accessed.
  ///
  /// def_API('Z3_mk_array_default', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_array_default(
    Z3_context c,
    Z3_ast array,
  ) {
    return _Z3_mk_array_default(
      c,
      array,
    );
  }

  late final _Z3_mk_array_defaultPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_array_default');
  late final _Z3_mk_array_default =
      _Z3_mk_array_defaultPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create array with the same interpretation as a function.
  /// The array satisfies the property (f x) = (select (_ as-array f) x)
  /// for every argument x.
  ///
  /// def_API('Z3_mk_as_array', AST, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_ast Z3_mk_as_array(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _Z3_mk_as_array(
      c,
      f,
    );
  }

  late final _Z3_mk_as_arrayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_decl)>>(
          'Z3_mk_as_array');
  late final _Z3_mk_as_array = _Z3_mk_as_arrayPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl)>();

  /// \brief Create predicate that holds if Boolean array \c set has \c k elements set to true.
  ///
  /// def_API('Z3_mk_set_has_size', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_has_size(
    Z3_context c,
    Z3_ast set1,
    Z3_ast k,
  ) {
    return _Z3_mk_set_has_size(
      c,
      set1,
      k,
    );
  }

  late final _Z3_mk_set_has_sizePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_has_size');
  late final _Z3_mk_set_has_size = _Z3_mk_set_has_sizePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Sets */
  /// /**@{*/
  /// /**
  /// \brief Create Set type.
  ///
  /// def_API('Z3_mk_set_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_mk_set_sort(
    Z3_context c,
    Z3_sort ty,
  ) {
    return _Z3_mk_set_sort(
      c,
      ty,
    );
  }

  late final _Z3_mk_set_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_set_sort');
  late final _Z3_mk_set_sort =
      _Z3_mk_set_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create the empty set.
  ///
  /// def_API('Z3_mk_empty_set', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_empty_set(
    Z3_context c,
    Z3_sort domain,
  ) {
    return _Z3_mk_empty_set(
      c,
      domain,
    );
  }

  late final _Z3_mk_empty_setPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_empty_set');
  late final _Z3_mk_empty_set =
      _Z3_mk_empty_setPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create the full set.
  ///
  /// def_API('Z3_mk_full_set', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_full_set(
    Z3_context c,
    Z3_sort domain,
  ) {
    return _Z3_mk_full_set(
      c,
      domain,
    );
  }

  late final _Z3_mk_full_setPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_full_set');
  late final _Z3_mk_full_set =
      _Z3_mk_full_setPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Add an element to a set.
  ///
  /// The first argument must be a set, the second an element.
  ///
  /// def_API('Z3_mk_set_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_add(
    Z3_context c,
    Z3_ast set1,
    Z3_ast elem,
  ) {
    return _Z3_mk_set_add(
      c,
      set1,
      elem,
    );
  }

  late final _Z3_mk_set_addPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_add');
  late final _Z3_mk_set_add = _Z3_mk_set_addPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Remove an element to a set.
  ///
  /// The first argument must be a set, the second an element.
  ///
  /// def_API('Z3_mk_set_del', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_del(
    Z3_context c,
    Z3_ast set1,
    Z3_ast elem,
  ) {
    return _Z3_mk_set_del(
      c,
      set1,
      elem,
    );
  }

  late final _Z3_mk_set_delPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_del');
  late final _Z3_mk_set_del = _Z3_mk_set_delPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Take the union of a list of sets.
  ///
  /// def_API('Z3_mk_set_union', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_set_union(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_set_union(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_set_unionPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_set_union');
  late final _Z3_mk_set_union = _Z3_mk_set_unionPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Take the intersection of a list of sets.
  ///
  /// def_API('Z3_mk_set_intersect', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_set_intersect(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_set_intersect(
      c,
      num_args,
      args,
    );
  }

  late final _Z3_mk_set_intersectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_set_intersect');
  late final _Z3_mk_set_intersect = _Z3_mk_set_intersectPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Take the set difference between two sets.
  ///
  /// def_API('Z3_mk_set_difference', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_difference(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_set_difference(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_set_differencePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_difference');
  late final _Z3_mk_set_difference = _Z3_mk_set_differencePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Take the complement of a set.
  ///
  /// def_API('Z3_mk_set_complement', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_set_complement(
    Z3_context c,
    Z3_ast arg,
  ) {
    return _Z3_mk_set_complement(
      c,
      arg,
    );
  }

  late final _Z3_mk_set_complementPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_set_complement');
  late final _Z3_mk_set_complement = _Z3_mk_set_complementPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check for set membership.
  ///
  /// The first argument should be an element type of the set.
  ///
  /// def_API('Z3_mk_set_member', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_member(
    Z3_context c,
    Z3_ast elem,
    Z3_ast set1,
  ) {
    return _Z3_mk_set_member(
      c,
      elem,
      set1,
    );
  }

  late final _Z3_mk_set_memberPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_member');
  late final _Z3_mk_set_member = _Z3_mk_set_memberPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check for subsetness of sets.
  ///
  /// def_API('Z3_mk_set_subset', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_set_subset(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_set_subset(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_set_subsetPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_subset');
  late final _Z3_mk_set_subset = _Z3_mk_set_subsetPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create array extensionality index given two arrays with the same sort.
  /// The meaning is given by the axiom:
  /// (=> (= (select A (array-ext A B)) (select B (array-ext A B))) (= A B))
  ///
  /// def_API('Z3_mk_array_ext', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_array_ext(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _Z3_mk_array_ext(
      c,
      arg1,
      arg2,
    );
  }

  late final _Z3_mk_array_extPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_array_ext');
  late final _Z3_mk_array_ext = _Z3_mk_array_extPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Numerals */
  /// /**@{*/
  /// /**
  /// \brief Create a numeral of a given sort.
  ///
  /// \param c logical context.
  /// \param numeral A string representing the numeral value in decimal notation. The string may be of the form `[num]*[.[num]*][E[+|-][num]+]`.
  /// If the given sort is a real, then the numeral can be a rational, that is, a string of the form `[num]* / [num]*` .
  /// \param ty The sort of the numeral. In the current implementation, the given sort can be an int, real, finite-domain, or bit-vectors of arbitrary size.
  ///
  /// \sa Z3_mk_int
  /// \sa Z3_mk_unsigned_int
  ///
  /// def_API('Z3_mk_numeral', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
  Z3_ast Z3_mk_numeral(
    Z3_context c,
    Z3_string numeral,
    Z3_sort ty,
  ) {
    return _Z3_mk_numeral(
      c,
      numeral,
      ty,
    );
  }

  late final _Z3_mk_numeralPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>>(
      'Z3_mk_numeral');
  late final _Z3_mk_numeral = _Z3_mk_numeralPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_string, Z3_sort)>();

  /// \brief Create a real from a fraction.
  ///
  /// \param c logical context.
  /// \param num numerator of rational.
  /// \param den denominator of rational.
  ///
  /// \pre den != 0
  ///
  /// \sa Z3_mk_numeral
  /// \sa Z3_mk_int
  /// \sa Z3_mk_unsigned_int
  ///
  /// def_API('Z3_mk_real', AST, (_in(CONTEXT), _in(INT), _in(INT)))
  Z3_ast Z3_mk_real(
    Z3_context c,
    int num,
    int den,
  ) {
    return _Z3_mk_real(
      c,
      num,
      den,
    );
  }

  late final _Z3_mk_realPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, ffi.Int)>>(
      'Z3_mk_real');
  late final _Z3_mk_real =
      _Z3_mk_realPtr.asFunction<Z3_ast Function(Z3_context, int, int)>();

  /// \brief Create a numeral of an int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
  Z3_ast Z3_mk_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _Z3_mk_int(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_intPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, Z3_sort)>>(
      'Z3_mk_int');
  late final _Z3_mk_int =
      _Z3_mk_intPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine unsigned integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_unsigned_int', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
  Z3_ast Z3_mk_unsigned_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _Z3_mk_unsigned_int(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_unsigned_intPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_sort)>>('Z3_mk_unsigned_int');
  late final _Z3_mk_unsigned_int = _Z3_mk_unsigned_intPtr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine \c int64_t integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_int64', AST, (_in(CONTEXT), _in(INT64), _in(SORT)))
  Z3_ast Z3_mk_int64(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _Z3_mk_int64(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_int64Ptr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int64, Z3_sort)>>(
      'Z3_mk_int64');
  late final _Z3_mk_int64 =
      _Z3_mk_int64Ptr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine \c uint64_t integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_unsigned_int64', AST, (_in(CONTEXT), _in(UINT64), _in(SORT)))
  Z3_ast Z3_mk_unsigned_int64(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _Z3_mk_unsigned_int64(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_unsigned_int64Ptr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Uint64, Z3_sort)>>(
      'Z3_mk_unsigned_int64');
  late final _Z3_mk_unsigned_int64 = _Z3_mk_unsigned_int64Ptr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief create a bit-vector numeral from a vector of Booleans.
  ///
  /// \sa Z3_mk_numeral
  /// def_API('Z3_mk_bv_numeral', AST, (_in(CONTEXT), _in(UINT), _in_array(1, BOOL)))
  Z3_ast Z3_mk_bv_numeral(
    Z3_context c,
    int sz,
    ffi.Pointer<ffi.Int> bits,
  ) {
    return _Z3_mk_bv_numeral(
      c,
      sz,
      bits,
    );
  }

  late final _Z3_mk_bv_numeralPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<ffi.Int>)>>('Z3_mk_bv_numeral');
  late final _Z3_mk_bv_numeral = _Z3_mk_bv_numeralPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<ffi.Int>)>();

  /// \brief Create a sequence sort out of the sort for the elements.
  ///
  /// def_API('Z3_mk_seq_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_mk_seq_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_mk_seq_sort(
      c,
      s,
    );
  }

  late final _Z3_mk_seq_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_seq_sort');
  late final _Z3_mk_seq_sort =
      _Z3_mk_seq_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a sequence sort.
  ///
  /// def_API('Z3_is_seq_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  int Z3_is_seq_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_is_seq_sort(
      c,
      s,
    );
  }

  late final _Z3_is_seq_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_sort)>>(
          'Z3_is_seq_sort');
  late final _Z3_is_seq_sort =
      _Z3_is_seq_sortPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Retrieve basis sort for sequence sort.
  ///
  /// def_API('Z3_get_seq_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_get_seq_sort_basis(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_get_seq_sort_basis(
      c,
      s,
    );
  }

  late final _Z3_get_seq_sort_basisPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_seq_sort_basis');
  late final _Z3_get_seq_sort_basis = _Z3_get_seq_sort_basisPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create a regular expression sort out of a sequence sort.
  ///
  /// def_API('Z3_mk_re_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_mk_re_sort(
    Z3_context c,
    Z3_sort seq,
  ) {
    return _Z3_mk_re_sort(
      c,
      seq,
    );
  }

  late final _Z3_mk_re_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_sort');
  late final _Z3_mk_re_sort =
      _Z3_mk_re_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a regular expression sort.
  ///
  /// def_API('Z3_is_re_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  int Z3_is_re_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_is_re_sort(
      c,
      s,
    );
  }

  late final _Z3_is_re_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_sort)>>(
          'Z3_is_re_sort');
  late final _Z3_is_re_sort =
      _Z3_is_re_sortPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Retrieve basis sort for regex sort.
  ///
  /// def_API('Z3_get_re_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_get_re_sort_basis(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_get_re_sort_basis(
      c,
      s,
    );
  }

  late final _Z3_get_re_sort_basisPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_re_sort_basis');
  late final _Z3_get_re_sort_basis = _Z3_get_re_sort_basisPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create a sort for unicode strings.
  ///
  /// The sort for characters can be changed to ASCII by setting
  /// the global parameter \c encoding to \c ascii, or alternative
  /// to 16 bit characters by setting \c encoding to \c bmp.
  ///
  /// def_API('Z3_mk_string_sort', SORT, (_in(CONTEXT), ))
  Z3_sort Z3_mk_string_sort(
    Z3_context c,
  ) {
    return _Z3_mk_string_sort(
      c,
    );
  }

  late final _Z3_mk_string_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_string_sort');
  late final _Z3_mk_string_sort =
      _Z3_mk_string_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a sort for unicode characters.
  ///
  /// The sort for characters can be changed to ASCII by setting
  /// the global parameter \c encoding to \c ascii, or alternative
  /// to 16 bit characters by setting \c encoding to \c bmp.
  ///
  /// def_API('Z3_mk_char_sort', SORT, (_in(CONTEXT), ))
  Z3_sort Z3_mk_char_sort(
    Z3_context c,
  ) {
    return _Z3_mk_char_sort(
      c,
    );
  }

  late final _Z3_mk_char_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_char_sort');
  late final _Z3_mk_char_sort =
      _Z3_mk_char_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Check if \c s is a string sort.
  ///
  /// def_API('Z3_is_string_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  int Z3_is_string_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_is_string_sort(
      c,
      s,
    );
  }

  late final _Z3_is_string_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_sort)>>(
          'Z3_is_string_sort');
  late final _Z3_is_string_sort =
      _Z3_is_string_sortPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a character sort.
  ///
  /// def_API('Z3_is_char_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  int Z3_is_char_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_is_char_sort(
      c,
      s,
    );
  }

  late final _Z3_is_char_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_sort)>>(
          'Z3_is_char_sort');
  late final _Z3_is_char_sort =
      _Z3_is_char_sortPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Create a string constant out of the string that is passed in
  /// The string may contain escape encoding for non-printable characters
  /// or characters outside of the basic printable ASCII range. For example,
  /// the escape encoding \\u{0} represents the character 0 and the encoding
  /// \\u{100} represents the character 256.
  ///
  /// def_API('Z3_mk_string', AST, (_in(CONTEXT), _in(STRING)))
  Z3_ast Z3_mk_string(
    Z3_context c,
    Z3_string s,
  ) {
    return _Z3_mk_string(
      c,
      s,
    );
  }

  late final _Z3_mk_stringPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string)>>(
          'Z3_mk_string');
  late final _Z3_mk_string =
      _Z3_mk_stringPtr.asFunction<Z3_ast Function(Z3_context, Z3_string)>();

  /// \brief Create a string constant out of the string that is passed in
  /// It takes the length of the string as well to take into account
  /// 0 characters. The string is treated as if it is unescaped so a sequence
  /// of characters \\u{0} is treated as 5 characters and not the character 0.
  ///
  /// def_API('Z3_mk_lstring', AST, (_in(CONTEXT), _in(UINT), _in(STRING)))
  Z3_ast Z3_mk_lstring(
    Z3_context c,
    int len,
    Z3_string s,
  ) {
    return _Z3_mk_lstring(
      c,
      len,
      s,
    );
  }

  late final _Z3_mk_lstringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_string)>>('Z3_mk_lstring');
  late final _Z3_mk_lstring = _Z3_mk_lstringPtr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_string)>();

  /// \brief Create a string constant out of the string that is passed in
  /// It takes the length of the string as well to take into account
  /// 0 characters. The string is unescaped.
  ///
  /// def_API('Z3_mk_u32string', AST, (_in(CONTEXT), _in(UINT), _in_array(1, UINT)))
  Z3_ast Z3_mk_u32string(
    Z3_context c,
    int len,
    ffi.Pointer<ffi.UnsignedInt> chars,
  ) {
    return _Z3_mk_u32string(
      c,
      len,
      chars,
    );
  }

  late final _Z3_mk_u32stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_mk_u32string');
  late final _Z3_mk_u32string = _Z3_mk_u32stringPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Determine if \c s is a string constant.
  ///
  /// def_API('Z3_is_string', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_string(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_is_string(
      c,
      s,
    );
  }

  late final _Z3_is_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_string');
  late final _Z3_is_string =
      _Z3_is_stringPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the string constant stored in \c s.
  /// Characters outside the basic printiable ASCII range are escaped.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string Z3_get_string(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_get_string(
      c,
      s,
    );
  }

  late final _Z3_get_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_string');
  late final _Z3_get_string =
      _Z3_get_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the string constant stored in \c s. The string can contain escape sequences.
  /// Characters in the range 1 to 255 are literal.
  /// Characters in the range 0, and 256 above are escaped.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_lstring', CHAR_PTR, (_in(CONTEXT), _in(AST), _out(UINT)))
  Z3_char_ptr Z3_get_lstring(
    Z3_context c,
    Z3_ast s,
    ffi.Pointer<ffi.UnsignedInt> length,
  ) {
    return _Z3_get_lstring(
      c,
      s,
      length,
    );
  }

  late final _Z3_get_lstringPtr = _lookup<
      ffi.NativeFunction<
          Z3_char_ptr Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_lstring');
  late final _Z3_get_lstring = _Z3_get_lstringPtr.asFunction<
      Z3_char_ptr Function(Z3_context, Z3_ast, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Retrieve the length of the unescaped string constant stored in \c s.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_string_length', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_string_length(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_get_string_length(
      c,
      s,
    );
  }

  late final _Z3_get_string_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_string_length');
  late final _Z3_get_string_length =
      _Z3_get_string_lengthPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the unescaped string constant stored in \c s.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// \pre length contains the number of characters in s
  ///
  /// def_API('Z3_get_string_contents', VOID, (_in(CONTEXT), _in(AST), _in(UINT), _out_array(2, UINT)))
  void Z3_get_string_contents(
    Z3_context c,
    Z3_ast s,
    int length,
    ffi.Pointer<ffi.UnsignedInt> contents,
  ) {
    return _Z3_get_string_contents(
      c,
      s,
      length,
      contents,
    );
  }

  late final _Z3_get_string_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_string_contents');
  late final _Z3_get_string_contents = _Z3_get_string_contentsPtr.asFunction<
      void Function(Z3_context, Z3_ast, int, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Create an empty sequence of the sequence sort \c seq.
  ///
  /// \pre s is a sequence sort.
  ///
  /// def_API('Z3_mk_seq_empty', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_seq_empty(
    Z3_context c,
    Z3_sort seq,
  ) {
    return _Z3_mk_seq_empty(
      c,
      seq,
    );
  }

  late final _Z3_mk_seq_emptyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_seq_empty');
  late final _Z3_mk_seq_empty =
      _Z3_mk_seq_emptyPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a unit sequence of \c a.
  ///
  /// def_API('Z3_mk_seq_unit', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_seq_unit(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_mk_seq_unit(
      c,
      a,
    );
  }

  late final _Z3_mk_seq_unitPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_unit');
  late final _Z3_mk_seq_unit =
      _Z3_mk_seq_unitPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Concatenate sequences.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_seq_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_seq_concat(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_seq_concat(
      c,
      n,
      args,
    );
  }

  late final _Z3_mk_seq_concatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_seq_concat');
  late final _Z3_mk_seq_concat = _Z3_mk_seq_concatPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Check if \c prefix is a prefix of \c s.
  ///
  /// \pre prefix and s are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_prefix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_prefix(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _Z3_mk_seq_prefix(
      c,
      prefix,
      s,
    );
  }

  late final _Z3_mk_seq_prefixPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_prefix');
  late final _Z3_mk_seq_prefix = _Z3_mk_seq_prefixPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c suffix is a suffix of \c s.
  ///
  /// \pre \c suffix and \c s are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_suffix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_suffix(
    Z3_context c,
    Z3_ast suffix,
    Z3_ast s,
  ) {
    return _Z3_mk_seq_suffix(
      c,
      suffix,
      s,
    );
  }

  late final _Z3_mk_seq_suffixPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_suffix');
  late final _Z3_mk_seq_suffix = _Z3_mk_seq_suffixPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c container contains \c containee.
  ///
  /// \pre \c container and \c containee are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_contains', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_contains(
    Z3_context c,
    Z3_ast container,
    Z3_ast containee,
  ) {
    return _Z3_mk_seq_contains(
      c,
      container,
      containee,
    );
  }

  late final _Z3_mk_seq_containsPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_contains');
  late final _Z3_mk_seq_contains = _Z3_mk_seq_containsPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c s1 is lexicographically strictly less than \c s2.
  ///
  /// \pre \c s1 and \c s2 are strings
  ///
  /// def_API('Z3_mk_str_lt', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_str_lt(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _Z3_mk_str_lt(
      c,
      prefix,
      s,
    );
  }

  late final _Z3_mk_str_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_str_lt');
  late final _Z3_mk_str_lt = _Z3_mk_str_ltPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c s1 is equal or lexicographically strictly less than \c s2.
  ///
  /// \pre \c s1 and \c s2 are strings
  ///
  /// def_API('Z3_mk_str_le', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_str_le(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _Z3_mk_str_le(
      c,
      prefix,
      s,
    );
  }

  late final _Z3_mk_str_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_str_le');
  late final _Z3_mk_str_le = _Z3_mk_str_lePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Extract subsequence starting at \c offset of \c length.
  ///
  /// def_API('Z3_mk_seq_extract', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_extract(
    Z3_context c,
    Z3_ast s,
    Z3_ast offset,
    Z3_ast length,
  ) {
    return _Z3_mk_seq_extract(
      c,
      s,
      offset,
      length,
    );
  }

  late final _Z3_mk_seq_extractPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_seq_extract');
  late final _Z3_mk_seq_extract = _Z3_mk_seq_extractPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Replace the first occurrence of \c src with \c dst in \c s.
  ///
  /// def_API('Z3_mk_seq_replace', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_replace(
    Z3_context c,
    Z3_ast s,
    Z3_ast src,
    Z3_ast dst,
  ) {
    return _Z3_mk_seq_replace(
      c,
      s,
      src,
      dst,
    );
  }

  late final _Z3_mk_seq_replacePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_seq_replace');
  late final _Z3_mk_seq_replace = _Z3_mk_seq_replacePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Retrieve from \c s the unit sequence positioned at position \c index.
  /// The sequence is empty if the index is out of bounds.
  ///
  /// def_API('Z3_mk_seq_at', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_at(
    Z3_context c,
    Z3_ast s,
    Z3_ast index,
  ) {
    return _Z3_mk_seq_at(
      c,
      s,
      index,
    );
  }

  late final _Z3_mk_seq_atPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_at');
  late final _Z3_mk_seq_at = _Z3_mk_seq_atPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Retrieve from \c s the element positioned at position \c index.
  /// The function is under-specified if the index is out of bounds.
  ///
  /// def_API('Z3_mk_seq_nth', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_nth(
    Z3_context c,
    Z3_ast s,
    Z3_ast index,
  ) {
    return _Z3_mk_seq_nth(
      c,
      s,
      index,
    );
  }

  late final _Z3_mk_seq_nthPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_nth');
  late final _Z3_mk_seq_nth = _Z3_mk_seq_nthPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the length of the sequence \c s.
  ///
  /// def_API('Z3_mk_seq_length', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_seq_length(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_mk_seq_length(
      c,
      s,
    );
  }

  late final _Z3_mk_seq_lengthPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_length');
  late final _Z3_mk_seq_length =
      _Z3_mk_seq_lengthPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return index of the first occurrence of \c substr in \c s starting from offset \c offset.
  /// If \c s does not contain \c substr, then the value is -1, if \c offset is the length of \c s, then the value is -1 as well.
  /// The value is -1 if \c offset is negative or larger than the length of \c s.
  ///
  /// def_API('Z3_mk_seq_index', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_index(
    Z3_context c,
    Z3_ast s,
    Z3_ast substr,
    Z3_ast offset,
  ) {
    return _Z3_mk_seq_index(
      c,
      s,
      substr,
      offset,
    );
  }

  late final _Z3_mk_seq_indexPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_seq_index');
  late final _Z3_mk_seq_index = _Z3_mk_seq_indexPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Return index of the last occurrence of \c substr in \c s.
  /// If \c s does not contain \c substr, then the value is -1,
  /// def_API('Z3_mk_seq_last_index', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_last_index(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast substr,
  ) {
    return _Z3_mk_seq_last_index(
      c,
      arg1,
      substr,
    );
  }

  late final _Z3_mk_seq_last_indexPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_last_index');
  late final _Z3_mk_seq_last_index = _Z3_mk_seq_last_indexPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Convert string to integer.
  ///
  /// def_API('Z3_mk_str_to_int', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_str_to_int(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_mk_str_to_int(
      c,
      s,
    );
  }

  late final _Z3_mk_str_to_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_str_to_int');
  late final _Z3_mk_str_to_int =
      _Z3_mk_str_to_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Integer to string conversion.
  ///
  /// def_API('Z3_mk_int_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_int_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_mk_int_to_str(
      c,
      s,
    );
  }

  late final _Z3_mk_int_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_int_to_str');
  late final _Z3_mk_int_to_str =
      _Z3_mk_int_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief String to code conversion.
  ///
  /// def_API('Z3_mk_string_to_code', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_string_to_code(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_mk_string_to_code(
      c,
      a,
    );
  }

  late final _Z3_mk_string_to_codePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_string_to_code');
  late final _Z3_mk_string_to_code = _Z3_mk_string_to_codePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Code to string conversion.
  ///
  /// def_API('Z3_mk_string_from_code', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_string_from_code(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_mk_string_from_code(
      c,
      a,
    );
  }

  late final _Z3_mk_string_from_codePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_string_from_code');
  late final _Z3_mk_string_from_code = _Z3_mk_string_from_codePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Unsigned bit-vector to string conversion.
  ///
  /// def_API('Z3_mk_ubv_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_ubv_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_mk_ubv_to_str(
      c,
      s,
    );
  }

  late final _Z3_mk_ubv_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_ubv_to_str');
  late final _Z3_mk_ubv_to_str =
      _Z3_mk_ubv_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Signed bit-vector to string conversion.
  ///
  /// def_API('Z3_mk_sbv_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_sbv_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _Z3_mk_sbv_to_str(
      c,
      s,
    );
  }

  late final _Z3_mk_sbv_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_sbv_to_str');
  late final _Z3_mk_sbv_to_str =
      _Z3_mk_sbv_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a regular expression that accepts the sequence \c seq.
  ///
  /// def_API('Z3_mk_seq_to_re', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_seq_to_re(
    Z3_context c,
    Z3_ast seq,
  ) {
    return _Z3_mk_seq_to_re(
      c,
      seq,
    );
  }

  late final _Z3_mk_seq_to_rePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_to_re');
  late final _Z3_mk_seq_to_re =
      _Z3_mk_seq_to_rePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check if \c seq is in the language generated by the regular expression \c re.
  ///
  /// def_API('Z3_mk_seq_in_re', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_seq_in_re(
    Z3_context c,
    Z3_ast seq,
    Z3_ast re,
  ) {
    return _Z3_mk_seq_in_re(
      c,
      seq,
      re,
    );
  }

  late final _Z3_mk_seq_in_rePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_in_re');
  late final _Z3_mk_seq_in_re = _Z3_mk_seq_in_rePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create the regular language \c re+.
  ///
  /// def_API('Z3_mk_re_plus', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_re_plus(
    Z3_context c,
    Z3_ast re,
  ) {
    return _Z3_mk_re_plus(
      c,
      re,
    );
  }

  late final _Z3_mk_re_plusPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_plus');
  late final _Z3_mk_re_plus =
      _Z3_mk_re_plusPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the regular language \c re*.
  ///
  /// def_API('Z3_mk_re_star', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_re_star(
    Z3_context c,
    Z3_ast re,
  ) {
    return _Z3_mk_re_star(
      c,
      re,
    );
  }

  late final _Z3_mk_re_starPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_star');
  late final _Z3_mk_re_star =
      _Z3_mk_re_starPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the regular language \c [re].
  ///
  /// def_API('Z3_mk_re_option', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_re_option(
    Z3_context c,
    Z3_ast re,
  ) {
    return _Z3_mk_re_option(
      c,
      re,
    );
  }

  late final _Z3_mk_re_optionPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_option');
  late final _Z3_mk_re_option =
      _Z3_mk_re_optionPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the union of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_union', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_re_union(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_re_union(
      c,
      n,
      args,
    );
  }

  late final _Z3_mk_re_unionPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_union');
  late final _Z3_mk_re_union = _Z3_mk_re_unionPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the concatenation of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_re_concat(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_re_concat(
      c,
      n,
      args,
    );
  }

  late final _Z3_mk_re_concatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_concat');
  late final _Z3_mk_re_concat = _Z3_mk_re_concatPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the range regular expression over two sequences of length 1.
  ///
  /// def_API('Z3_mk_re_range', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_re_range(
    Z3_context c,
    Z3_ast lo,
    Z3_ast hi,
  ) {
    return _Z3_mk_re_range(
      c,
      lo,
      hi,
    );
  }

  late final _Z3_mk_re_rangePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_re_range');
  late final _Z3_mk_re_range = _Z3_mk_re_rangePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a regular expression that accepts all singleton sequences of the regular expression sort
  ///
  /// def_API('Z3_mk_re_allchar', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_re_allchar(
    Z3_context c,
    Z3_sort regex_sort,
  ) {
    return _Z3_mk_re_allchar(
      c,
      regex_sort,
    );
  }

  late final _Z3_mk_re_allcharPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_allchar');
  late final _Z3_mk_re_allchar =
      _Z3_mk_re_allcharPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a regular expression loop. The supplied regular expression \c r is repeated
  /// between \c lo and \c hi times. The \c lo should be below \c hi with one exception: when
  /// supplying the value \c hi as 0, the meaning is to repeat the argument \c r at least
  /// \c lo number of times, and with an unbounded upper bound.
  ///
  /// def_API('Z3_mk_re_loop', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in(UINT)))
  Z3_ast Z3_mk_re_loop(
    Z3_context c,
    Z3_ast r,
    int lo,
    int hi,
  ) {
    return _Z3_mk_re_loop(
      c,
      r,
      lo,
      hi,
    );
  }

  late final _Z3_mk_re_loopPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('Z3_mk_re_loop');
  late final _Z3_mk_re_loop = _Z3_mk_re_loopPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, int)>();

  /// \brief Create a power regular expression.
  ///
  /// def_API('Z3_mk_re_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_mk_re_power(
    Z3_context c,
    Z3_ast arg1,
    int n,
  ) {
    return _Z3_mk_re_power(
      c,
      arg1,
      n,
    );
  }

  late final _Z3_mk_re_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_mk_re_power');
  late final _Z3_mk_re_power =
      _Z3_mk_re_powerPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Create the intersection of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_intersect', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast Z3_mk_re_intersect(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_mk_re_intersect(
      c,
      n,
      args,
    );
  }

  late final _Z3_mk_re_intersectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_intersect');
  late final _Z3_mk_re_intersect = _Z3_mk_re_intersectPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the complement of the regular language \c re.
  ///
  /// def_API('Z3_mk_re_complement', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_re_complement(
    Z3_context c,
    Z3_ast re,
  ) {
    return _Z3_mk_re_complement(
      c,
      re,
    );
  }

  late final _Z3_mk_re_complementPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_complement');
  late final _Z3_mk_re_complement =
      _Z3_mk_re_complementPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the difference of regular expressions.
  ///
  /// def_API('Z3_mk_re_diff', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_re_diff(
    Z3_context c,
    Z3_ast re1,
    Z3_ast re2,
  ) {
    return _Z3_mk_re_diff(
      c,
      re1,
      re2,
    );
  }

  late final _Z3_mk_re_diffPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_re_diff');
  late final _Z3_mk_re_diff = _Z3_mk_re_diffPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an empty regular expression of sort \c re.
  ///
  /// \pre re is a regular expression sort.
  ///
  /// def_API('Z3_mk_re_empty', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_re_empty(
    Z3_context c,
    Z3_sort re,
  ) {
    return _Z3_mk_re_empty(
      c,
      re,
    );
  }

  late final _Z3_mk_re_emptyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_empty');
  late final _Z3_mk_re_empty =
      _Z3_mk_re_emptyPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create an universal regular expression of sort \c re.
  ///
  /// \pre re is a regular expression sort.
  ///
  /// def_API('Z3_mk_re_full', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_mk_re_full(
    Z3_context c,
    Z3_sort re,
  ) {
    return _Z3_mk_re_full(
      c,
      re,
    );
  }

  late final _Z3_mk_re_fullPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_full');
  late final _Z3_mk_re_full =
      _Z3_mk_re_fullPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a character literal
  /// def_API('Z3_mk_char', AST, (_in(CONTEXT), _in(UINT)))
  Z3_ast Z3_mk_char(
    Z3_context c,
    int ch,
  ) {
    return _Z3_mk_char(
      c,
      ch,
    );
  }

  late final _Z3_mk_charPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.UnsignedInt)>>(
          'Z3_mk_char');
  late final _Z3_mk_char =
      _Z3_mk_charPtr.asFunction<Z3_ast Function(Z3_context, int)>();

  /// \brief Create less than or equal to between two characters.
  ///
  /// def_API('Z3_mk_char_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_mk_char_le(
    Z3_context c,
    Z3_ast ch1,
    Z3_ast ch2,
  ) {
    return _Z3_mk_char_le(
      c,
      ch1,
      ch2,
    );
  }

  late final _Z3_mk_char_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_char_le');
  late final _Z3_mk_char_le = _Z3_mk_char_lePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an integer (code point) from character.
  ///
  /// def_API('Z3_mk_char_to_int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_char_to_int(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _Z3_mk_char_to_int(
      c,
      ch,
    );
  }

  late final _Z3_mk_char_to_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_to_int');
  late final _Z3_mk_char_to_int =
      _Z3_mk_char_to_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a bit-vector (code point) from character.
  ///
  /// def_API('Z3_mk_char_to_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_char_to_bv(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _Z3_mk_char_to_bv(
      c,
      ch,
    );
  }

  late final _Z3_mk_char_to_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_to_bv');
  late final _Z3_mk_char_to_bv =
      _Z3_mk_char_to_bvPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a character from a bit-vector (code point).
  ///
  /// def_API('Z3_mk_char_from_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_char_from_bv(
    Z3_context c,
    Z3_ast bv,
  ) {
    return _Z3_mk_char_from_bv(
      c,
      bv,
    );
  }

  late final _Z3_mk_char_from_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_from_bv');
  late final _Z3_mk_char_from_bv =
      _Z3_mk_char_from_bvPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a check if the character is a digit.
  ///
  /// def_API('Z3_mk_char_is_digit', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_mk_char_is_digit(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _Z3_mk_char_is_digit(
      c,
      ch,
    );
  }

  late final _Z3_mk_char_is_digitPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_is_digit');
  late final _Z3_mk_char_is_digit =
      _Z3_mk_char_is_digitPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Special relations */
  /// /**@{*/
  /// /**
  /// \brief create a linear ordering relation over signature \c a.
  /// The relation is identified by the index \c id.
  ///
  /// def_API('Z3_mk_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_mk_linear_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _Z3_mk_linear_order(
      c,
      a,
      id,
    );
  }

  late final _Z3_mk_linear_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_linear_order');
  late final _Z3_mk_linear_order = _Z3_mk_linear_orderPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a partial ordering relation over signature \c a and index \c id.
  ///
  /// def_API('Z3_mk_partial_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_mk_partial_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _Z3_mk_partial_order(
      c,
      a,
      id,
    );
  }

  late final _Z3_mk_partial_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_partial_order');
  late final _Z3_mk_partial_order = _Z3_mk_partial_orderPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a piecewise linear ordering relation over signature \c a and index \c id.
  ///
  /// def_API('Z3_mk_piecewise_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_mk_piecewise_linear_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _Z3_mk_piecewise_linear_order(
      c,
      a,
      id,
    );
  }

  late final _Z3_mk_piecewise_linear_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_mk_piecewise_linear_order');
  late final _Z3_mk_piecewise_linear_order = _Z3_mk_piecewise_linear_orderPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a tree ordering relation over signature \c a identified using index \c id.
  ///
  /// def_API('Z3_mk_tree_order', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_mk_tree_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _Z3_mk_tree_order(
      c,
      a,
      id,
    );
  }

  late final _Z3_mk_tree_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_tree_order');
  late final _Z3_mk_tree_order = _Z3_mk_tree_orderPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create transitive closure of binary relation.
  ///
  /// \pre f is a binary relation, such that the two arguments have the same sorts.
  ///
  /// The resulting relation f+ represents the transitive closure of f.
  ///
  /// def_API('Z3_mk_transitive_closure', FUNC_DECL ,(_in(CONTEXT), _in(FUNC_DECL)))
  Z3_func_decl Z3_mk_transitive_closure(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _Z3_mk_transitive_closure(
      c,
      f,
    );
  }

  late final _Z3_mk_transitive_closurePtr = _lookup<
          ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_func_decl)>>(
      'Z3_mk_transitive_closure');
  late final _Z3_mk_transitive_closure = _Z3_mk_transitive_closurePtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_func_decl)>();

  /// @name Quantifiers */
  /// /**@{*/
  /// /**
  /// \brief Create a pattern for quantifier instantiation.
  ///
  /// Z3 uses pattern matching to instantiate quantifiers. If a
  /// pattern is not provided for a quantifier, then Z3 will
  /// automatically compute a set of patterns for it. However, for
  /// optimal performance, the user should provide the patterns.
  ///
  /// Patterns comprise a list of terms. The list should be
  /// non-empty.  If the list comprises of more than one term, it is
  /// a called a multi-pattern.
  ///
  /// In general, one can pass in a list of (multi-)patterns in the
  /// quantifier constructor.
  ///
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_pattern', PATTERN, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_pattern Z3_mk_pattern(
    Z3_context c,
    int num_patterns,
    ffi.Pointer<Z3_ast> terms,
  ) {
    return _Z3_mk_pattern(
      c,
      num_patterns,
      terms,
    );
  }

  late final _Z3_mk_patternPtr = _lookup<
      ffi.NativeFunction<
          Z3_pattern Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_pattern');
  late final _Z3_mk_pattern = _Z3_mk_patternPtr.asFunction<
      Z3_pattern Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create a bound variable.
  ///
  /// Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain
  /// the meaning of de-Bruijn indices by indicating the compilation process from
  /// non-de-Bruijn formulas to de-Bruijn format.
  ///
  /// \verbatim
  /// abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
  /// abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
  /// abs1(x, x, n) = b_n
  /// abs1(y, x, n) = y
  /// abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
  /// abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
  /// \endverbatim
  ///
  /// The last line is significant: the index of a bound variable is different depending
  /// on the scope in which it appears. The deeper x appears, the higher is its
  /// index.
  ///
  /// \param c logical context
  /// \param index de-Bruijn index
  /// \param ty sort of the bound variable
  ///
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_bound', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
  Z3_ast Z3_mk_bound(
    Z3_context c,
    int index,
    Z3_sort ty,
  ) {
    return _Z3_mk_bound(
      c,
      index,
      ty,
    );
  }

  late final _Z3_mk_boundPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_sort)>>('Z3_mk_bound');
  late final _Z3_mk_bound =
      _Z3_mk_boundPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a forall formula. It takes an expression \c body that contains bound variables
  /// of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
  /// using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
  /// bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
  /// refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
  /// to the variable with index 1, etc.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_decls number of variables to be bound.
  /// \param sorts the sorts of the bound variables.
  /// \param decl_names names of the bound variables
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_forall', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
  Z3_ast Z3_mk_forall(
    Z3_context c,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _Z3_mk_forall(
      c,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _Z3_mk_forallPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_forall');
  late final _Z3_mk_forall = _Z3_mk_forallPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create an exists formula. Similar to #Z3_mk_forall.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_quantifier
  ///
  /// def_API('Z3_mk_exists', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
  Z3_ast Z3_mk_exists(
    Z3_context c,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _Z3_mk_exists(
      c,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _Z3_mk_existsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_exists');
  late final _Z3_mk_exists = _Z3_mk_existsPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a quantifier - universal or existential, with pattern hints.
  /// See the documentation for #Z3_mk_forall for an explanation of the parameters.
  ///
  /// \param c logical context.
  /// \param is_forall flag to indicate if this is a universal or existential quantifier.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_decls number of variables to be bound.
  /// \param sorts array of sorts of the bound variables.
  /// \param decl_names names of the bound variables.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_quantifier', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, PATTERN), _in(UINT), _in_array(5, SORT), _in_array(5, SYMBOL), _in(AST)))
  Z3_ast Z3_mk_quantifier(
    Z3_context c,
    int is_forall,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _Z3_mk_quantifier(
      c,
      is_forall,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _Z3_mk_quantifierPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_quantifier');
  late final _Z3_mk_quantifier = _Z3_mk_quantifierPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes
  ///
  /// \param c logical context.
  /// \param is_forall flag to indicate if this is a universal or existential quantifier.
  /// \param quantifier_id identifier to identify quantifier
  /// \param skolem_id identifier to identify skolem constants introduced by quantifier.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_no_patterns number of no_patterns.
  /// \param no_patterns array containing subexpressions to be excluded from inferred patterns.
  /// \param num_decls number of variables to be bound.
  /// \param sorts array of sorts of the bound variables.
  /// \param decl_names names of the bound variables.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_quantifier_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, PATTERN), _in(UINT), _in_array(7, AST), _in(UINT), _in_array(9, SORT), _in_array(9, SYMBOL), _in(AST)))
  Z3_ast Z3_mk_quantifier_ex(
    Z3_context c,
    int is_forall,
    int weight,
    Z3_symbol quantifier_id,
    Z3_symbol skolem_id,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_no_patterns,
    ffi.Pointer<Z3_ast> no_patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _Z3_mk_quantifier_ex(
      c,
      is_forall,
      weight,
      quantifier_id,
      skolem_id,
      num_patterns,
      patterns,
      num_no_patterns,
      no_patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _Z3_mk_quantifier_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Int,
              ffi.UnsignedInt,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_quantifier_ex');
  late final _Z3_mk_quantifier_ex = _Z3_mk_quantifier_exPtr.asFunction<
      Z3_ast Function(
          Z3_context,
          int,
          int,
          Z3_symbol,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_pattern>,
          int,
          ffi.Pointer<Z3_ast>,
          int,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_symbol>,
          Z3_ast)>();

  /// \brief Create a universal quantifier using a list of constants that
  /// will form the set of bound variables.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using
  /// the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_exists_const
  ///
  /// def_API('Z3_mk_forall_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
  Z3_ast Z3_mk_forall_const(
    Z3_context c,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _Z3_mk_forall_const(
      c,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _Z3_mk_forall_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_forall_const');
  late final _Z3_mk_forall_const = _Z3_mk_forall_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Similar to #Z3_mk_forall_const.
  ///
  /// \brief Create an existential quantifier using a list of constants that
  /// will form the set of bound variables.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using
  /// the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_forall_const
  ///
  /// def_API('Z3_mk_exists_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
  Z3_ast Z3_mk_exists_const(
    Z3_context c,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _Z3_mk_exists_const(
      c,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _Z3_mk_exists_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_exists_const');
  late final _Z3_mk_exists_const = _Z3_mk_exists_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Create a universal or existential quantifier using a list of
  /// constants that will form the set of bound variables.
  ///
  /// def_API('Z3_mk_quantifier_const', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, APP), _in(UINT), _in_array(5, PATTERN), _in(AST)))
  Z3_ast Z3_mk_quantifier_const(
    Z3_context c,
    int is_forall,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _Z3_mk_quantifier_const(
      c,
      is_forall,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _Z3_mk_quantifier_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_quantifier_const');
  late final _Z3_mk_quantifier_const = _Z3_mk_quantifier_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Create a universal or existential quantifier using a list of
  /// constants that will form the set of bound variables.
  ///
  /// def_API('Z3_mk_quantifier_const_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, APP), _in(UINT), _in_array(7, PATTERN), _in(UINT), _in_array(9, AST), _in(AST)))
  Z3_ast Z3_mk_quantifier_const_ex(
    Z3_context c,
    int is_forall,
    int weight,
    Z3_symbol quantifier_id,
    Z3_symbol skolem_id,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_no_patterns,
    ffi.Pointer<Z3_ast> no_patterns,
    Z3_ast body,
  ) {
    return _Z3_mk_quantifier_const_ex(
      c,
      is_forall,
      weight,
      quantifier_id,
      skolem_id,
      num_bound,
      bound,
      num_patterns,
      patterns,
      num_no_patterns,
      no_patterns,
      body,
    );
  }

  late final _Z3_mk_quantifier_const_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Int,
              ffi.UnsignedInt,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_mk_quantifier_const_ex');
  late final _Z3_mk_quantifier_const_ex =
      _Z3_mk_quantifier_const_exPtr.asFunction<
          Z3_ast Function(
              Z3_context,
              int,
              int,
              Z3_symbol,
              Z3_symbol,
              int,
              ffi.Pointer<Z3_app>,
              int,
              ffi.Pointer<Z3_pattern>,
              int,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>();

  /// \brief Create a lambda expression. It takes an expression \c body that contains bound variables
  /// of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
  /// using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
  /// bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
  /// refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
  /// to the variable with index 1, etc.
  /// The sort of the resulting expression is \c (Array sorts range) where \c range is the sort of \c body.
  /// For example, if the lambda binds two variables of sort \c Int and \c Bool, and the \c body has sort \c Real,
  /// the sort of the expression is \c (Array Int Bool Real).
  ///
  /// \param c logical context
  /// \param num_decls number of variables to be bound.
  /// \param sorts the sorts of the bound variables.
  /// \param decl_names names of the bound variables
  /// \param body the body of the lambda expression.
  ///
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_lambda_const
  ///
  /// def_API('Z3_mk_lambda', AST, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in_array(1, SYMBOL), _in(AST)))
  Z3_ast Z3_mk_lambda(
    Z3_context c,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _Z3_mk_lambda(
      c,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _Z3_mk_lambdaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>, Z3_ast)>>('Z3_mk_lambda');
  late final _Z3_mk_lambda = _Z3_mk_lambdaPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a lambda expression using a list of constants that form the set
  /// of bound variables
  ///
  /// \param c logical context.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param body the body of the lambda expression.
  ///
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_lambda
  ///
  /// def_API('Z3_mk_lambda_const', AST, (_in(CONTEXT), _in(UINT), _in_array(1, APP), _in(AST)))
  Z3_ast Z3_mk_lambda_const(
    Z3_context c,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
  ) {
    return _Z3_mk_lambda_const(
      c,
      num_bound,
      bound,
      body,
    );
  }

  late final _Z3_mk_lambda_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_app>,
              Z3_ast)>>('Z3_mk_lambda_const');
  late final _Z3_mk_lambda_const = _Z3_mk_lambda_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_app>, Z3_ast)>();

  /// @name Accessors */
  /// /**@{*/
  /// /**
  /// \brief Return \c Z3_INT_SYMBOL if the symbol was constructed
  /// using #Z3_mk_int_symbol, and \c Z3_STRING_SYMBOL if the symbol
  /// was constructed using #Z3_mk_string_symbol.
  ///
  /// def_API('Z3_get_symbol_kind', UINT, (_in(CONTEXT), _in(SYMBOL)))
  int Z3_get_symbol_kind(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _Z3_get_symbol_kind(
      c,
      s,
    );
  }

  late final _Z3_get_symbol_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_kind');
  late final _Z3_get_symbol_kind =
      _Z3_get_symbol_kindPtr.asFunction<int Function(Z3_context, Z3_symbol)>();

  /// \brief Return the symbol int value.
  ///
  /// \pre Z3_get_symbol_kind(s) == Z3_INT_SYMBOL
  ///
  /// \sa Z3_mk_int_symbol
  ///
  /// def_API('Z3_get_symbol_int', INT, (_in(CONTEXT), _in(SYMBOL)))
  int Z3_get_symbol_int(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _Z3_get_symbol_int(
      c,
      s,
    );
  }

  late final _Z3_get_symbol_intPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_int');
  late final _Z3_get_symbol_int =
      _Z3_get_symbol_intPtr.asFunction<int Function(Z3_context, Z3_symbol)>();

  /// \brief Return the symbol name.
  ///
  /// \pre Z3_get_symbol_kind(s) == Z3_STRING_SYMBOL
  ///
  /// \warning The returned buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_get_symbol_string.
  ///
  /// \sa Z3_mk_string_symbol
  ///
  /// def_API('Z3_get_symbol_string', STRING, (_in(CONTEXT), _in(SYMBOL)))
  Z3_string Z3_get_symbol_string(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _Z3_get_symbol_string(
      c,
      s,
    );
  }

  late final _Z3_get_symbol_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_string');
  late final _Z3_get_symbol_string = _Z3_get_symbol_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_symbol)>();

  /// \brief Return the sort name as a symbol.
  ///
  /// def_API('Z3_get_sort_name', SYMBOL, (_in(CONTEXT), _in(SORT)))
  Z3_symbol Z3_get_sort_name(
    Z3_context c,
    Z3_sort d,
  ) {
    return _Z3_get_sort_name(
      c,
      d,
    );
  }

  late final _Z3_get_sort_namePtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_sort)>>(
          'Z3_get_sort_name');
  late final _Z3_get_sort_name = _Z3_get_sort_namePtr.asFunction<
      Z3_symbol Function(Z3_context, Z3_sort)>();

  /// \brief Return a unique identifier for \c s.
  ///
  /// def_API('Z3_get_sort_id', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_sort_id(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_get_sort_id(
      c,
      s,
    );
  }

  late final _Z3_get_sort_idPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_sort_id');
  late final _Z3_get_sort_id =
      _Z3_get_sort_idPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Convert a \c Z3_sort into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_sort_to_ast', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast Z3_sort_to_ast(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_sort_to_ast(
      c,
      s,
    );
  }

  late final _Z3_sort_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_sort_to_ast');
  late final _Z3_sort_to_ast =
      _Z3_sort_to_astPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief compare sorts.
  ///
  /// def_API('Z3_is_eq_sort', BOOL, (_in(CONTEXT), _in(SORT), _in(SORT)))
  int Z3_is_eq_sort(
    Z3_context c,
    Z3_sort s1,
    Z3_sort s2,
  ) {
    return _Z3_is_eq_sort(
      c,
      s1,
      s2,
    );
  }

  late final _Z3_is_eq_sortPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_sort, Z3_sort)>>(
      'Z3_is_eq_sort');
  late final _Z3_is_eq_sort = _Z3_is_eq_sortPtr.asFunction<
      int Function(Z3_context, Z3_sort, Z3_sort)>();

  /// \brief Return the sort kind (e.g., array, tuple, int, bool, etc).
  ///
  /// \sa Z3_sort_kind
  ///
  /// def_API('Z3_get_sort_kind', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_sort_kind(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_sort_kind(
      c,
      t,
    );
  }

  late final _Z3_get_sort_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_sort)>>(
          'Z3_get_sort_kind');
  late final _Z3_get_sort_kind =
      _Z3_get_sort_kindPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return the size of the given bit-vector sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_BV_SORT
  ///
  /// \sa Z3_mk_bv_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_bv_sort_size', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_bv_sort_size(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_bv_sort_size(
      c,
      t,
    );
  }

  late final _Z3_get_bv_sort_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_bv_sort_size');
  late final _Z3_get_bv_sort_size =
      _Z3_get_bv_sort_sizePtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Store the size of the sort in \c r. Return \c false if the call failed.
  /// That is, Z3_get_sort_kind(s) == Z3_FINITE_DOMAIN_SORT
  ///
  /// def_API('Z3_get_finite_domain_sort_size', BOOL, (_in(CONTEXT), _in(SORT), _out(UINT64)))
  int Z3_get_finite_domain_sort_size(
    Z3_context c,
    Z3_sort s,
    ffi.Pointer<ffi.Uint64> r,
  ) {
    return _Z3_get_finite_domain_sort_size(
      c,
      s,
      r,
    );
  }

  late final _Z3_get_finite_domain_sort_sizePtr = _lookup<
      ffi.NativeFunction<
          Z3_bool Function(Z3_context, Z3_sort,
              ffi.Pointer<ffi.Uint64>)>>('Z3_get_finite_domain_sort_size');
  late final _Z3_get_finite_domain_sort_size =
      _Z3_get_finite_domain_sort_sizePtr.asFunction<
          int Function(Z3_context, Z3_sort, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Return the domain of the given array sort.
  /// In the case of a multi-dimensional array, this function returns the sort of the first dimension.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  /// \sa Z3_get_array_sort_domain_n
  ///
  /// def_API('Z3_get_array_sort_domain', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_get_array_sort_domain(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_array_sort_domain(
      c,
      t,
    );
  }

  late final _Z3_get_array_sort_domainPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_array_sort_domain');
  late final _Z3_get_array_sort_domain = _Z3_get_array_sort_domainPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Return the i'th domain sort of an n-dimensional array.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  /// \sa Z3_get_array_sort_domain
  ///
  /// def_API('Z3_get_array_sort_domain_n', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_sort Z3_get_array_sort_domain_n(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _Z3_get_array_sort_domain_n(
      c,
      t,
      idx,
    );
  }

  late final _Z3_get_array_sort_domain_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_array_sort_domain_n');
  late final _Z3_get_array_sort_domain_n = _Z3_get_array_sort_domain_nPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort, int)>();

  /// \brief Return the range of the given array sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_array_sort_range', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort Z3_get_array_sort_range(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_array_sort_range(
      c,
      t,
    );
  }

  late final _Z3_get_array_sort_rangePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_array_sort_range');
  late final _Z3_get_array_sort_range = _Z3_get_array_sort_rangePtr.asFunction<
      Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Return the constructor declaration of the given tuple
  /// sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_mk_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT)))
  Z3_func_decl Z3_get_tuple_sort_mk_decl(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_tuple_sort_mk_decl(
      c,
      t,
    );
  }

  late final _Z3_get_tuple_sort_mk_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_sort)>>(
          'Z3_get_tuple_sort_mk_decl');
  late final _Z3_get_tuple_sort_mk_decl = _Z3_get_tuple_sort_mk_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort)>();

  /// \brief Return the number of fields of the given tuple sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_num_fields', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_tuple_sort_num_fields(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_tuple_sort_num_fields(
      c,
      t,
    );
  }

  late final _Z3_get_tuple_sort_num_fieldsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_tuple_sort_num_fields');
  late final _Z3_get_tuple_sort_num_fields = _Z3_get_tuple_sort_num_fieldsPtr
      .asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return the i-th field declaration (i.e., projection function declaration)
  /// of the given tuple sort.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre i < Z3_get_tuple_sort_num_fields(c, t)
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_field_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_get_tuple_sort_field_decl(
    Z3_context c,
    Z3_sort t,
    int i,
  ) {
    return _Z3_get_tuple_sort_field_decl(
      c,
      t,
      i,
    );
  }

  late final _Z3_get_tuple_sort_field_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_tuple_sort_field_decl');
  late final _Z3_get_tuple_sort_field_decl = _Z3_get_tuple_sort_field_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return number of constructors for datatype.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_recognizer
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_num_constructors', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_datatype_sort_num_constructors(
    Z3_context c,
    Z3_sort t,
  ) {
    return _Z3_get_datatype_sort_num_constructors(
      c,
      t,
    );
  }

  late final _Z3_get_datatype_sort_num_constructorsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_datatype_sort_num_constructors');
  late final _Z3_get_datatype_sort_num_constructors =
      _Z3_get_datatype_sort_num_constructorsPtr.asFunction<
          int Function(Z3_context, Z3_sort)>();

  /// \brief Return idx'th constructor.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx < Z3_get_datatype_sort_num_constructors(c, t)
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_recognizer
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_constructor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_get_datatype_sort_constructor(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _Z3_get_datatype_sort_constructor(
      c,
      t,
      idx,
    );
  }

  late final _Z3_get_datatype_sort_constructorPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_constructor');
  late final _Z3_get_datatype_sort_constructor =
      _Z3_get_datatype_sort_constructorPtr.asFunction<
          Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return idx'th recognizer.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx < Z3_get_datatype_sort_num_constructors(c, t)
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_recognizer', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl Z3_get_datatype_sort_recognizer(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _Z3_get_datatype_sort_recognizer(
      c,
      t,
      idx,
    );
  }

  late final _Z3_get_datatype_sort_recognizerPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_recognizer');
  late final _Z3_get_datatype_sort_recognizer =
      _Z3_get_datatype_sort_recognizerPtr.asFunction<
          Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return idx_a'th accessor for the idx_c'th constructor.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx_c < Z3_get_datatype_sort_num_constructors(c, t)
  /// \pre idx_a < Z3_get_domain_size(c, Z3_get_datatype_sort_constructor(c, idx_c))
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_recognizer
  ///
  /// def_API('Z3_get_datatype_sort_constructor_accessor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT), _in(UINT)))
  Z3_func_decl Z3_get_datatype_sort_constructor_accessor(
    Z3_context c,
    Z3_sort t,
    int idx_c,
    int idx_a,
  ) {
    return _Z3_get_datatype_sort_constructor_accessor(
      c,
      t,
      idx_c,
      idx_a,
    );
  }

  late final _Z3_get_datatype_sort_constructor_accessorPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_constructor_accessor');
  late final _Z3_get_datatype_sort_constructor_accessor =
      _Z3_get_datatype_sort_constructor_accessorPtr.asFunction<
          Z3_func_decl Function(Z3_context, Z3_sort, int, int)>();

  /// \brief Update record field with a value.
  ///
  /// This corresponds to the 'with' construct in OCaml.
  /// It has the effect of updating a record field with a given value.
  /// The remaining fields are left unchanged. It is the record
  /// equivalent of an array store (see \sa Z3_mk_store).
  /// If the datatype has more than one constructor, then the update function
  /// behaves as identity if there is a mismatch between the accessor and
  /// constructor. For example ((_ update-field car) nil 1) is nil,
  /// while ((_ update-field car) (cons 2 nil) 1) is (cons 1 nil).
  ///
  ///
  /// \pre Z3_get_sort_kind(Z3_get_sort(c, t)) == Z3_get_domain(c, field_access, 1) == Z3_DATATYPE_SORT
  /// \pre Z3_get_sort(c, value) == Z3_get_range(c, field_access)
  ///
  ///
  /// def_API('Z3_datatype_update_field', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(AST), _in(AST)))
  Z3_ast Z3_datatype_update_field(
    Z3_context c,
    Z3_func_decl field_access,
    Z3_ast t,
    Z3_ast value,
  ) {
    return _Z3_datatype_update_field(
      c,
      field_access,
      t,
      value,
    );
  }

  late final _Z3_datatype_update_fieldPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, Z3_ast,
              Z3_ast)>>('Z3_datatype_update_field');
  late final _Z3_datatype_update_field = _Z3_datatype_update_fieldPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_decl, Z3_ast, Z3_ast)>();

  /// \brief Return arity of relation.
  ///
  /// \pre Z3_get_sort_kind(s) == Z3_RELATION_SORT
  ///
  /// \sa Z3_get_relation_column
  ///
  /// def_API('Z3_get_relation_arity', UINT, (_in(CONTEXT), _in(SORT)))
  int Z3_get_relation_arity(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_get_relation_arity(
      c,
      s,
    );
  }

  late final _Z3_get_relation_arityPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_relation_arity');
  late final _Z3_get_relation_arity =
      _Z3_get_relation_arityPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return sort at i'th column of relation sort.
  ///
  /// \pre Z3_get_sort_kind(c, s) == Z3_RELATION_SORT
  /// \pre col < Z3_get_relation_arity(c, s)
  ///
  /// \sa Z3_get_relation_arity
  ///
  /// def_API('Z3_get_relation_column', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_sort Z3_get_relation_column(
    Z3_context c,
    Z3_sort s,
    int col,
  ) {
    return _Z3_get_relation_column(
      c,
      s,
      col,
    );
  }

  late final _Z3_get_relation_columnPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_get_relation_column');
  late final _Z3_get_relation_column = _Z3_get_relation_columnPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_sort, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode p1 + p2 + ... + pn <= k
  ///
  /// def_API('Z3_mk_atmost', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
  Z3_ast Z3_mk_atmost(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    int k,
  ) {
    return _Z3_mk_atmost(
      c,
      num_args,
      args,
      k,
    );
  }

  late final _Z3_mk_atmostPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt)>>('Z3_mk_atmost');
  late final _Z3_mk_atmost = _Z3_mk_atmostPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode p1 + p2 + ... + pn >= k
  ///
  /// def_API('Z3_mk_atleast', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
  Z3_ast Z3_mk_atleast(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    int k,
  ) {
    return _Z3_mk_atleast(
      c,
      num_args,
      args,
      k,
    );
  }

  late final _Z3_mk_atleastPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt)>>('Z3_mk_atleast');
  late final _Z3_mk_atleast = _Z3_mk_atleastPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn <= k
  ///
  /// def_API('Z3_mk_pble', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast Z3_mk_pble(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _Z3_mk_pble(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _Z3_mk_pblePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pble');
  late final _Z3_mk_pble = _Z3_mk_pblePtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn >= k
  ///
  /// def_API('Z3_mk_pbge', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast Z3_mk_pbge(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _Z3_mk_pbge(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _Z3_mk_pbgePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pbge');
  late final _Z3_mk_pbge = _Z3_mk_pbgePtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn = k
  ///
  /// def_API('Z3_mk_pbeq', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast Z3_mk_pbeq(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _Z3_mk_pbeq(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _Z3_mk_pbeqPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pbeq');
  late final _Z3_mk_pbeq = _Z3_mk_pbeqPtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Convert a \c Z3_func_decl into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_func_decl_to_ast', AST, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_ast Z3_func_decl_to_ast(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _Z3_func_decl_to_ast(
      c,
      f,
    );
  }

  late final _Z3_func_decl_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_decl)>>(
          'Z3_func_decl_to_ast');
  late final _Z3_func_decl_to_ast = _Z3_func_decl_to_astPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl)>();

  /// \brief Compare terms.
  ///
  /// def_API('Z3_is_eq_func_decl', BOOL, (_in(CONTEXT), _in(FUNC_DECL), _in(FUNC_DECL)))
  int Z3_is_eq_func_decl(
    Z3_context c,
    Z3_func_decl f1,
    Z3_func_decl f2,
  ) {
    return _Z3_is_eq_func_decl(
      c,
      f1,
      f2,
    );
  }

  late final _Z3_is_eq_func_declPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              Z3_context, Z3_func_decl, Z3_func_decl)>>('Z3_is_eq_func_decl');
  late final _Z3_is_eq_func_decl = _Z3_is_eq_func_declPtr.asFunction<
      int Function(Z3_context, Z3_func_decl, Z3_func_decl)>();

  /// \brief Return a unique identifier for \c f.
  ///
  /// def_API('Z3_get_func_decl_id', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int Z3_get_func_decl_id(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _Z3_get_func_decl_id(
      c,
      f,
    );
  }

  late final _Z3_get_func_decl_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_decl)>>('Z3_get_func_decl_id');
  late final _Z3_get_func_decl_id = _Z3_get_func_decl_idPtr.asFunction<
      int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the constant declaration name as a symbol.
  ///
  /// def_API('Z3_get_decl_name', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_symbol Z3_get_decl_name(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_decl_name(
      c,
      d,
    );
  }

  late final _Z3_get_decl_namePtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_decl_name');
  late final _Z3_get_decl_name = _Z3_get_decl_namePtr.asFunction<
      Z3_symbol Function(Z3_context, Z3_func_decl)>();

  /// \brief Return declaration kind corresponding to declaration.
  ///
  /// def_API('Z3_get_decl_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int Z3_get_decl_kind(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_decl_kind(
      c,
      d,
    );
  }

  late final _Z3_get_decl_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_decl_kind');
  late final _Z3_get_decl_kind =
      _Z3_get_decl_kindPtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the number of parameters of the given declaration.
  ///
  /// \sa Z3_get_arity
  ///
  /// def_API('Z3_get_domain_size', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int Z3_get_domain_size(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_domain_size(
      c,
      d,
    );
  }

  late final _Z3_get_domain_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_decl)>>('Z3_get_domain_size');
  late final _Z3_get_domain_size = _Z3_get_domain_sizePtr.asFunction<
      int Function(Z3_context, Z3_func_decl)>();

  /// \brief Alias for \c Z3_get_domain_size.
  ///
  /// \sa Z3_get_domain_size
  ///
  /// def_API('Z3_get_arity', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int Z3_get_arity(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_arity(
      c,
      d,
    );
  }

  late final _Z3_get_arityPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_func_decl)>>('Z3_get_arity');
  late final _Z3_get_arity =
      _Z3_get_arityPtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the sort of the i-th parameter of the given function declaration.
  ///
  /// \pre i < Z3_get_domain_size(d)
  ///
  /// \sa Z3_get_domain_size
  ///
  /// def_API('Z3_get_domain', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_sort Z3_get_domain(
    Z3_context c,
    Z3_func_decl d,
    int i,
  ) {
    return _Z3_get_domain(
      c,
      d,
      i,
    );
  }

  late final _Z3_get_domainPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_func_decl, ffi.UnsignedInt)>>('Z3_get_domain');
  late final _Z3_get_domain = _Z3_get_domainPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the range of the given declaration.
  ///
  /// If \c d is a constant (i.e., has zero arguments), then this
  /// function returns the sort of the constant.
  ///
  /// def_API('Z3_get_range', SORT, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_sort Z3_get_range(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_range(
      c,
      d,
    );
  }

  late final _Z3_get_rangePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_range');
  late final _Z3_get_range =
      _Z3_get_rangePtr.asFunction<Z3_sort Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the number of parameters associated with a declaration.
  ///
  /// def_API('Z3_get_decl_num_parameters', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int Z3_get_decl_num_parameters(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_get_decl_num_parameters(
      c,
      d,
    );
  }

  late final _Z3_get_decl_num_parametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_decl)>>('Z3_get_decl_num_parameters');
  late final _Z3_get_decl_num_parameters = _Z3_get_decl_num_parametersPtr
      .asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the parameter type associated with a declaration.
  ///
  /// \param c the context
  /// \param d the function declaration
  /// \param idx is the index of the named parameter it should be between 0 and the number of parameters.
  ///
  /// def_API('Z3_get_decl_parameter_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  int Z3_get_decl_parameter_kind(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_parameter_kind(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_parameter_kindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_parameter_kind');
  late final _Z3_get_decl_parameter_kind = _Z3_get_decl_parameter_kindPtr
      .asFunction<int Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the integer value associated with an integer parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_INT
  ///
  /// def_API('Z3_get_decl_int_parameter', INT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  int Z3_get_decl_int_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_int_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_int_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_int_parameter');
  late final _Z3_get_decl_int_parameter = _Z3_get_decl_int_parameterPtr
      .asFunction<int Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the double value associated with an double parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_DOUBLE
  ///
  /// def_API('Z3_get_decl_double_parameter', DOUBLE, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  double Z3_get_decl_double_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_double_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_double_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_double_parameter');
  late final _Z3_get_decl_double_parameter = _Z3_get_decl_double_parameterPtr
      .asFunction<double Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the double value associated with an double parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SYMBOL
  ///
  /// def_API('Z3_get_decl_symbol_parameter', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_symbol Z3_get_decl_symbol_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_symbol_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_symbol_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_symbol_parameter');
  late final _Z3_get_decl_symbol_parameter = _Z3_get_decl_symbol_parameterPtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the sort value associated with a sort parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SORT
  ///
  /// def_API('Z3_get_decl_sort_parameter', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_sort Z3_get_decl_sort_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_sort_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_sort_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_sort_parameter');
  late final _Z3_get_decl_sort_parameter = _Z3_get_decl_sort_parameterPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the expression value associated with an expression parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_AST
  ///
  /// def_API('Z3_get_decl_ast_parameter', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_ast Z3_get_decl_ast_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_ast_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_ast_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_ast_parameter');
  late final _Z3_get_decl_ast_parameter = _Z3_get_decl_ast_parameterPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the expression value associated with an expression parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_FUNC_DECL
  ///
  /// def_API('Z3_get_decl_func_decl_parameter', FUNC_DECL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_func_decl Z3_get_decl_func_decl_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_func_decl_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_func_decl_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_func_decl_parameter');
  late final _Z3_get_decl_func_decl_parameter =
      _Z3_get_decl_func_decl_parameterPtr.asFunction<
          Z3_func_decl Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the rational value, as a string, associated with a rational parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_RATIONAL
  ///
  /// def_API('Z3_get_decl_rational_parameter', STRING, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_string Z3_get_decl_rational_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _Z3_get_decl_rational_parameter(
      c,
      d,
      idx,
    );
  }

  late final _Z3_get_decl_rational_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_rational_parameter');
  late final _Z3_get_decl_rational_parameter =
      _Z3_get_decl_rational_parameterPtr.asFunction<
          Z3_string Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Convert a \c Z3_app into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_app_to_ast', AST, (_in(CONTEXT), _in(APP)))
  Z3_ast Z3_app_to_ast(
    Z3_context c,
    Z3_app a,
  ) {
    return _Z3_app_to_ast(
      c,
      a,
    );
  }

  late final _Z3_app_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_app)>>(
          'Z3_app_to_ast');
  late final _Z3_app_to_ast =
      _Z3_app_to_astPtr.asFunction<Z3_ast Function(Z3_context, Z3_app)>();

  /// \brief Return the declaration of a constant or function application.
  ///
  /// def_API('Z3_get_app_decl', FUNC_DECL, (_in(CONTEXT), _in(APP)))
  Z3_func_decl Z3_get_app_decl(
    Z3_context c,
    Z3_app a,
  ) {
    return _Z3_get_app_decl(
      c,
      a,
    );
  }

  late final _Z3_get_app_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_app)>>(
          'Z3_get_app_decl');
  late final _Z3_get_app_decl = _Z3_get_app_declPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_app)>();

  /// \brief Return the number of argument of an application. If \c t
  /// is an constant, then the number of arguments is 0.
  ///
  /// def_API('Z3_get_app_num_args', UINT, (_in(CONTEXT), _in(APP)))
  int Z3_get_app_num_args(
    Z3_context c,
    Z3_app a,
  ) {
    return _Z3_get_app_num_args(
      c,
      a,
    );
  }

  late final _Z3_get_app_num_argsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_app)>>(
          'Z3_get_app_num_args');
  late final _Z3_get_app_num_args =
      _Z3_get_app_num_argsPtr.asFunction<int Function(Z3_context, Z3_app)>();

  /// \brief Return the i-th argument of the given application.
  ///
  /// \pre i < Z3_get_app_num_args(c, a)
  ///
  /// def_API('Z3_get_app_arg', AST, (_in(CONTEXT), _in(APP), _in(UINT)))
  Z3_ast Z3_get_app_arg(
    Z3_context c,
    Z3_app a,
    int i,
  ) {
    return _Z3_get_app_arg(
      c,
      a,
      i,
    );
  }

  late final _Z3_get_app_argPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_app, ffi.UnsignedInt)>>('Z3_get_app_arg');
  late final _Z3_get_app_arg =
      _Z3_get_app_argPtr.asFunction<Z3_ast Function(Z3_context, Z3_app, int)>();

  /// \brief Compare terms.
  ///
  /// def_API('Z3_is_eq_ast', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_is_eq_ast(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_is_eq_ast(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_is_eq_astPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_is_eq_ast');
  late final _Z3_is_eq_ast =
      _Z3_is_eq_astPtr.asFunction<int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return a unique identifier for \c t.
  /// The identifier is unique up to structural equality. Thus, two ast nodes
  /// created by the same context and having the same children and same function symbols
  /// have the same identifiers. Ast nodes created in the same context, but having
  /// different children or different functions have different identifiers.
  /// Variables and quantifiers are also assigned different identifiers according to
  /// their structure.
  ///
  /// def_API('Z3_get_ast_id', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_ast_id(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_get_ast_id(
      c,
      t,
    );
  }

  late final _Z3_get_ast_idPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_id');
  late final _Z3_get_ast_id =
      _Z3_get_ast_idPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return a hash code for the given AST.
  /// The hash code is structural but two different AST objects can map to the same hash.
  /// The result of \c Z3_get_ast_id returns an indentifier that is unique over the
  /// set of live AST objects.
  ///
  /// def_API('Z3_get_ast_hash', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_ast_hash(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_ast_hash(
      c,
      a,
    );
  }

  late final _Z3_get_ast_hashPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_hash');
  late final _Z3_get_ast_hash =
      _Z3_get_ast_hashPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the sort of an AST node.
  ///
  /// The AST node must be a constant, application, numeral, bound variable, or quantifier.
  ///
  /// def_API('Z3_get_sort', SORT, (_in(CONTEXT), _in(AST)))
  Z3_sort Z3_get_sort(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_sort(
      c,
      a,
    );
  }

  late final _Z3_get_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_ast)>>(
          'Z3_get_sort');
  late final _Z3_get_sort =
      _Z3_get_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if the given expression \c t is well sorted.
  ///
  /// def_API('Z3_is_well_sorted', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_well_sorted(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_is_well_sorted(
      c,
      t,
    );
  }

  late final _Z3_is_well_sortedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_well_sorted');
  late final _Z3_is_well_sorted =
      _Z3_is_well_sortedPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return \c Z3_L_TRUE if \c a is true, \c Z3_L_FALSE if it is false, and \c Z3_L_UNDEF otherwise.
  ///
  /// def_API('Z3_get_bool_value', LBOOL, (_in(CONTEXT), _in(AST)))
  int Z3_get_bool_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_bool_value(
      c,
      a,
    );
  }

  late final _Z3_get_bool_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_ast)>>(
          'Z3_get_bool_value');
  late final _Z3_get_bool_value =
      _Z3_get_bool_valuePtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the kind of the given AST.
  ///
  /// def_API('Z3_get_ast_kind', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_ast_kind(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_ast_kind(
      c,
      a,
    );
  }

  late final _Z3_get_ast_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_kind');
  late final _Z3_get_ast_kind =
      _Z3_get_ast_kindPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_is_app', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_app(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_app(
      c,
      a,
    );
  }

  late final _Z3_is_appPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_app');
  late final _Z3_is_app =
      _Z3_is_appPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_is_numeral_ast', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_numeral_ast(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_numeral_ast(
      c,
      a,
    );
  }

  late final _Z3_is_numeral_astPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_numeral_ast');
  late final _Z3_is_numeral_ast =
      _Z3_is_numeral_astPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if the given AST is a real algebraic number.
  ///
  /// def_API('Z3_is_algebraic_number', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_algebraic_number(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_algebraic_number(
      c,
      a,
    );
  }

  late final _Z3_is_algebraic_numberPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_algebraic_number');
  late final _Z3_is_algebraic_number =
      _Z3_is_algebraic_numberPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Convert an \c ast into an \c APP_AST. This is just type casting.
  ///
  /// \pre \code Z3_get_ast_kind(c, a) == \c Z3_APP_AST \endcode
  ///
  /// def_API('Z3_to_app', APP, (_in(CONTEXT), _in(AST)))
  Z3_app Z3_to_app(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_to_app(
      c,
      a,
    );
  }

  late final _Z3_to_appPtr =
      _lookup<ffi.NativeFunction<Z3_app Function(Z3_context, Z3_ast)>>(
          'Z3_to_app');
  late final _Z3_to_app =
      _Z3_to_appPtr.asFunction<Z3_app Function(Z3_context, Z3_ast)>();

  /// \brief Convert an AST into a FUNC_DECL_AST. This is just type casting.
  ///
  /// \pre \code Z3_get_ast_kind(c, a) == Z3_FUNC_DECL_AST \endcode
  ///
  /// def_API('Z3_to_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
  Z3_func_decl Z3_to_func_decl(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_to_func_decl(
      c,
      a,
    );
  }

  late final _Z3_to_func_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_ast)>>(
          'Z3_to_func_decl');
  late final _Z3_to_func_decl = _Z3_to_func_declPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a decimal string of a numeric constant term
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numeral_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string Z3_get_numeral_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_numeral_string(
      c,
      a,
    );
  }

  late final _Z3_get_numeral_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_string');
  late final _Z3_get_numeral_string = _Z3_get_numeral_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a binary string of a numeric constant term
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  /// \pre a represents a non-negative integer
  ///
  /// def_API('Z3_get_numeral_binary_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string Z3_get_numeral_binary_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_numeral_binary_string(
      c,
      a,
    );
  }

  late final _Z3_get_numeral_binary_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_binary_string');
  late final _Z3_get_numeral_binary_string = _Z3_get_numeral_binary_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral as a string in decimal notation.
  /// The result has at most \c precision decimal places.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_numeral_decimal_string', STRING, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_string Z3_get_numeral_decimal_string(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _Z3_get_numeral_decimal_string(
      c,
      a,
      precision,
    );
  }

  late final _Z3_get_numeral_decimal_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_numeral_decimal_string');
  late final _Z3_get_numeral_decimal_string = _Z3_get_numeral_decimal_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast, int)>();

  /// \brief Return numeral as a double.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_numeral_double', DOUBLE, (_in(CONTEXT), _in(AST)))
  double Z3_get_numeral_double(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_numeral_double(
      c,
      a,
    );
  }

  late final _Z3_get_numeral_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_double');
  late final _Z3_get_numeral_double = _Z3_get_numeral_doublePtr.asFunction<
      double Function(Z3_context, Z3_ast)>();

  /// \brief Return the numerator (as a numeral AST) of a numeral AST of sort Real.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numerator', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_get_numerator(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_numerator(
      c,
      a,
    );
  }

  late final _Z3_get_numeratorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_numerator');
  late final _Z3_get_numerator =
      _Z3_get_numeratorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return the denominator (as a numeral AST) of a numeral AST of sort Real.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_denominator', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_get_denominator(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_denominator(
      c,
      a,
    );
  }

  late final _Z3_get_denominatorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_denominator');
  late final _Z3_get_denominator =
      _Z3_get_denominatorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a pair of 64 bit numbers if the representation fits.
  ///
  /// \param c logical context.
  /// \param a term.
  /// \param num numerator.
  /// \param den denominator.
  ///
  /// Return \c true if the numeral value fits in 64 bit numerals, \c false otherwise.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numeral_small', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
  int Z3_get_numeral_small(
    Z3_context c,
    Z3_ast a,
    ffi.Pointer<ffi.Int64> num,
    ffi.Pointer<ffi.Int64> den,
  ) {
    return _Z3_get_numeral_small(
      c,
      a,
      num,
      den,
    );
  }

  late final _Z3_get_numeral_smallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_small');
  late final _Z3_get_numeral_small = _Z3_get_numeral_smallPtr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_int', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
  int Z3_get_numeral_int(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int> i,
  ) {
    return _Z3_get_numeral_int(
      c,
      v,
      i,
    );
  }

  late final _Z3_get_numeral_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>>('Z3_get_numeral_int');
  late final _Z3_get_numeral_int = _Z3_get_numeral_intPtr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine unsigned int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_uint', BOOL, (_in(CONTEXT), _in(AST), _out(UINT)))
  int Z3_get_numeral_uint(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.UnsignedInt> u,
  ) {
    return _Z3_get_numeral_uint(
      c,
      v,
      u,
    );
  }

  late final _Z3_get_numeral_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_numeral_uint');
  late final _Z3_get_numeral_uint = _Z3_get_numeral_uintPtr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine \c uint64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
  int Z3_get_numeral_uint64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Uint64> u,
  ) {
    return _Z3_get_numeral_uint64(
      c,
      v,
      u,
    );
  }

  late final _Z3_get_numeral_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Uint64>)>>('Z3_get_numeral_uint64');
  late final _Z3_get_numeral_uint64 = _Z3_get_numeral_uint64Ptr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine \c int64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64)))
  int Z3_get_numeral_int64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int64> i,
  ) {
    return _Z3_get_numeral_int64(
      c,
      v,
      i,
    );
  }

  late final _Z3_get_numeral_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_int64');
  late final _Z3_get_numeral_int64 = _Z3_get_numeral_int64Ptr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit as a rational number as machine \c int64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_rational_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
  int Z3_get_numeral_rational_int64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int64> num,
    ffi.Pointer<ffi.Int64> den,
  ) {
    return _Z3_get_numeral_rational_int64(
      c,
      v,
      num,
      den,
    );
  }

  late final _Z3_get_numeral_rational_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_rational_int64');
  late final _Z3_get_numeral_rational_int64 =
      _Z3_get_numeral_rational_int64Ptr.asFunction<
          int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>();

  /// \brief Return a lower bound for the given real algebraic number.
  /// The interval isolating the number is smaller than 1/10^precision.
  /// The result is a numeral AST of sort Real.
  ///
  /// \pre Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_algebraic_number_lower', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_get_algebraic_number_lower(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _Z3_get_algebraic_number_lower(
      c,
      a,
      precision,
    );
  }

  late final _Z3_get_algebraic_number_lowerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_algebraic_number_lower');
  late final _Z3_get_algebraic_number_lower = _Z3_get_algebraic_number_lowerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return a upper bound for the given real algebraic number.
  /// The interval isolating the number is smaller than 1/10^precision.
  /// The result is a numeral AST of sort Real.
  ///
  /// \pre Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_algebraic_number_upper', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_get_algebraic_number_upper(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _Z3_get_algebraic_number_upper(
      c,
      a,
      precision,
    );
  }

  late final _Z3_get_algebraic_number_upperPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_algebraic_number_upper');
  late final _Z3_get_algebraic_number_upper = _Z3_get_algebraic_number_upperPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Convert a Z3_pattern into Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_pattern_to_ast', AST, (_in(CONTEXT), _in(PATTERN)))
  Z3_ast Z3_pattern_to_ast(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _Z3_pattern_to_ast(
      c,
      p,
    );
  }

  late final _Z3_pattern_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_pattern)>>(
          'Z3_pattern_to_ast');
  late final _Z3_pattern_to_ast = _Z3_pattern_to_astPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_pattern)>();

  /// \brief Return number of terms in pattern.
  ///
  /// def_API('Z3_get_pattern_num_terms', UINT, (_in(CONTEXT), _in(PATTERN)))
  int Z3_get_pattern_num_terms(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _Z3_get_pattern_num_terms(
      c,
      p,
    );
  }

  late final _Z3_get_pattern_num_termsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_pattern)>>(
      'Z3_get_pattern_num_terms');
  late final _Z3_get_pattern_num_terms = _Z3_get_pattern_num_termsPtr
      .asFunction<int Function(Z3_context, Z3_pattern)>();

  /// \brief Return i'th ast in pattern.
  ///
  /// def_API('Z3_get_pattern', AST, (_in(CONTEXT), _in(PATTERN), _in(UINT)))
  Z3_ast Z3_get_pattern(
    Z3_context c,
    Z3_pattern p,
    int idx,
  ) {
    return _Z3_get_pattern(
      c,
      p,
      idx,
    );
  }

  late final _Z3_get_patternPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_pattern, ffi.UnsignedInt)>>('Z3_get_pattern');
  late final _Z3_get_pattern = _Z3_get_patternPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_pattern, int)>();

  /// \brief Return index of de-Bruijn bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_VAR_AST
  ///
  /// def_API('Z3_get_index_value', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_index_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_index_value(
      c,
      a,
    );
  }

  late final _Z3_get_index_valuePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_index_value');
  late final _Z3_get_index_value =
      _Z3_get_index_valuePtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Determine if an ast is a universal quantifier.
  ///
  /// def_API('Z3_is_quantifier_forall', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_quantifier_forall(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_quantifier_forall(
      c,
      a,
    );
  }

  late final _Z3_is_quantifier_forallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_quantifier_forall');
  late final _Z3_is_quantifier_forall = _Z3_is_quantifier_forallPtr.asFunction<
      int Function(Z3_context, Z3_ast)>();

  /// \brief Determine if ast is an existential quantifier.
  ///
  ///
  /// def_API('Z3_is_quantifier_exists', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_quantifier_exists(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_quantifier_exists(
      c,
      a,
    );
  }

  late final _Z3_is_quantifier_existsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_quantifier_exists');
  late final _Z3_is_quantifier_exists = _Z3_is_quantifier_existsPtr.asFunction<
      int Function(Z3_context, Z3_ast)>();

  /// \brief Determine if ast is a lambda expression.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_is_lambda', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_lambda(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_lambda(
      c,
      a,
    );
  }

  late final _Z3_is_lambdaPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_lambda');
  late final _Z3_is_lambda =
      _Z3_is_lambdaPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Obtain weight of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_weight', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_quantifier_weight(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_quantifier_weight(
      c,
      a,
    );
  }

  late final _Z3_get_quantifier_weightPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_weight');
  late final _Z3_get_quantifier_weight = _Z3_get_quantifier_weightPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return number of patterns used in quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_patterns', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_quantifier_num_patterns(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_quantifier_num_patterns(
      c,
      a,
    );
  }

  late final _Z3_get_quantifier_num_patternsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_patterns');
  late final _Z3_get_quantifier_num_patterns =
      _Z3_get_quantifier_num_patternsPtr.asFunction<
          int Function(Z3_context, Z3_ast)>();

  /// \brief Return i'th pattern.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_pattern_ast', PATTERN, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_pattern Z3_get_quantifier_pattern_ast(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _Z3_get_quantifier_pattern_ast(
      c,
      a,
      i,
    );
  }

  late final _Z3_get_quantifier_pattern_astPtr = _lookup<
      ffi.NativeFunction<
          Z3_pattern Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_pattern_ast');
  late final _Z3_get_quantifier_pattern_ast = _Z3_get_quantifier_pattern_astPtr
      .asFunction<Z3_pattern Function(Z3_context, Z3_ast, int)>();

  /// \brief Return number of no_patterns used in quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_no_patterns', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_quantifier_num_no_patterns(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_quantifier_num_no_patterns(
      c,
      a,
    );
  }

  late final _Z3_get_quantifier_num_no_patternsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_no_patterns');
  late final _Z3_get_quantifier_num_no_patterns =
      _Z3_get_quantifier_num_no_patternsPtr.asFunction<
          int Function(Z3_context, Z3_ast)>();

  /// \brief Return i'th no_pattern.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_no_pattern_ast', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_get_quantifier_no_pattern_ast(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _Z3_get_quantifier_no_pattern_ast(
      c,
      a,
      i,
    );
  }

  late final _Z3_get_quantifier_no_pattern_astPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_no_pattern_ast');
  late final _Z3_get_quantifier_no_pattern_ast =
      _Z3_get_quantifier_no_pattern_astPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return number of bound variables of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_bound', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_get_quantifier_num_bound(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_quantifier_num_bound(
      c,
      a,
    );
  }

  late final _Z3_get_quantifier_num_boundPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_bound');
  late final _Z3_get_quantifier_num_bound = _Z3_get_quantifier_num_boundPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return symbol of the i'th bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_bound_name', SYMBOL, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_symbol Z3_get_quantifier_bound_name(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _Z3_get_quantifier_bound_name(
      c,
      a,
      i,
    );
  }

  late final _Z3_get_quantifier_bound_namePtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_bound_name');
  late final _Z3_get_quantifier_bound_name = _Z3_get_quantifier_bound_namePtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_ast, int)>();

  /// \brief Return sort of the i'th bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_bound_sort', SORT, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_sort Z3_get_quantifier_bound_sort(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _Z3_get_quantifier_bound_sort(
      c,
      a,
      i,
    );
  }

  late final _Z3_get_quantifier_bound_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_bound_sort');
  late final _Z3_get_quantifier_bound_sort = _Z3_get_quantifier_bound_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_ast, int)>();

  /// \brief Return body of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_body', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_get_quantifier_body(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_quantifier_body(
      c,
      a,
    );
  }

  late final _Z3_get_quantifier_bodyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_body');
  late final _Z3_get_quantifier_body = _Z3_get_quantifier_bodyPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Interface to simplifier.
  ///
  /// Provides an interface to the AST simplifier used by Z3.
  /// It returns an AST object which is equal to the argument.
  /// The returned AST is simplified using algebraic simplification rules,
  /// such as constant propagation (propagating true/false over logical connectives).
  ///
  /// \sa Z3_simplify_ex
  ///
  /// def_API('Z3_simplify', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_simplify(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_simplify(
      c,
      a,
    );
  }

  late final _Z3_simplifyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_simplify');
  late final _Z3_simplify =
      _Z3_simplifyPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Interface to simplifier.
  ///
  /// Provides an interface to the AST simplifier used by Z3.
  /// This procedure is similar to #Z3_simplify, but the behavior of the simplifier
  /// can be configured using the given parameter set.
  ///
  /// \sa Z3_simplify
  /// \sa Z3_simplify_get_help
  /// \sa Z3_simplify_get_param_descrs
  ///
  /// def_API('Z3_simplify_ex', AST, (_in(CONTEXT), _in(AST), _in(PARAMS)))
  Z3_ast Z3_simplify_ex(
    Z3_context c,
    Z3_ast a,
    Z3_params p,
  ) {
    return _Z3_simplify_ex(
      c,
      a,
      p,
    );
  }

  late final _Z3_simplify_exPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_params)>>(
      'Z3_simplify_ex');
  late final _Z3_simplify_ex = _Z3_simplify_exPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_params)>();

  /// \brief Return a string describing all available parameters.
  ///
  /// \sa Z3_simplify_ex
  /// \sa Z3_simplify_get_param_descrs
  ///
  /// def_API('Z3_simplify_get_help', STRING, (_in(CONTEXT),))
  Z3_string Z3_simplify_get_help(
    Z3_context c,
  ) {
    return _Z3_simplify_get_help(
      c,
    );
  }

  late final _Z3_simplify_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context)>>(
          'Z3_simplify_get_help');
  late final _Z3_simplify_get_help =
      _Z3_simplify_get_helpPtr.asFunction<Z3_string Function(Z3_context)>();

  /// \brief Return the parameter description set for the simplify procedure.
  ///
  /// \sa Z3_simplify_ex
  /// \sa Z3_simplify_get_help
  ///
  /// def_API('Z3_simplify_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT),))
  Z3_param_descrs Z3_simplify_get_param_descrs(
    Z3_context c,
  ) {
    return _Z3_simplify_get_param_descrs(
      c,
    );
  }

  late final _Z3_simplify_get_param_descrsPtr =
      _lookup<ffi.NativeFunction<Z3_param_descrs Function(Z3_context)>>(
          'Z3_simplify_get_param_descrs');
  late final _Z3_simplify_get_param_descrs = _Z3_simplify_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context)>();

  /// @name Modifiers */
  /// /**@{*/
  /// /**
  /// \brief Update the arguments of term \c a using the arguments \c args.
  /// The number of arguments \c num_args should coincide
  /// with the number of arguments to \c a.
  /// If \c a is a quantifier, then num_args has to be 1.
  ///
  /// def_API('Z3_update_term', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast Z3_update_term(
    Z3_context c,
    Z3_ast a,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _Z3_update_term(
      c,
      a,
      num_args,
      args,
    );
  }

  late final _Z3_update_termPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_update_term');
  late final _Z3_update_term = _Z3_update_termPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute every occurrence of \ccode{from[i]} in \c a with \ccode{to[i]}, for \c i smaller than \c num_exprs.
  /// The result is the new AST. The arrays \c from and \c to must have size \c num_exprs.
  /// For every \c i smaller than \c num_exprs, we must have that sort of \ccode{from[i]} must be equal to sort of \ccode{to[i]}.
  ///
  /// def_API('Z3_substitute', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in_array(2, AST)))
  Z3_ast Z3_substitute(
    Z3_context c,
    Z3_ast a,
    int num_exprs,
    ffi.Pointer<Z3_ast> from,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _Z3_substitute(
      c,
      a,
      num_exprs,
      from,
      to,
    );
  }

  late final _Z3_substitutePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>>('Z3_substitute');
  late final _Z3_substitute = _Z3_substitutePtr.asFunction<
      Z3_ast Function(
          Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute the free variables in \c a with the expressions in \c to.
  /// For every \c i smaller than \c num_exprs, the variable with de-Bruijn index \c i is replaced with term \ccode{to[i]}.
  ///
  /// def_API('Z3_substitute_vars', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast Z3_substitute_vars(
    Z3_context c,
    Z3_ast a,
    int num_exprs,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _Z3_substitute_vars(
      c,
      a,
      num_exprs,
      to,
    );
  }

  late final _Z3_substitute_varsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_substitute_vars');
  late final _Z3_substitute_vars = _Z3_substitute_varsPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute funcions in \c from with new expressions in \c to.
  ///
  /// The expressions in \c to can have free variables. The free variable in \c to at index 0
  /// refers to the first argument of \c from, the free variable at index 1 corresponds to the second argument.
  ///
  /// def_API('Z3_substitute_funs', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, FUNC_DECL), _in_array(2, AST)))
  Z3_ast Z3_substitute_funs(
    Z3_context c,
    Z3_ast a,
    int num_funs,
    ffi.Pointer<Z3_func_decl> from,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _Z3_substitute_funs(
      c,
      a,
      num_funs,
      from,
      to,
    );
  }

  late final _Z3_substitute_funsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              Z3_ast,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_ast>)>>('Z3_substitute_funs');
  late final _Z3_substitute_funs = _Z3_substitute_funsPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_ast>)>();

  /// \brief Translate/Copy the AST \c a from context \c source to context \c target.
  /// AST \c a must have been created using context \c source.
  /// \pre source != target
  ///
  /// def_API('Z3_translate', AST, (_in(CONTEXT), _in(AST), _in(CONTEXT)))
  Z3_ast Z3_translate(
    Z3_context source,
    Z3_ast a,
    Z3_context target,
  ) {
    return _Z3_translate(
      source,
      a,
      target,
    );
  }

  late final _Z3_translatePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_context)>>(
      'Z3_translate');
  late final _Z3_translate = _Z3_translatePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_context)>();

  /// \brief Create a fresh model object. It has reference count 0.
  ///
  /// def_API('Z3_mk_model', MODEL, (_in(CONTEXT),))
  Z3_model Z3_mk_model(
    Z3_context c,
  ) {
    return _Z3_mk_model(
      c,
    );
  }

  late final _Z3_mk_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context)>>('Z3_mk_model');
  late final _Z3_mk_model =
      _Z3_mk_modelPtr.asFunction<Z3_model Function(Z3_context)>();

  /// \brief Increment the reference counter of the given model.
  ///
  /// def_API('Z3_model_inc_ref', VOID, (_in(CONTEXT), _in(MODEL)))
  void Z3_model_inc_ref(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_inc_ref(
      c,
      m,
    );
  }

  late final _Z3_model_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_model)>>(
          'Z3_model_inc_ref');
  late final _Z3_model_inc_ref =
      _Z3_model_inc_refPtr.asFunction<void Function(Z3_context, Z3_model)>();

  /// \brief Decrement the reference counter of the given model.
  ///
  /// def_API('Z3_model_dec_ref', VOID, (_in(CONTEXT), _in(MODEL)))
  void Z3_model_dec_ref(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_dec_ref(
      c,
      m,
    );
  }

  late final _Z3_model_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_model)>>(
          'Z3_model_dec_ref');
  late final _Z3_model_dec_ref =
      _Z3_model_dec_refPtr.asFunction<void Function(Z3_context, Z3_model)>();

  /// \brief Evaluate the AST node \c t in the given model.
  /// Return \c true if succeeded, and store the result in \c v.
  ///
  /// If \c model_completion is \c true, then Z3 will assign an interpretation for any constant or function that does
  /// not have an interpretation in \c m. These constants and functions were essentially don't cares.
  ///
  /// If \c model_completion is \c false, then Z3 will not assign interpretations to constants for functions that do
  /// not have interpretations in \c m. Evaluation behaves as the identify function in this case.
  ///
  /// The evaluation may fail for the following reasons:
  ///
  /// - \c t contains a quantifier.
  ///
  /// - the model \c m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions.
  /// That is, the option \ccode{MODEL_PARTIAL=true} was used.
  ///
  /// - \c t is type incorrect.
  ///
  /// - \c Z3_interrupt was invoked during evaluation.
  ///
  /// def_API('Z3_model_eval', BOOL, (_in(CONTEXT), _in(MODEL), _in(AST), _in(BOOL), _out(AST)))
  int Z3_model_eval(
    Z3_context c,
    Z3_model m,
    Z3_ast t,
    int model_completion,
    ffi.Pointer<Z3_ast> v,
  ) {
    return _Z3_model_eval(
      c,
      m,
      t,
      model_completion,
      v,
    );
  }

  late final _Z3_model_evalPtr = _lookup<
      ffi.NativeFunction<
          Z3_bool Function(Z3_context, Z3_model, Z3_ast, ffi.Int,
              ffi.Pointer<Z3_ast>)>>('Z3_model_eval');
  late final _Z3_model_eval = _Z3_model_evalPtr.asFunction<
      int Function(Z3_context, Z3_model, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Return the interpretation (i.e., assignment) of constant \c a in the model \c m.
  /// Return \c NULL, if the model does not assign an interpretation for \c a.
  /// That should be interpreted as: the value of \c a does not matter.
  ///
  /// \pre Z3_get_arity(c, a) == 0
  ///
  /// def_API('Z3_model_get_const_interp', AST, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  Z3_ast Z3_model_get_const_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl a,
  ) {
    return _Z3_model_get_const_interp(
      c,
      m,
      a,
    );
  }

  late final _Z3_model_get_const_interpPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_model,
              Z3_func_decl)>>('Z3_model_get_const_interp');
  late final _Z3_model_get_const_interp = _Z3_model_get_const_interpPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Test if there exists an interpretation (i.e., assignment) for \c a in the model \c m.
  ///
  /// def_API('Z3_model_has_interp', BOOL, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  int Z3_model_has_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl a,
  ) {
    return _Z3_model_has_interp(
      c,
      m,
      a,
    );
  }

  late final _Z3_model_has_interpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              Z3_context, Z3_model, Z3_func_decl)>>('Z3_model_has_interp');
  late final _Z3_model_has_interp = _Z3_model_has_interpPtr.asFunction<
      int Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Return the interpretation of the function \c f in the model \c m.
  /// Return \c NULL, if the model does not assign an interpretation for \c f.
  /// That should be interpreted as: the \c f does not matter.
  ///
  /// \pre Z3_get_arity(c, f) > 0
  ///
  /// \remark Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_model_get_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  Z3_func_interp Z3_model_get_func_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
  ) {
    return _Z3_model_get_func_interp(
      c,
      m,
      f,
    );
  }

  late final _Z3_model_get_func_interpPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_interp Function(
              Z3_context, Z3_model, Z3_func_decl)>>('Z3_model_get_func_interp');
  late final _Z3_model_get_func_interp =
      _Z3_model_get_func_interpPtr.asFunction<
          Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Return the number of constants assigned by the given model.
  ///
  /// \sa Z3_model_get_const_decl
  ///
  /// def_API('Z3_model_get_num_consts', UINT, (_in(CONTEXT), _in(MODEL)))
  int Z3_model_get_num_consts(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_get_num_consts(
      c,
      m,
    );
  }

  late final _Z3_model_get_num_constsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_consts');
  late final _Z3_model_get_num_consts = _Z3_model_get_num_constsPtr.asFunction<
      int Function(Z3_context, Z3_model)>();

  /// \brief Return the i-th constant in the given model.
  ///
  /// \pre i < Z3_model_get_num_consts(c, m)
  ///
  /// \sa Z3_model_eval
  ///
  /// def_API('Z3_model_get_const_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_func_decl Z3_model_get_const_decl(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _Z3_model_get_const_decl(
      c,
      m,
      i,
    );
  }

  late final _Z3_model_get_const_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_model,
              ffi.UnsignedInt)>>('Z3_model_get_const_decl');
  late final _Z3_model_get_const_decl = _Z3_model_get_const_declPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_model, int)>();

  /// \brief Return the number of function interpretations in the given model.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// Each entry in the finite map represents the value of a function given a set of arguments.
  ///
  /// def_API('Z3_model_get_num_funcs', UINT, (_in(CONTEXT), _in(MODEL)))
  int Z3_model_get_num_funcs(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_get_num_funcs(
      c,
      m,
    );
  }

  late final _Z3_model_get_num_funcsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_funcs');
  late final _Z3_model_get_num_funcs = _Z3_model_get_num_funcsPtr.asFunction<
      int Function(Z3_context, Z3_model)>();

  /// \brief Return the declaration of the i-th function in the given model.
  ///
  /// \pre i < Z3_model_get_num_funcs(c, m)
  ///
  /// \sa Z3_model_get_num_funcs
  ///
  /// def_API('Z3_model_get_func_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_func_decl Z3_model_get_func_decl(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _Z3_model_get_func_decl(
      c,
      m,
      i,
    );
  }

  late final _Z3_model_get_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_model,
              ffi.UnsignedInt)>>('Z3_model_get_func_decl');
  late final _Z3_model_get_func_decl = _Z3_model_get_func_declPtr.asFunction<
      Z3_func_decl Function(Z3_context, Z3_model, int)>();

  /// \brief Return the number of uninterpreted sorts that \c m assigns an interpretation to.
  ///
  /// Z3 also provides an interpretation for uninterpreted sorts used in a formula.
  /// The interpretation for a sort \c s is a finite set of distinct values. We say this finite set is
  /// the "universe" of \c s.
  ///
  /// \sa Z3_model_get_sort
  /// \sa Z3_model_get_sort_universe
  ///
  /// def_API('Z3_model_get_num_sorts', UINT, (_in(CONTEXT), _in(MODEL)))
  int Z3_model_get_num_sorts(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_get_num_sorts(
      c,
      m,
    );
  }

  late final _Z3_model_get_num_sortsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_sorts');
  late final _Z3_model_get_num_sorts = _Z3_model_get_num_sortsPtr.asFunction<
      int Function(Z3_context, Z3_model)>();

  /// \brief Return a uninterpreted sort that \c m assigns an interpretation.
  ///
  /// \pre i < Z3_model_get_num_sorts(c, m)
  ///
  /// \sa Z3_model_get_num_sorts
  /// \sa Z3_model_get_sort_universe
  ///
  /// def_API('Z3_model_get_sort', SORT, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_sort Z3_model_get_sort(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _Z3_model_get_sort(
      c,
      m,
      i,
    );
  }

  late final _Z3_model_get_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_model, ffi.UnsignedInt)>>('Z3_model_get_sort');
  late final _Z3_model_get_sort = _Z3_model_get_sortPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_model, int)>();

  /// \brief Return the finite set of distinct values that represent the interpretation for sort \c s.
  ///
  /// \sa Z3_model_get_num_sorts
  /// \sa Z3_model_get_sort
  ///
  /// def_API('Z3_model_get_sort_universe', AST_VECTOR, (_in(CONTEXT), _in(MODEL), _in(SORT)))
  Z3_ast_vector Z3_model_get_sort_universe(
    Z3_context c,
    Z3_model m,
    Z3_sort s,
  ) {
    return _Z3_model_get_sort_universe(
      c,
      m,
      s,
    );
  }

  late final _Z3_model_get_sort_universePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context, Z3_model, Z3_sort)>>('Z3_model_get_sort_universe');
  late final _Z3_model_get_sort_universe = _Z3_model_get_sort_universePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_model, Z3_sort)>();

  /// \brief translate model from context \c c to context \c dst.
  ///
  /// \remark Use this method for cloning state between contexts. Note that
  /// operations on contexts are not thread safe and therefore all operations
  /// that related to a given context have to be synchronized (or run in the same thread).
  ///
  /// def_API('Z3_model_translate', MODEL, (_in(CONTEXT), _in(MODEL), _in(CONTEXT)))
  Z3_model Z3_model_translate(
    Z3_context c,
    Z3_model m,
    Z3_context dst,
  ) {
    return _Z3_model_translate(
      c,
      m,
      dst,
    );
  }

  late final _Z3_model_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_model Function(
              Z3_context, Z3_model, Z3_context)>>('Z3_model_translate');
  late final _Z3_model_translate = _Z3_model_translatePtr.asFunction<
      Z3_model Function(Z3_context, Z3_model, Z3_context)>();

  /// \brief The \ccode{(_ as-array f)} AST node is a construct for assigning interpretations for arrays in Z3.
  /// It is the array such that forall indices \c i we have that \ccode{(select (_ as-array f) i)} is equal to \ccode{(f i)}.
  /// This procedure returns \c true if the \c a is an \c as-array AST node.
  ///
  /// Z3 current solvers have minimal support for \c as_array nodes.
  ///
  /// \sa Z3_get_as_array_func_decl
  ///
  /// def_API('Z3_is_as_array', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_is_as_array(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_is_as_array(
      c,
      a,
    );
  }

  late final _Z3_is_as_arrayPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_is_as_array');
  late final _Z3_is_as_array =
      _Z3_is_as_arrayPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the function declaration \c f associated with a \ccode{(_ as_array f)} node.
  ///
  /// \sa Z3_is_as_array
  ///
  /// def_API('Z3_get_as_array_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
  Z3_func_decl Z3_get_as_array_func_decl(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_get_as_array_func_decl(
      c,
      a,
    );
  }

  late final _Z3_get_as_array_func_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_ast)>>(
          'Z3_get_as_array_func_decl');
  late final _Z3_get_as_array_func_decl = _Z3_get_as_array_func_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_ast)>();

  /// \brief Create a fresh func_interp object, add it to a model for a specified function.
  /// It has reference count 0.
  ///
  /// \param c context
  /// \param m model
  /// \param f function declaration
  /// \param default_value default value for function interpretation
  ///
  /// def_API('Z3_add_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
  Z3_func_interp Z3_add_func_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
    Z3_ast default_value,
  ) {
    return _Z3_add_func_interp(
      c,
      m,
      f,
      default_value,
    );
  }

  late final _Z3_add_func_interpPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl,
              Z3_ast)>>('Z3_add_func_interp');
  late final _Z3_add_func_interp = _Z3_add_func_interpPtr.asFunction<
      Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl, Z3_ast)>();

  /// \brief Add a constant interpretation.
  ///
  /// def_API('Z3_add_const_interp', VOID, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
  void Z3_add_const_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
    Z3_ast a,
  ) {
    return _Z3_add_const_interp(
      c,
      m,
      f,
      a,
    );
  }

  late final _Z3_add_const_interpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_model, Z3_func_decl,
              Z3_ast)>>('Z3_add_const_interp');
  late final _Z3_add_const_interp = _Z3_add_const_interpPtr.asFunction<
      void Function(Z3_context, Z3_model, Z3_func_decl, Z3_ast)>();

  /// \brief Increment the reference counter of the given Z3_func_interp object.
  ///
  /// def_API('Z3_func_interp_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
  void Z3_func_interp_inc_ref(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _Z3_func_interp_inc_ref(
      c,
      f,
    );
  }

  late final _Z3_func_interp_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_interp)>>(
      'Z3_func_interp_inc_ref');
  late final _Z3_func_interp_inc_ref = _Z3_func_interp_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_func_interp)>();

  /// \brief Decrement the reference counter of the given Z3_func_interp object.
  ///
  /// def_API('Z3_func_interp_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
  void Z3_func_interp_dec_ref(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _Z3_func_interp_dec_ref(
      c,
      f,
    );
  }

  late final _Z3_func_interp_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_interp)>>(
      'Z3_func_interp_dec_ref');
  late final _Z3_func_interp_dec_ref = _Z3_func_interp_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_func_interp)>();

  /// \brief Return the number of entries in the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// Each entry in the finite map represents the value of a function given a set of arguments.
  /// This procedure return the number of element in the finite map of \c f.
  ///
  /// def_API('Z3_func_interp_get_num_entries', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
  int Z3_func_interp_get_num_entries(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _Z3_func_interp_get_num_entries(
      c,
      f,
    );
  }

  late final _Z3_func_interp_get_num_entriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_interp)>>('Z3_func_interp_get_num_entries');
  late final _Z3_func_interp_get_num_entries =
      _Z3_func_interp_get_num_entriesPtr.asFunction<
          int Function(Z3_context, Z3_func_interp)>();

  /// \brief Return a "point" of the given function interpretation. It represents the
  /// value of \c f in a particular point.
  ///
  /// \pre i < Z3_func_interp_get_num_entries(c, f)
  ///
  /// \sa Z3_func_interp_get_num_entries
  ///
  /// def_API('Z3_func_interp_get_entry', FUNC_ENTRY, (_in(CONTEXT), _in(FUNC_INTERP), _in(UINT)))
  Z3_func_entry Z3_func_interp_get_entry(
    Z3_context c,
    Z3_func_interp f,
    int i,
  ) {
    return _Z3_func_interp_get_entry(
      c,
      f,
      i,
    );
  }

  late final _Z3_func_interp_get_entryPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_entry Function(Z3_context, Z3_func_interp,
              ffi.UnsignedInt)>>('Z3_func_interp_get_entry');
  late final _Z3_func_interp_get_entry = _Z3_func_interp_get_entryPtr
      .asFunction<Z3_func_entry Function(Z3_context, Z3_func_interp, int)>();

  /// \brief Return the 'else' value of the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// This procedure returns the 'else' value.
  ///
  /// def_API('Z3_func_interp_get_else', AST, (_in(CONTEXT), _in(FUNC_INTERP)))
  Z3_ast Z3_func_interp_get_else(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _Z3_func_interp_get_else(
      c,
      f,
    );
  }

  late final _Z3_func_interp_get_elsePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_interp)>>(
          'Z3_func_interp_get_else');
  late final _Z3_func_interp_get_else = _Z3_func_interp_get_elsePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_interp)>();

  /// \brief Return the 'else' value of the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// This procedure can be used to update the 'else' value.
  ///
  /// def_API('Z3_func_interp_set_else', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST)))
  void Z3_func_interp_set_else(
    Z3_context c,
    Z3_func_interp f,
    Z3_ast else_value,
  ) {
    return _Z3_func_interp_set_else(
      c,
      f,
      else_value,
    );
  }

  late final _Z3_func_interp_set_elsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_func_interp, Z3_ast)>>('Z3_func_interp_set_else');
  late final _Z3_func_interp_set_else = _Z3_func_interp_set_elsePtr.asFunction<
      void Function(Z3_context, Z3_func_interp, Z3_ast)>();

  /// \brief Return the arity (number of arguments) of the given function interpretation.
  ///
  /// def_API('Z3_func_interp_get_arity', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
  int Z3_func_interp_get_arity(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _Z3_func_interp_get_arity(
      c,
      f,
    );
  }

  late final _Z3_func_interp_get_arityPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_interp)>>('Z3_func_interp_get_arity');
  late final _Z3_func_interp_get_arity = _Z3_func_interp_get_arityPtr
      .asFunction<int Function(Z3_context, Z3_func_interp)>();

  /// \brief add a function entry to a function interpretation.
  ///
  /// \param c logical context
  /// \param fi a function interpretation to be updated.
  /// \param args list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.
  /// \param value value of the function when the parameters match args.
  ///
  /// It is assumed that entries added to a function cover disjoint arguments.
  /// If an two entries are added with the same arguments, only the second insertion survives and the
  /// first inserted entry is removed.
  ///
  /// def_API('Z3_func_interp_add_entry', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST_VECTOR), _in(AST)))
  void Z3_func_interp_add_entry(
    Z3_context c,
    Z3_func_interp fi,
    Z3_ast_vector args,
    Z3_ast value,
  ) {
    return _Z3_func_interp_add_entry(
      c,
      fi,
      args,
      value,
    );
  }

  late final _Z3_func_interp_add_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_func_interp, Z3_ast_vector,
              Z3_ast)>>('Z3_func_interp_add_entry');
  late final _Z3_func_interp_add_entry =
      _Z3_func_interp_add_entryPtr.asFunction<
          void Function(Z3_context, Z3_func_interp, Z3_ast_vector, Z3_ast)>();

  /// \brief Increment the reference counter of the given \c Z3_func_entry object.
  ///
  /// def_API('Z3_func_entry_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
  void Z3_func_entry_inc_ref(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _Z3_func_entry_inc_ref(
      c,
      e,
    );
  }

  late final _Z3_func_entry_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_inc_ref');
  late final _Z3_func_entry_inc_ref = _Z3_func_entry_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_func_entry)>();

  /// \brief Decrement the reference counter of the given \c Z3_func_entry object.
  ///
  /// def_API('Z3_func_entry_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
  void Z3_func_entry_dec_ref(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _Z3_func_entry_dec_ref(
      c,
      e,
    );
  }

  late final _Z3_func_entry_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_dec_ref');
  late final _Z3_func_entry_dec_ref = _Z3_func_entry_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_func_entry)>();

  /// \brief Return the value of this point.
  ///
  /// A \c Z3_func_entry object represents an element in the finite map used to encode
  /// a function interpretation.
  ///
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_value', AST, (_in(CONTEXT), _in(FUNC_ENTRY)))
  Z3_ast Z3_func_entry_get_value(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _Z3_func_entry_get_value(
      c,
      e,
    );
  }

  late final _Z3_func_entry_get_valuePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_get_value');
  late final _Z3_func_entry_get_value = _Z3_func_entry_get_valuePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_entry)>();

  /// \brief Return the number of arguments in a \c Z3_func_entry object.
  ///
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_num_args', UINT, (_in(CONTEXT), _in(FUNC_ENTRY)))
  int Z3_func_entry_get_num_args(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _Z3_func_entry_get_num_args(
      c,
      e,
    );
  }

  late final _Z3_func_entry_get_num_argsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_entry)>>('Z3_func_entry_get_num_args');
  late final _Z3_func_entry_get_num_args = _Z3_func_entry_get_num_argsPtr
      .asFunction<int Function(Z3_context, Z3_func_entry)>();

  /// \brief Return an argument of a \c Z3_func_entry object.
  ///
  /// \pre i < Z3_func_entry_get_num_args(c, e)
  ///
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_arg', AST, (_in(CONTEXT), _in(FUNC_ENTRY), _in(UINT)))
  Z3_ast Z3_func_entry_get_arg(
    Z3_context c,
    Z3_func_entry e,
    int i,
  ) {
    return _Z3_func_entry_get_arg(
      c,
      e,
      i,
    );
  }

  late final _Z3_func_entry_get_argPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_entry,
              ffi.UnsignedInt)>>('Z3_func_entry_get_arg');
  late final _Z3_func_entry_get_arg = _Z3_func_entry_get_argPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_entry, int)>();

  /// @name Interaction logging */
  /// /**@{*/
  /// /**
  /// \brief Log interaction to a file.
  ///
  /// extra_API('Z3_open_log', INT, (_in(STRING),))
  int Z3_open_log(
    Z3_string filename,
  ) {
    return _Z3_open_log(
      filename,
    );
  }

  late final _Z3_open_logPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_string)>>('Z3_open_log');
  late final _Z3_open_log =
      _Z3_open_logPtr.asFunction<int Function(Z3_string)>();

  /// \brief Append user-defined string to interaction log.
  ///
  /// The interaction log is opened using Z3_open_log.
  /// It contains the formulas that are checked using Z3.
  /// You can use this command to append comments, for instance.
  ///
  /// extra_API('Z3_append_log', VOID, (_in(STRING),))
  void Z3_append_log(
    Z3_string string,
  ) {
    return _Z3_append_log(
      string,
    );
  }

  late final _Z3_append_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_append_log');
  late final _Z3_append_log =
      _Z3_append_logPtr.asFunction<void Function(Z3_string)>();

  /// \brief Close interaction log.
  ///
  /// extra_API('Z3_close_log', VOID, ())
  void Z3_close_log() {
    return _Z3_close_log();
  }

  late final _Z3_close_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_close_log');
  late final _Z3_close_log = _Z3_close_logPtr.asFunction<void Function()>();

  /// \brief Enable/disable printing warning messages to the console.
  ///
  /// Warnings are printed after passing \c true, warning messages are
  /// suppressed after calling this method with \c false.
  ///
  /// def_API('Z3_toggle_warning_messages', VOID, (_in(BOOL),))
  void Z3_toggle_warning_messages(
    int enabled,
  ) {
    return _Z3_toggle_warning_messages(
      enabled,
    );
  }

  late final _Z3_toggle_warning_messagesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'Z3_toggle_warning_messages');
  late final _Z3_toggle_warning_messages =
      _Z3_toggle_warning_messagesPtr.asFunction<void Function(int)>();

  /// @name String conversion */
  /// /**@{*/
  /// /**
  /// \brief Select mode for the format used for pretty-printing AST nodes.
  ///
  /// The default mode for pretty printing AST nodes is to produce
  /// SMT-LIB style output where common subexpressions are printed
  /// at each occurrence. The mode is called \c Z3_PRINT_SMTLIB_FULL.
  /// To print shared common subexpressions only once,
  /// use the \c Z3_PRINT_LOW_LEVEL mode.
  /// To print in way that conforms to SMT-LIB standards and uses let
  /// expressions to share common sub-expressions use \c Z3_PRINT_SMTLIB2_COMPLIANT.
  ///
  /// \sa Z3_ast_to_string
  /// \sa Z3_pattern_to_string
  /// \sa Z3_func_decl_to_string
  ///
  /// def_API('Z3_set_ast_print_mode', VOID, (_in(CONTEXT), _in(PRINT_MODE)))
  void Z3_set_ast_print_mode(
    Z3_context c,
    int mode,
  ) {
    return _Z3_set_ast_print_mode(
      c,
      mode,
    );
  }

  late final _Z3_set_ast_print_modePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, ffi.Int32)>>(
          'Z3_set_ast_print_mode');
  late final _Z3_set_ast_print_mode =
      _Z3_set_ast_print_modePtr.asFunction<void Function(Z3_context, int)>();

  /// \brief Convert the given AST node into a string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_ast_to_string.
  ///
  /// \sa Z3_pattern_to_string
  /// \sa Z3_sort_to_string
  ///
  /// def_API('Z3_ast_to_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string Z3_ast_to_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_ast_to_string(
      c,
      a,
    );
  }

  late final _Z3_ast_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_ast_to_string');
  late final _Z3_ast_to_string =
      _Z3_ast_to_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_pattern_to_string', STRING, (_in(CONTEXT), _in(PATTERN)))
  Z3_string Z3_pattern_to_string(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _Z3_pattern_to_string(
      c,
      p,
    );
  }

  late final _Z3_pattern_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_pattern)>>(
          'Z3_pattern_to_string');
  late final _Z3_pattern_to_string = _Z3_pattern_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_pattern)>();

  /// def_API('Z3_sort_to_string', STRING, (_in(CONTEXT), _in(SORT)))
  Z3_string Z3_sort_to_string(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_sort_to_string(
      c,
      s,
    );
  }

  late final _Z3_sort_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_sort)>>(
          'Z3_sort_to_string');
  late final _Z3_sort_to_string = _Z3_sort_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_sort)>();

  /// def_API('Z3_func_decl_to_string', STRING, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_string Z3_func_decl_to_string(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _Z3_func_decl_to_string(
      c,
      d,
    );
  }

  late final _Z3_func_decl_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_func_decl)>>(
          'Z3_func_decl_to_string');
  late final _Z3_func_decl_to_string = _Z3_func_decl_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_func_decl)>();

  /// \brief Convert the given model into a string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_model_to_string.
  ///
  /// def_API('Z3_model_to_string', STRING, (_in(CONTEXT), _in(MODEL)))
  Z3_string Z3_model_to_string(
    Z3_context c,
    Z3_model m,
  ) {
    return _Z3_model_to_string(
      c,
      m,
    );
  }

  late final _Z3_model_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_model)>>(
          'Z3_model_to_string');
  late final _Z3_model_to_string = _Z3_model_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_model)>();

  /// \brief Convert the given benchmark into SMT-LIB formatted string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_benchmark_to_smtlib_string.
  ///
  /// \param c - context.
  /// \param name - name of benchmark. The argument is optional.
  /// \param logic - the benchmark logic.
  /// \param status - the status string (sat, unsat, or unknown)
  /// \param attributes - other attributes, such as source, difficulty or category.
  /// \param num_assumptions - number of assumptions.
  /// \param assumptions - auxiliary assumptions.
  /// \param formula - formula to be checked for consistency in conjunction with assumptions.
  ///
  /// def_API('Z3_benchmark_to_smtlib_string', STRING, (_in(CONTEXT), _in(STRING), _in(STRING), _in(STRING), _in(STRING), _in(UINT), _in_array(5, AST), _in(AST)))
  Z3_string Z3_benchmark_to_smtlib_string(
    Z3_context c,
    Z3_string name,
    Z3_string logic,
    Z3_string status,
    Z3_string attributes,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
    Z3_ast formula,
  ) {
    return _Z3_benchmark_to_smtlib_string(
      c,
      name,
      logic,
      status,
      attributes,
      num_assumptions,
      assumptions,
      formula,
    );
  }

  late final _Z3_benchmark_to_smtlib_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(
              Z3_context,
              Z3_string,
              Z3_string,
              Z3_string,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_benchmark_to_smtlib_string');
  late final _Z3_benchmark_to_smtlib_string =
      _Z3_benchmark_to_smtlib_stringPtr.asFunction<
          Z3_string Function(Z3_context, Z3_string, Z3_string, Z3_string,
              Z3_string, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// @name Parser interface */
  /// /**@{*/
  /// /**
  /// \brief Parse the given string using the SMT-LIB2 parser.
  ///
  /// It returns a formula comprising of the conjunction of assertions in the scope
  /// (up to push/pop) at the end of the string.
  ///
  /// def_API('Z3_parse_smtlib2_string', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
  Z3_ast_vector Z3_parse_smtlib2_string(
    Z3_context c,
    Z3_string str,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    int num_decls,
    ffi.Pointer<Z3_symbol> decl_names,
    ffi.Pointer<Z3_func_decl> decls,
  ) {
    return _Z3_parse_smtlib2_string(
      c,
      str,
      num_sorts,
      sort_names,
      sorts,
      num_decls,
      decl_names,
      decls,
    );
  }

  late final _Z3_parse_smtlib2_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_parse_smtlib2_string');
  late final _Z3_parse_smtlib2_string = _Z3_parse_smtlib2_stringPtr.asFunction<
      Z3_ast_vector Function(
          Z3_context,
          Z3_string,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Similar to #Z3_parse_smtlib2_string, but reads the benchmark from a file.
  ///
  /// def_API('Z3_parse_smtlib2_file', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
  Z3_ast_vector Z3_parse_smtlib2_file(
    Z3_context c,
    Z3_string file_name,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    int num_decls,
    ffi.Pointer<Z3_symbol> decl_names,
    ffi.Pointer<Z3_func_decl> decls,
  ) {
    return _Z3_parse_smtlib2_file(
      c,
      file_name,
      num_sorts,
      sort_names,
      sorts,
      num_decls,
      decl_names,
      decls,
    );
  }

  late final _Z3_parse_smtlib2_filePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_parse_smtlib2_file');
  late final _Z3_parse_smtlib2_file = _Z3_parse_smtlib2_filePtr.asFunction<
      Z3_ast_vector Function(
          Z3_context,
          Z3_string,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Parse and evaluate and SMT-LIB2 command sequence. The state from a previous call is saved so the next
  /// evaluation builds on top of the previous call.
  ///
  /// \returns output generated from processing commands.
  ///
  /// def_API('Z3_eval_smtlib2_string', STRING, (_in(CONTEXT), _in(STRING),))
  Z3_string Z3_eval_smtlib2_string(
    Z3_context arg0,
    Z3_string str,
  ) {
    return _Z3_eval_smtlib2_string(
      arg0,
      str,
    );
  }

  late final _Z3_eval_smtlib2_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_eval_smtlib2_string');
  late final _Z3_eval_smtlib2_string = _Z3_eval_smtlib2_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Return the error code for the last API call.
  ///
  /// A call to a Z3 function may return a non Z3_OK error code,
  /// when it is not used correctly.
  ///
  /// \sa Z3_set_error_handler
  ///
  /// def_API('Z3_get_error_code', UINT, (_in(CONTEXT), ))
  int Z3_get_error_code(
    Z3_context c,
  ) {
    return _Z3_get_error_code(
      c,
    );
  }

  late final _Z3_get_error_codePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context)>>(
          'Z3_get_error_code');
  late final _Z3_get_error_code =
      _Z3_get_error_codePtr.asFunction<int Function(Z3_context)>();

  /// \brief Register a Z3 error handler.
  ///
  /// A call to a Z3 function may return a non \c Z3_OK error code, when
  /// it is not used correctly.  An error handler can be registered
  /// and will be called in this case.  To disable the use of the
  /// error handler, simply register with \c h=NULL.
  ///
  /// \warning Log files, created using #Z3_open_log, may be potentially incomplete/incorrect if error handlers are used.
  ///
  /// \sa Z3_get_error_code
  void Z3_set_error_handler(
    Z3_context c,
    ffi.Pointer<Z3_error_handler> h,
  ) {
    return _Z3_set_error_handler(
      c,
      h,
    );
  }

  late final _Z3_set_error_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context,
              ffi.Pointer<Z3_error_handler>)>>('Z3_set_error_handler');
  late final _Z3_set_error_handler = _Z3_set_error_handlerPtr.asFunction<
      void Function(Z3_context, ffi.Pointer<Z3_error_handler>)>();

  /// \brief Set an error.
  ///
  /// def_API('Z3_set_error', VOID, (_in(CONTEXT), _in(ERROR_CODE)))
  void Z3_set_error(
    Z3_context c,
    int e,
  ) {
    return _Z3_set_error(
      c,
      e,
    );
  }

  late final _Z3_set_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, ffi.Int32)>>(
          'Z3_set_error');
  late final _Z3_set_error =
      _Z3_set_errorPtr.asFunction<void Function(Z3_context, int)>();

  /// \brief Return a string describing the given error code.
  ///
  /// def_API('Z3_get_error_msg', STRING, (_in(CONTEXT), _in(ERROR_CODE)))
  Z3_string Z3_get_error_msg(
    Z3_context c,
    int err,
  ) {
    return _Z3_get_error_msg(
      c,
      err,
    );
  }

  late final _Z3_get_error_msgPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, ffi.Int32)>>(
          'Z3_get_error_msg');
  late final _Z3_get_error_msg =
      _Z3_get_error_msgPtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return Z3 version number information.
  ///
  /// \sa Z3_get_full_version
  ///
  /// def_API('Z3_get_version', VOID, (_out(UINT), _out(UINT), _out(UINT), _out(UINT)))
  void Z3_get_version(
    ffi.Pointer<ffi.UnsignedInt> major,
    ffi.Pointer<ffi.UnsignedInt> minor,
    ffi.Pointer<ffi.UnsignedInt> build_number,
    ffi.Pointer<ffi.UnsignedInt> revision_number,
  ) {
    return _Z3_get_version(
      major,
      minor,
      build_number,
      revision_number,
    );
  }

  late final _Z3_get_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_version');
  late final _Z3_get_version = _Z3_get_versionPtr.asFunction<
      void Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Return a string that fully describes the version of Z3 in use.
  ///
  /// \sa Z3_get_version
  ///
  /// def_API('Z3_get_full_version', STRING, ())
  Z3_string Z3_get_full_version() {
    return _Z3_get_full_version();
  }

  late final _Z3_get_full_versionPtr =
      _lookup<ffi.NativeFunction<Z3_string Function()>>('Z3_get_full_version');
  late final _Z3_get_full_version =
      _Z3_get_full_versionPtr.asFunction<Z3_string Function()>();

  /// \brief Enable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
  /// It is a NOOP otherwise
  ///
  /// \sa Z3_disable_trace
  ///
  /// def_API('Z3_enable_trace', VOID, (_in(STRING),))
  void Z3_enable_trace(
    Z3_string tag,
  ) {
    return _Z3_enable_trace(
      tag,
    );
  }

  late final _Z3_enable_tracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_enable_trace');
  late final _Z3_enable_trace =
      _Z3_enable_tracePtr.asFunction<void Function(Z3_string)>();

  /// \brief Disable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
  /// It is a NOOP otherwise
  ///
  /// \sa Z3_enable_trace
  ///
  /// def_API('Z3_disable_trace', VOID, (_in(STRING),))
  void Z3_disable_trace(
    Z3_string tag,
  ) {
    return _Z3_disable_trace(
      tag,
    );
  }

  late final _Z3_disable_tracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_disable_trace');
  late final _Z3_disable_trace =
      _Z3_disable_tracePtr.asFunction<void Function(Z3_string)>();

  /// \brief Reset all allocated resources.
  ///
  /// Use this facility on out-of memory errors.
  /// It allows discharging the previous state and resuming afresh.
  /// Any pointers previously returned by the API
  /// become invalid.
  ///
  /// def_API('Z3_reset_memory', VOID, ())
  void Z3_reset_memory() {
    return _Z3_reset_memory();
  }

  late final _Z3_reset_memoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_reset_memory');
  late final _Z3_reset_memory =
      _Z3_reset_memoryPtr.asFunction<void Function()>();

  /// \brief Destroy all allocated resources.
  ///
  /// Any pointers previously returned by the API become invalid.
  /// Can be used for memory leak detection.
  ///
  /// def_API('Z3_finalize_memory', VOID, ())
  void Z3_finalize_memory() {
    return _Z3_finalize_memory();
  }

  late final _Z3_finalize_memoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_finalize_memory');
  late final _Z3_finalize_memory =
      _Z3_finalize_memoryPtr.asFunction<void Function()>();

  /// @name Goals */
  /// /**@{*/
  /// /**
  /// \brief Create a goal (aka problem). A goal is essentially a set
  /// of formulas, that can be solved and/or transformed using
  /// tactics and solvers.
  ///
  /// If \c models is \c true, then model generation is enabled for the new goal.
  ///
  /// If \c unsat_cores is \c true, then unsat core generation is enabled for the new goal.
  ///
  /// If \c proofs is \c true, then proof generation is enabled for the new goal. Remark, the
  /// Z3 context \c c must have been created with proof generation support.
  ///
  /// \remark Reference counting must be used to manage goals, even when the \c Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_goal', GOAL, (_in(CONTEXT), _in(BOOL), _in(BOOL), _in(BOOL)))
  Z3_goal Z3_mk_goal(
    Z3_context c,
    int models,
    int unsat_cores,
    int proofs,
  ) {
    return _Z3_mk_goal(
      c,
      models,
      unsat_cores,
      proofs,
    );
  }

  late final _Z3_mk_goalPtr = _lookup<
      ffi.NativeFunction<
          Z3_goal Function(
              Z3_context, ffi.Int, ffi.Int, ffi.Int)>>('Z3_mk_goal');
  late final _Z3_mk_goal =
      _Z3_mk_goalPtr.asFunction<Z3_goal Function(Z3_context, int, int, int)>();

  /// \brief Increment the reference counter of the given goal.
  ///
  /// def_API('Z3_goal_inc_ref', VOID, (_in(CONTEXT), _in(GOAL)))
  void Z3_goal_inc_ref(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_inc_ref(
      c,
      g,
    );
  }

  late final _Z3_goal_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_inc_ref');
  late final _Z3_goal_inc_ref =
      _Z3_goal_inc_refPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Decrement the reference counter of the given goal.
  ///
  /// def_API('Z3_goal_dec_ref', VOID, (_in(CONTEXT), _in(GOAL)))
  void Z3_goal_dec_ref(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_dec_ref(
      c,
      g,
    );
  }

  late final _Z3_goal_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_dec_ref');
  late final _Z3_goal_dec_ref =
      _Z3_goal_dec_refPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Return the "precision" of the given goal. Goals can be transformed using over and under approximations.
  /// A under approximation is applied when the objective is to find a model for a given goal.
  /// An over approximation is applied when the objective is to find a proof for a given goal.
  ///
  /// def_API('Z3_goal_precision', UINT, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_precision(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_precision(
      c,
      g,
    );
  }

  late final _Z3_goal_precisionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_goal)>>(
          'Z3_goal_precision');
  late final _Z3_goal_precision =
      _Z3_goal_precisionPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Add a new formula \c a to the given goal.
  /// The formula is split according to the following procedure that is applied
  /// until a fixed-point:
  /// Conjunctions are split into separate formulas.
  /// Negations are distributed over disjunctions, resulting in separate formulas.
  /// If the goal is \c false, adding new formulas is a no-op.
  /// If the formula \c a is \c true, then nothing is added.
  /// If the formula \c a is \c false, then the entire goal is replaced by the formula \c false.
  ///
  /// def_API('Z3_goal_assert', VOID, (_in(CONTEXT), _in(GOAL), _in(AST)))
  void Z3_goal_assert(
    Z3_context c,
    Z3_goal g,
    Z3_ast a,
  ) {
    return _Z3_goal_assert(
      c,
      g,
      a,
    );
  }

  late final _Z3_goal_assertPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal, Z3_ast)>>(
      'Z3_goal_assert');
  late final _Z3_goal_assert = _Z3_goal_assertPtr.asFunction<
      void Function(Z3_context, Z3_goal, Z3_ast)>();

  /// \brief Return \c true if the given goal contains the formula \c false.
  ///
  /// def_API('Z3_goal_inconsistent', BOOL, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_inconsistent(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_inconsistent(
      c,
      g,
    );
  }

  late final _Z3_goal_inconsistentPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_goal)>>(
          'Z3_goal_inconsistent');
  late final _Z3_goal_inconsistent =
      _Z3_goal_inconsistentPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Return the depth of the given goal. It tracks how many transformations were applied to it.
  ///
  /// def_API('Z3_goal_depth', UINT, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_depth(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_depth(
      c,
      g,
    );
  }

  late final _Z3_goal_depthPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_depth');
  late final _Z3_goal_depth =
      _Z3_goal_depthPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Erase all formulas from the given goal.
  ///
  /// def_API('Z3_goal_reset', VOID, (_in(CONTEXT), _in(GOAL)))
  void Z3_goal_reset(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_reset(
      c,
      g,
    );
  }

  late final _Z3_goal_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_reset');
  late final _Z3_goal_reset =
      _Z3_goal_resetPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Return the number of formulas in the given goal.
  ///
  /// def_API('Z3_goal_size', UINT, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_size(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_size(
      c,
      g,
    );
  }

  late final _Z3_goal_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_size');
  late final _Z3_goal_size =
      _Z3_goal_sizePtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Return a formula from the given goal.
  ///
  /// \pre idx < Z3_goal_size(c, g)
  ///
  /// def_API('Z3_goal_formula', AST, (_in(CONTEXT), _in(GOAL), _in(UINT)))
  Z3_ast Z3_goal_formula(
    Z3_context c,
    Z3_goal g,
    int idx,
  ) {
    return _Z3_goal_formula(
      c,
      g,
      idx,
    );
  }

  late final _Z3_goal_formulaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_goal, ffi.UnsignedInt)>>('Z3_goal_formula');
  late final _Z3_goal_formula = _Z3_goal_formulaPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_goal, int)>();

  /// \brief Return the number of formulas, subformulas and terms in the given goal.
  ///
  /// def_API('Z3_goal_num_exprs', UINT, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_num_exprs(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_num_exprs(
      c,
      g,
    );
  }

  late final _Z3_goal_num_exprsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_num_exprs');
  late final _Z3_goal_num_exprs =
      _Z3_goal_num_exprsPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Return \c true if the goal is empty, and it is precise or the product of a under approximation.
  ///
  /// def_API('Z3_goal_is_decided_sat', BOOL, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_is_decided_sat(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_is_decided_sat(
      c,
      g,
    );
  }

  late final _Z3_goal_is_decided_satPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_goal)>>(
          'Z3_goal_is_decided_sat');
  late final _Z3_goal_is_decided_sat = _Z3_goal_is_decided_satPtr.asFunction<
      int Function(Z3_context, Z3_goal)>();

  /// \brief Return \c true if the goal contains false, and it is precise or the product of an over approximation.
  ///
  /// def_API('Z3_goal_is_decided_unsat', BOOL, (_in(CONTEXT), _in(GOAL)))
  int Z3_goal_is_decided_unsat(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_is_decided_unsat(
      c,
      g,
    );
  }

  late final _Z3_goal_is_decided_unsatPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_goal)>>(
          'Z3_goal_is_decided_unsat');
  late final _Z3_goal_is_decided_unsat = _Z3_goal_is_decided_unsatPtr
      .asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Copy a goal \c g from the context \c source to the context \c target.
  ///
  /// def_API('Z3_goal_translate', GOAL, (_in(CONTEXT), _in(GOAL), _in(CONTEXT)))
  Z3_goal Z3_goal_translate(
    Z3_context source,
    Z3_goal g,
    Z3_context target,
  ) {
    return _Z3_goal_translate(
      source,
      g,
      target,
    );
  }

  late final _Z3_goal_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_goal Function(
              Z3_context, Z3_goal, Z3_context)>>('Z3_goal_translate');
  late final _Z3_goal_translate = _Z3_goal_translatePtr.asFunction<
      Z3_goal Function(Z3_context, Z3_goal, Z3_context)>();

  /// \brief Convert a model of the formulas of a goal to a model of an original goal.
  /// The model may be null, in which case the returned model is valid if the goal was
  /// established satisfiable.
  ///
  /// def_API('Z3_goal_convert_model', MODEL, (_in(CONTEXT), _in(GOAL), _in(MODEL)))
  Z3_model Z3_goal_convert_model(
    Z3_context c,
    Z3_goal g,
    Z3_model m,
  ) {
    return _Z3_goal_convert_model(
      c,
      g,
      m,
    );
  }

  late final _Z3_goal_convert_modelPtr = _lookup<
          ffi.NativeFunction<Z3_model Function(Z3_context, Z3_goal, Z3_model)>>(
      'Z3_goal_convert_model');
  late final _Z3_goal_convert_model = _Z3_goal_convert_modelPtr.asFunction<
      Z3_model Function(Z3_context, Z3_goal, Z3_model)>();

  /// \brief Convert a goal into a string.
  ///
  /// def_API('Z3_goal_to_string', STRING, (_in(CONTEXT), _in(GOAL)))
  Z3_string Z3_goal_to_string(
    Z3_context c,
    Z3_goal g,
  ) {
    return _Z3_goal_to_string(
      c,
      g,
    );
  }

  late final _Z3_goal_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_goal)>>(
          'Z3_goal_to_string');
  late final _Z3_goal_to_string = _Z3_goal_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_goal)>();

  /// \brief Convert a goal into a DIMACS formatted string.
  /// The goal must be in CNF. You can convert a goal to CNF
  /// by applying the tseitin-cnf tactic. Bit-vectors are not automatically
  /// converted to Booleans either, so if the caller intends to
  /// preserve satisfiability, it should apply bit-blasting tactics.
  /// Quantifiers and theory atoms will not be encoded.
  ///
  /// def_API('Z3_goal_to_dimacs_string', STRING, (_in(CONTEXT), _in(GOAL), _in(BOOL)))
  Z3_string Z3_goal_to_dimacs_string(
    Z3_context c,
    Z3_goal g,
    int include_names,
  ) {
    return _Z3_goal_to_dimacs_string(
      c,
      g,
      include_names,
    );
  }

  late final _Z3_goal_to_dimacs_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_goal, ffi.Int)>>(
      'Z3_goal_to_dimacs_string');
  late final _Z3_goal_to_dimacs_string = _Z3_goal_to_dimacs_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_goal, int)>();

  /// @name Tactics and Probes */
  /// /**@{*/
  /// /**
  /// \brief Return a tactic associated with the given name.
  /// The complete list of tactics may be obtained using the procedures #Z3_get_num_tactics and #Z3_get_tactic_name.
  /// It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.
  ///
  /// Tactics are the basic building block for creating custom solvers for specific problem domains.
  ///
  /// def_API('Z3_mk_tactic', TACTIC, (_in(CONTEXT), _in(STRING)))
  Z3_tactic Z3_mk_tactic(
    Z3_context c,
    Z3_string name,
  ) {
    return _Z3_mk_tactic(
      c,
      name,
    );
  }

  late final _Z3_mk_tacticPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context, Z3_string)>>(
          'Z3_mk_tactic');
  late final _Z3_mk_tactic =
      _Z3_mk_tacticPtr.asFunction<Z3_tactic Function(Z3_context, Z3_string)>();

  /// \brief Increment the reference counter of the given tactic.
  ///
  /// def_API('Z3_tactic_inc_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
  void Z3_tactic_inc_ref(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _Z3_tactic_inc_ref(
      c,
      t,
    );
  }

  late final _Z3_tactic_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_inc_ref');
  late final _Z3_tactic_inc_ref =
      _Z3_tactic_inc_refPtr.asFunction<void Function(Z3_context, Z3_tactic)>();

  /// \brief Decrement the reference counter of the given tactic.
  ///
  /// def_API('Z3_tactic_dec_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
  void Z3_tactic_dec_ref(
    Z3_context c,
    Z3_tactic g,
  ) {
    return _Z3_tactic_dec_ref(
      c,
      g,
    );
  }

  late final _Z3_tactic_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_dec_ref');
  late final _Z3_tactic_dec_ref =
      _Z3_tactic_dec_refPtr.asFunction<void Function(Z3_context, Z3_tactic)>();

  /// \brief Return a probe associated with the given name.
  /// The complete list of probes may be obtained using the procedures #Z3_get_num_probes and #Z3_get_probe_name.
  /// It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.
  ///
  /// Probes are used to inspect a goal (aka problem) and collect information that may be used to decide
  /// which solver and/or preprocessing step will be used.
  ///
  /// def_API('Z3_mk_probe', PROBE, (_in(CONTEXT), _in(STRING)))
  Z3_probe Z3_mk_probe(
    Z3_context c,
    Z3_string name,
  ) {
    return _Z3_mk_probe(
      c,
      name,
    );
  }

  late final _Z3_mk_probePtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, Z3_string)>>(
          'Z3_mk_probe');
  late final _Z3_mk_probe =
      _Z3_mk_probePtr.asFunction<Z3_probe Function(Z3_context, Z3_string)>();

  /// \brief Increment the reference counter of the given probe.
  ///
  /// def_API('Z3_probe_inc_ref', VOID, (_in(CONTEXT), _in(PROBE)))
  void Z3_probe_inc_ref(
    Z3_context c,
    Z3_probe p,
  ) {
    return _Z3_probe_inc_ref(
      c,
      p,
    );
  }

  late final _Z3_probe_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_probe)>>(
          'Z3_probe_inc_ref');
  late final _Z3_probe_inc_ref =
      _Z3_probe_inc_refPtr.asFunction<void Function(Z3_context, Z3_probe)>();

  /// \brief Decrement the reference counter of the given probe.
  ///
  /// def_API('Z3_probe_dec_ref', VOID, (_in(CONTEXT), _in(PROBE)))
  void Z3_probe_dec_ref(
    Z3_context c,
    Z3_probe p,
  ) {
    return _Z3_probe_dec_ref(
      c,
      p,
    );
  }

  late final _Z3_probe_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_probe)>>(
          'Z3_probe_dec_ref');
  late final _Z3_probe_dec_ref =
      _Z3_probe_dec_refPtr.asFunction<void Function(Z3_context, Z3_probe)>();

  /// \brief Return a tactic that applies \c t1 to a given goal and \c t2
  /// to every subgoal produced by \c t1.
  ///
  /// def_API('Z3_tactic_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic Z3_tactic_and_then(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _Z3_tactic_and_then(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_tactic_and_thenPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_and_then');
  late final _Z3_tactic_and_then = _Z3_tactic_and_thenPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that first applies \c t1 to a given goal,
  /// if it fails then returns the result of \c t2 applied to the given goal.
  ///
  /// def_API('Z3_tactic_or_else', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic Z3_tactic_or_else(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _Z3_tactic_or_else(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_tactic_or_elsePtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_or_else');
  late final _Z3_tactic_or_else = _Z3_tactic_or_elsePtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that applies the given tactics in parallel.
  ///
  /// def_API('Z3_tactic_par_or', TACTIC, (_in(CONTEXT), _in(UINT), _in_array(1, TACTIC)))
  Z3_tactic Z3_tactic_par_or(
    Z3_context c,
    int num,
    ffi.Pointer<Z3_tactic> ts,
  ) {
    return _Z3_tactic_par_or(
      c,
      num,
      ts,
    );
  }

  late final _Z3_tactic_par_orPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_tactic>)>>('Z3_tactic_par_or');
  late final _Z3_tactic_par_or = _Z3_tactic_par_orPtr.asFunction<
      Z3_tactic Function(Z3_context, int, ffi.Pointer<Z3_tactic>)>();

  /// \brief Return a tactic that applies \c t1 to a given goal and then \c t2
  /// to every subgoal produced by \c t1. The subgoals are processed in parallel.
  ///
  /// def_API('Z3_tactic_par_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic Z3_tactic_par_and_then(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _Z3_tactic_par_and_then(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_tactic_par_and_thenPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_par_and_then');
  late final _Z3_tactic_par_and_then = _Z3_tactic_par_and_thenPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that applies \c t to a given goal for \c ms milliseconds.
  /// If \c t does not terminate in \c ms milliseconds, then it fails.
  ///
  /// def_API('Z3_tactic_try_for', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
  Z3_tactic Z3_tactic_try_for(
    Z3_context c,
    Z3_tactic t,
    int ms,
  ) {
    return _Z3_tactic_try_for(
      c,
      t,
      ms,
    );
  }

  late final _Z3_tactic_try_forPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, ffi.UnsignedInt)>>('Z3_tactic_try_for');
  late final _Z3_tactic_try_for = _Z3_tactic_try_forPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, int)>();

  /// \brief Return a tactic that applies \c t to a given goal is the probe \c p evaluates to true.
  /// If \c p evaluates to false, then the new tactic behaves like the skip tactic.
  ///
  /// def_API('Z3_tactic_when', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC)))
  Z3_tactic Z3_tactic_when(
    Z3_context c,
    Z3_probe p,
    Z3_tactic t,
  ) {
    return _Z3_tactic_when(
      c,
      p,
      t,
    );
  }

  late final _Z3_tactic_whenPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_probe, Z3_tactic)>>('Z3_tactic_when');
  late final _Z3_tactic_when = _Z3_tactic_whenPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_probe, Z3_tactic)>();

  /// \brief Return a tactic that applies \c t1 to a given goal if the probe \c p evaluates to true,
  /// and \c t2 if \c p evaluates to false.
  ///
  /// def_API('Z3_tactic_cond', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC), _in(TACTIC)))
  Z3_tactic Z3_tactic_cond(
    Z3_context c,
    Z3_probe p,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _Z3_tactic_cond(
      c,
      p,
      t1,
      t2,
    );
  }

  late final _Z3_tactic_condPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_probe, Z3_tactic, Z3_tactic)>>('Z3_tactic_cond');
  late final _Z3_tactic_cond = _Z3_tactic_condPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_probe, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that keeps applying \c t until the goal is not modified anymore or the maximum
  /// number of iterations \c max is reached.
  ///
  /// def_API('Z3_tactic_repeat', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
  Z3_tactic Z3_tactic_repeat(
    Z3_context c,
    Z3_tactic t,
    int max,
  ) {
    return _Z3_tactic_repeat(
      c,
      t,
      max,
    );
  }

  late final _Z3_tactic_repeatPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, ffi.UnsignedInt)>>('Z3_tactic_repeat');
  late final _Z3_tactic_repeat = _Z3_tactic_repeatPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, int)>();

  /// \brief Return a tactic that just return the given goal.
  ///
  /// def_API('Z3_tactic_skip', TACTIC, (_in(CONTEXT),))
  Z3_tactic Z3_tactic_skip(
    Z3_context c,
  ) {
    return _Z3_tactic_skip(
      c,
    );
  }

  late final _Z3_tactic_skipPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_skip');
  late final _Z3_tactic_skip =
      _Z3_tactic_skipPtr.asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that always fails.
  ///
  /// def_API('Z3_tactic_fail', TACTIC, (_in(CONTEXT),))
  Z3_tactic Z3_tactic_fail(
    Z3_context c,
  ) {
    return _Z3_tactic_fail(
      c,
    );
  }

  late final _Z3_tactic_failPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_fail');
  late final _Z3_tactic_fail =
      _Z3_tactic_failPtr.asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that fails if the probe \c p evaluates to false.
  ///
  /// def_API('Z3_tactic_fail_if', TACTIC, (_in(CONTEXT), _in(PROBE)))
  Z3_tactic Z3_tactic_fail_if(
    Z3_context c,
    Z3_probe p,
  ) {
    return _Z3_tactic_fail_if(
      c,
      p,
    );
  }

  late final _Z3_tactic_fail_ifPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context, Z3_probe)>>(
          'Z3_tactic_fail_if');
  late final _Z3_tactic_fail_if = _Z3_tactic_fail_ifPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_probe)>();

  /// \brief Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or
  /// trivially unsatisfiable (i.e., contains false).
  ///
  /// def_API('Z3_tactic_fail_if_not_decided', TACTIC, (_in(CONTEXT),))
  Z3_tactic Z3_tactic_fail_if_not_decided(
    Z3_context c,
  ) {
    return _Z3_tactic_fail_if_not_decided(
      c,
    );
  }

  late final _Z3_tactic_fail_if_not_decidedPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_fail_if_not_decided');
  late final _Z3_tactic_fail_if_not_decided = _Z3_tactic_fail_if_not_decidedPtr
      .asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that applies \c t using the given set of parameters.
  ///
  /// def_API('Z3_tactic_using_params', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(PARAMS)))
  Z3_tactic Z3_tactic_using_params(
    Z3_context c,
    Z3_tactic t,
    Z3_params p,
  ) {
    return _Z3_tactic_using_params(
      c,
      t,
      p,
    );
  }

  late final _Z3_tactic_using_paramsPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_params)>>('Z3_tactic_using_params');
  late final _Z3_tactic_using_params = _Z3_tactic_using_paramsPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_tactic, Z3_params)>();

  /// \brief Return a probe that always evaluates to val.
  ///
  /// def_API('Z3_probe_const', PROBE, (_in(CONTEXT), _in(DOUBLE)))
  Z3_probe Z3_probe_const(
    Z3_context x,
    double val,
  ) {
    return _Z3_probe_const(
      x,
      val,
    );
  }

  late final _Z3_probe_constPtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, ffi.Double)>>(
          'Z3_probe_const');
  late final _Z3_probe_const =
      _Z3_probe_constPtr.asFunction<Z3_probe Function(Z3_context, double)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is less than the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_lt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_lt(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_lt(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_ltPtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_lt');
  late final _Z3_probe_lt = _Z3_probe_ltPtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is greater than the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_gt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_gt(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_gt(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_gtPtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_gt');
  late final _Z3_probe_gt = _Z3_probe_gtPtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is less than or equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_le', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_le(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_le(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_lePtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_le');
  late final _Z3_probe_le = _Z3_probe_lePtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is greater than or equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_ge', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_ge(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_ge(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_gePtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_ge');
  late final _Z3_probe_ge = _Z3_probe_gePtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_eq', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_eq(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_eq(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_eqPtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_eq');
  late final _Z3_probe_eq = _Z3_probe_eqPtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p1 and \c p2 evaluates to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_and', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_and(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_and(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_andPtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_and');
  late final _Z3_probe_and = _Z3_probe_andPtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p1 or \c p2 evaluates to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_or', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe Z3_probe_or(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _Z3_probe_or(
      x,
      p1,
      p2,
    );
  }

  late final _Z3_probe_orPtr = _lookup<
      ffi.NativeFunction<
          Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>('Z3_probe_or');
  late final _Z3_probe_or = _Z3_probe_orPtr.asFunction<
      Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p does not evaluate to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_not', PROBE, (_in(CONTEXT), _in(PROBE)))
  Z3_probe Z3_probe_not(
    Z3_context x,
    Z3_probe p,
  ) {
    return _Z3_probe_not(
      x,
      p,
    );
  }

  late final _Z3_probe_notPtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, Z3_probe)>>(
          'Z3_probe_not');
  late final _Z3_probe_not =
      _Z3_probe_notPtr.asFunction<Z3_probe Function(Z3_context, Z3_probe)>();

  /// \brief Return the number of builtin tactics available in Z3.
  ///
  /// def_API('Z3_get_num_tactics', UINT, (_in(CONTEXT),))
  int Z3_get_num_tactics(
    Z3_context c,
  ) {
    return _Z3_get_num_tactics(
      c,
    );
  }

  late final _Z3_get_num_tacticsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context)>>(
          'Z3_get_num_tactics');
  late final _Z3_get_num_tactics =
      _Z3_get_num_tacticsPtr.asFunction<int Function(Z3_context)>();

  /// \brief Return the name of the idx tactic.
  ///
  /// \pre i < Z3_get_num_tactics(c)
  ///
  /// def_API('Z3_get_tactic_name', STRING, (_in(CONTEXT), _in(UINT)))
  Z3_string Z3_get_tactic_name(
    Z3_context c,
    int i,
  ) {
    return _Z3_get_tactic_name(
      c,
      i,
    );
  }

  late final _Z3_get_tactic_namePtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_get_tactic_name');
  late final _Z3_get_tactic_name =
      _Z3_get_tactic_namePtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return the number of builtin probes available in Z3.
  ///
  /// def_API('Z3_get_num_probes', UINT, (_in(CONTEXT),))
  int Z3_get_num_probes(
    Z3_context c,
  ) {
    return _Z3_get_num_probes(
      c,
    );
  }

  late final _Z3_get_num_probesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context)>>(
          'Z3_get_num_probes');
  late final _Z3_get_num_probes =
      _Z3_get_num_probesPtr.asFunction<int Function(Z3_context)>();

  /// \brief Return the name of the \c i probe.
  ///
  /// \pre i < Z3_get_num_probes(c)
  ///
  /// def_API('Z3_get_probe_name', STRING, (_in(CONTEXT), _in(UINT)))
  Z3_string Z3_get_probe_name(
    Z3_context c,
    int i,
  ) {
    return _Z3_get_probe_name(
      c,
      i,
    );
  }

  late final _Z3_get_probe_namePtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_get_probe_name');
  late final _Z3_get_probe_name =
      _Z3_get_probe_namePtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return a string containing a description of parameters accepted by the given tactic.
  ///
  /// def_API('Z3_tactic_get_help', STRING, (_in(CONTEXT), _in(TACTIC)))
  Z3_string Z3_tactic_get_help(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _Z3_tactic_get_help(
      c,
      t,
    );
  }

  late final _Z3_tactic_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_get_help');
  late final _Z3_tactic_get_help = _Z3_tactic_get_helpPtr.asFunction<
      Z3_string Function(Z3_context, Z3_tactic)>();

  /// \brief Return the parameter description set for the given tactic object.
  ///
  /// def_API('Z3_tactic_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(TACTIC)))
  Z3_param_descrs Z3_tactic_get_param_descrs(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _Z3_tactic_get_param_descrs(
      c,
      t,
    );
  }

  late final _Z3_tactic_get_param_descrsPtr = _lookup<
          ffi.NativeFunction<Z3_param_descrs Function(Z3_context, Z3_tactic)>>(
      'Z3_tactic_get_param_descrs');
  late final _Z3_tactic_get_param_descrs = _Z3_tactic_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_tactic)>();

  /// \brief Return a string containing a description of the tactic with the given name.
  ///
  /// def_API('Z3_tactic_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
  Z3_string Z3_tactic_get_descr(
    Z3_context c,
    Z3_string name,
  ) {
    return _Z3_tactic_get_descr(
      c,
      name,
    );
  }

  late final _Z3_tactic_get_descrPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_tactic_get_descr');
  late final _Z3_tactic_get_descr = _Z3_tactic_get_descrPtr.asFunction<
      Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Return a string containing a description of the probe with the given name.
  ///
  /// def_API('Z3_probe_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
  Z3_string Z3_probe_get_descr(
    Z3_context c,
    Z3_string name,
  ) {
    return _Z3_probe_get_descr(
      c,
      name,
    );
  }

  late final _Z3_probe_get_descrPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_probe_get_descr');
  late final _Z3_probe_get_descr = _Z3_probe_get_descrPtr.asFunction<
      Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Execute the probe over the goal. The probe always produce a double value.
  /// "Boolean" probes return 0.0 for false, and a value different from 0.0 for true.
  ///
  /// def_API('Z3_probe_apply', DOUBLE, (_in(CONTEXT), _in(PROBE), _in(GOAL)))
  double Z3_probe_apply(
    Z3_context c,
    Z3_probe p,
    Z3_goal g,
  ) {
    return _Z3_probe_apply(
      c,
      p,
      g,
    );
  }

  late final _Z3_probe_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              Z3_context, Z3_probe, Z3_goal)>>('Z3_probe_apply');
  late final _Z3_probe_apply = _Z3_probe_applyPtr.asFunction<
      double Function(Z3_context, Z3_probe, Z3_goal)>();

  /// \brief Apply tactic \c t to the goal \c g.
  ///
  /// def_API('Z3_tactic_apply', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL)))
  Z3_apply_result Z3_tactic_apply(
    Z3_context c,
    Z3_tactic t,
    Z3_goal g,
  ) {
    return _Z3_tactic_apply(
      c,
      t,
      g,
    );
  }

  late final _Z3_tactic_applyPtr = _lookup<
      ffi.NativeFunction<
          Z3_apply_result Function(
              Z3_context, Z3_tactic, Z3_goal)>>('Z3_tactic_apply');
  late final _Z3_tactic_apply = _Z3_tactic_applyPtr.asFunction<
      Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal)>();

  /// \brief Apply tactic \c t to the goal \c g using the parameter set \c p.
  ///
  /// def_API('Z3_tactic_apply_ex', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL), _in(PARAMS)))
  Z3_apply_result Z3_tactic_apply_ex(
    Z3_context c,
    Z3_tactic t,
    Z3_goal g,
    Z3_params p,
  ) {
    return _Z3_tactic_apply_ex(
      c,
      t,
      g,
      p,
    );
  }

  late final _Z3_tactic_apply_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal,
              Z3_params)>>('Z3_tactic_apply_ex');
  late final _Z3_tactic_apply_ex = _Z3_tactic_apply_exPtr.asFunction<
      Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal, Z3_params)>();

  /// \brief Increment the reference counter of the given \c Z3_apply_result object.
  ///
  /// def_API('Z3_apply_result_inc_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
  void Z3_apply_result_inc_ref(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _Z3_apply_result_inc_ref(
      c,
      r,
    );
  }

  late final _Z3_apply_result_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_inc_ref');
  late final _Z3_apply_result_inc_ref = _Z3_apply_result_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_apply_result)>();

  /// \brief Decrement the reference counter of the given \c Z3_apply_result object.
  ///
  /// def_API('Z3_apply_result_dec_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
  void Z3_apply_result_dec_ref(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _Z3_apply_result_dec_ref(
      c,
      r,
    );
  }

  late final _Z3_apply_result_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_dec_ref');
  late final _Z3_apply_result_dec_ref = _Z3_apply_result_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_apply_result)>();

  /// \brief Convert the \c Z3_apply_result object returned by #Z3_tactic_apply into a string.
  ///
  /// def_API('Z3_apply_result_to_string', STRING, (_in(CONTEXT), _in(APPLY_RESULT)))
  Z3_string Z3_apply_result_to_string(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _Z3_apply_result_to_string(
      c,
      r,
    );
  }

  late final _Z3_apply_result_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_to_string');
  late final _Z3_apply_result_to_string = _Z3_apply_result_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_apply_result)>();

  /// \brief Return the number of subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.
  ///
  /// def_API('Z3_apply_result_get_num_subgoals', UINT, (_in(CONTEXT), _in(APPLY_RESULT)))
  int Z3_apply_result_get_num_subgoals(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _Z3_apply_result_get_num_subgoals(
      c,
      r,
    );
  }

  late final _Z3_apply_result_get_num_subgoalsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context,
              Z3_apply_result)>>('Z3_apply_result_get_num_subgoals');
  late final _Z3_apply_result_get_num_subgoals =
      _Z3_apply_result_get_num_subgoalsPtr.asFunction<
          int Function(Z3_context, Z3_apply_result)>();

  /// \brief Return one of the subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.
  ///
  /// \pre i < Z3_apply_result_get_num_subgoals(c, r)
  ///
  /// def_API('Z3_apply_result_get_subgoal', GOAL, (_in(CONTEXT), _in(APPLY_RESULT), _in(UINT)))
  Z3_goal Z3_apply_result_get_subgoal(
    Z3_context c,
    Z3_apply_result r,
    int i,
  ) {
    return _Z3_apply_result_get_subgoal(
      c,
      r,
      i,
    );
  }

  late final _Z3_apply_result_get_subgoalPtr = _lookup<
      ffi.NativeFunction<
          Z3_goal Function(Z3_context, Z3_apply_result,
              ffi.UnsignedInt)>>('Z3_apply_result_get_subgoal');
  late final _Z3_apply_result_get_subgoal = _Z3_apply_result_get_subgoalPtr
      .asFunction<Z3_goal Function(Z3_context, Z3_apply_result, int)>();

  /// @name Solvers*/
  /// /**@{*/
  /// /**
  /// \brief Create a new solver. This solver is a "combined solver" (see
  /// combined_solver module) that internally uses a non-incremental (solver1) and an
  /// incremental solver (solver2). This combined solver changes its behaviour based
  /// on how it is used and how its parameters are set.
  ///
  /// If the solver is used in a non incremental way (i.e. no calls to
  /// #Z3_solver_push() or #Z3_solver_pop(), and no calls to
  /// #Z3_solver_assert() or #Z3_solver_assert_and_track() after checking
  /// satisfiability without an intervening #Z3_solver_reset()) then solver1
  /// will be used. This solver will apply Z3's "default" tactic.
  ///
  /// The "default" tactic will attempt to probe the logic used by the
  /// assertions and will apply a specialized tactic if one is supported.
  /// Otherwise the general `(and-then simplify smt)` tactic will be used.
  ///
  /// If the solver is used in an incremental way then the combined solver
  /// will switch to using solver2 (which behaves similarly to the general
  /// "smt" tactic).
  ///
  /// Note however it is possible to set the `solver2_timeout`,
  /// `solver2_unknown`, and `ignore_solver1` parameters of the combined
  /// solver to change its behaviour.
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// The function #Z3_solver_get_model can also be used even
  /// if the result is \c Z3_L_UNDEF, but the returned model
  /// is not guaranteed to satisfy quantified assertions.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_solver', SOLVER, (_in(CONTEXT),))
  Z3_solver Z3_mk_solver(
    Z3_context c,
  ) {
    return _Z3_mk_solver(
      c,
    );
  }

  late final _Z3_mk_solverPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context)>>(
          'Z3_mk_solver');
  late final _Z3_mk_solver =
      _Z3_mk_solverPtr.asFunction<Z3_solver Function(Z3_context)>();

  /// \brief Create a new incremental solver.
  ///
  /// This is equivalent to applying the "smt" tactic.
  ///
  /// Unlike #Z3_mk_solver() this solver
  /// - Does not attempt to apply any logic specific tactics.
  /// - Does not change its behaviour based on whether it used
  /// incrementally/non-incrementally.
  ///
  /// Note that these differences can result in very different performance
  /// compared to #Z3_mk_solver().
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// The function #Z3_solver_get_model can also be used even
  /// if the result is \c Z3_L_UNDEF, but the returned model
  /// is not guaranteed to satisfy quantified assertions.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_simple_solver', SOLVER, (_in(CONTEXT),))
  Z3_solver Z3_mk_simple_solver(
    Z3_context c,
  ) {
    return _Z3_mk_simple_solver(
      c,
    );
  }

  late final _Z3_mk_simple_solverPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context)>>(
          'Z3_mk_simple_solver');
  late final _Z3_mk_simple_solver =
      _Z3_mk_simple_solverPtr.asFunction<Z3_solver Function(Z3_context)>();

  /// \brief Create a new solver customized for the given logic.
  /// It behaves like #Z3_mk_solver if the logic is unknown or unsupported.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_solver_for_logic', SOLVER, (_in(CONTEXT), _in(SYMBOL)))
  Z3_solver Z3_mk_solver_for_logic(
    Z3_context c,
    Z3_symbol logic,
  ) {
    return _Z3_mk_solver_for_logic(
      c,
      logic,
    );
  }

  late final _Z3_mk_solver_for_logicPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_solver_for_logic');
  late final _Z3_mk_solver_for_logic = _Z3_mk_solver_for_logicPtr.asFunction<
      Z3_solver Function(Z3_context, Z3_symbol)>();

  /// \brief Create a new solver that is implemented using the given tactic.
  /// The solver supports the commands #Z3_solver_push and #Z3_solver_pop, but it
  /// will always solve each #Z3_solver_check from scratch.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_solver_from_tactic', SOLVER, (_in(CONTEXT), _in(TACTIC)))
  Z3_solver Z3_mk_solver_from_tactic(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _Z3_mk_solver_from_tactic(
      c,
      t,
    );
  }

  late final _Z3_mk_solver_from_tacticPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context, Z3_tactic)>>(
          'Z3_mk_solver_from_tactic');
  late final _Z3_mk_solver_from_tactic = _Z3_mk_solver_from_tacticPtr
      .asFunction<Z3_solver Function(Z3_context, Z3_tactic)>();

  /// \brief Copy a solver \c s from the context \c source to the context \c target.
  ///
  /// def_API('Z3_solver_translate', SOLVER, (_in(CONTEXT), _in(SOLVER), _in(CONTEXT)))
  Z3_solver Z3_solver_translate(
    Z3_context source,
    Z3_solver s,
    Z3_context target,
  ) {
    return _Z3_solver_translate(
      source,
      s,
      target,
    );
  }

  late final _Z3_solver_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_solver Function(
              Z3_context, Z3_solver, Z3_context)>>('Z3_solver_translate');
  late final _Z3_solver_translate = _Z3_solver_translatePtr.asFunction<
      Z3_solver Function(Z3_context, Z3_solver, Z3_context)>();

  /// \brief Ad-hoc method for importing model conversion from solver.
  ///
  /// This method is used for scenarios where \c src has been used to solve a set
  /// of formulas and was interrupted. The \c dst solver may be a strengthening of \c src
  /// obtained from cubing (assigning a subset of literals or adding constraints over the
  /// assertions available in \c src). If \c dst ends up being satisfiable, the model for \c dst
  /// may not correspond to a model of the original formula due to inprocessing in \c src.
  /// This method is used to take the side-effect of inprocessing into account when returning
  /// a model for \c dst.
  ///
  /// def_API('Z3_solver_import_model_converter', VOID, (_in(CONTEXT), _in(SOLVER), _in(SOLVER)))
  void Z3_solver_import_model_converter(
    Z3_context ctx,
    Z3_solver src,
    Z3_solver dst,
  ) {
    return _Z3_solver_import_model_converter(
      ctx,
      src,
      dst,
    );
  }

  late final _Z3_solver_import_model_converterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              Z3_solver)>>('Z3_solver_import_model_converter');
  late final _Z3_solver_import_model_converter =
      _Z3_solver_import_model_converterPtr.asFunction<
          void Function(Z3_context, Z3_solver, Z3_solver)>();

  /// \brief Return a string describing all solver available parameters.
  ///
  /// \sa Z3_solver_get_param_descrs
  /// \sa Z3_solver_set_params
  ///
  /// def_API('Z3_solver_get_help', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string Z3_solver_get_help(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_help(
      c,
      s,
    );
  }

  late final _Z3_solver_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_help');
  late final _Z3_solver_get_help = _Z3_solver_get_helpPtr.asFunction<
      Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Return the parameter description set for the given solver object.
  ///
  /// \sa Z3_solver_get_help
  /// \sa Z3_solver_set_params
  ///
  /// def_API('Z3_solver_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(SOLVER)))
  Z3_param_descrs Z3_solver_get_param_descrs(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_param_descrs(
      c,
      s,
    );
  }

  late final _Z3_solver_get_param_descrsPtr = _lookup<
          ffi.NativeFunction<Z3_param_descrs Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_param_descrs');
  late final _Z3_solver_get_param_descrs = _Z3_solver_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_solver)>();

  /// \brief Set the given solver using the given parameters.
  ///
  /// \sa Z3_solver_get_help
  /// \sa Z3_solver_get_param_descrs
  ///
  /// def_API('Z3_solver_set_params', VOID, (_in(CONTEXT), _in(SOLVER), _in(PARAMS)))
  void Z3_solver_set_params(
    Z3_context c,
    Z3_solver s,
    Z3_params p,
  ) {
    return _Z3_solver_set_params(
      c,
      s,
      p,
    );
  }

  late final _Z3_solver_set_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_solver, Z3_params)>>('Z3_solver_set_params');
  late final _Z3_solver_set_params = _Z3_solver_set_paramsPtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_params)>();

  /// \brief Increment the reference counter of the given solver.
  ///
  /// def_API('Z3_solver_inc_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
  void Z3_solver_inc_ref(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_inc_ref(
      c,
      s,
    );
  }

  late final _Z3_solver_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_inc_ref');
  late final _Z3_solver_inc_ref =
      _Z3_solver_inc_refPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Decrement the reference counter of the given solver.
  ///
  /// def_API('Z3_solver_dec_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
  void Z3_solver_dec_ref(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_dec_ref(
      c,
      s,
    );
  }

  late final _Z3_solver_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_dec_ref');
  late final _Z3_solver_dec_ref =
      _Z3_solver_dec_refPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Solver local interrupt.
  /// Normally you should use Z3_interrupt to cancel solvers because only
  /// one solver is enabled concurrently per context.
  /// However, per GitHub issue #1006, there are use cases where
  /// it is more convenient to cancel a specific solver. Solvers
  /// that are not selected for interrupts are left alone.
  ///
  /// def_API('Z3_solver_interrupt', VOID, (_in(CONTEXT), _in(SOLVER)))
  void Z3_solver_interrupt(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_interrupt(
      c,
      s,
    );
  }

  late final _Z3_solver_interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_interrupt');
  late final _Z3_solver_interrupt = _Z3_solver_interruptPtr.asFunction<
      void Function(Z3_context, Z3_solver)>();

  /// \brief Create a backtracking point.
  ///
  /// The solver contains a stack of assertions.
  ///
  /// \sa Z3_solver_get_num_scopes
  /// \sa Z3_solver_pop
  ///
  /// def_API('Z3_solver_push', VOID, (_in(CONTEXT), _in(SOLVER)))
  void Z3_solver_push(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_push(
      c,
      s,
    );
  }

  late final _Z3_solver_pushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_push');
  late final _Z3_solver_push =
      _Z3_solver_pushPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Backtrack \c n backtracking points.
  ///
  /// \sa Z3_solver_get_num_scopes
  /// \sa Z3_solver_push
  ///
  /// \pre n <= Z3_solver_get_num_scopes(c, s)
  ///
  /// def_API('Z3_solver_pop', VOID, (_in(CONTEXT), _in(SOLVER), _in(UINT)))
  void Z3_solver_pop(
    Z3_context c,
    Z3_solver s,
    int n,
  ) {
    return _Z3_solver_pop(
      c,
      s,
      n,
    );
  }

  late final _Z3_solver_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_solver, ffi.UnsignedInt)>>('Z3_solver_pop');
  late final _Z3_solver_pop =
      _Z3_solver_popPtr.asFunction<void Function(Z3_context, Z3_solver, int)>();

  /// \brief Remove all assertions from the solver.
  ///
  /// \sa Z3_solver_assert
  /// \sa Z3_solver_assert_and_track
  ///
  /// def_API('Z3_solver_reset', VOID, (_in(CONTEXT), _in(SOLVER)))
  void Z3_solver_reset(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_reset(
      c,
      s,
    );
  }

  late final _Z3_solver_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_reset');
  late final _Z3_solver_reset =
      _Z3_solver_resetPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Return the number of backtracking points.
  ///
  /// \sa Z3_solver_push
  /// \sa Z3_solver_pop
  ///
  /// def_API('Z3_solver_get_num_scopes', UINT, (_in(CONTEXT), _in(SOLVER)))
  int Z3_solver_get_num_scopes(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_num_scopes(
      c,
      s,
    );
  }

  late final _Z3_solver_get_num_scopesPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_num_scopes');
  late final _Z3_solver_get_num_scopes = _Z3_solver_get_num_scopesPtr
      .asFunction<int Function(Z3_context, Z3_solver)>();

  /// \brief Assert a constraint into the solver.
  ///
  /// The functions #Z3_solver_check and #Z3_solver_check_assumptions should be
  /// used to check whether the logical context is consistent or not.
  ///
  /// \sa Z3_solver_assert_and_track
  /// \sa Z3_solver_reset
  ///
  /// def_API('Z3_solver_assert', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  void Z3_solver_assert(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
  ) {
    return _Z3_solver_assert(
      c,
      s,
      a,
    );
  }

  late final _Z3_solver_assertPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_assert');
  late final _Z3_solver_assert = _Z3_solver_assertPtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief Assert a constraint \c a into the solver, and track it (in the unsat) core using
  /// the Boolean constant \c p.
  ///
  /// This API is an alternative to #Z3_solver_check_assumptions for extracting unsat cores.
  /// Both APIs can be used in the same solver. The unsat core will contain a combination
  /// of the Boolean variables provided using Z3_solver_assert_and_track and the Boolean literals
  /// provided using #Z3_solver_check_assumptions.
  ///
  /// \pre \c a must be a Boolean expression
  /// \pre \c p must be a Boolean constant (aka variable).
  ///
  /// \sa Z3_solver_assert
  /// \sa Z3_solver_reset
  ///
  /// def_API('Z3_solver_assert_and_track', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST), _in(AST)))
  void Z3_solver_assert_and_track(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
    Z3_ast p,
  ) {
    return _Z3_solver_assert_and_track(
      c,
      s,
      a,
      p,
    );
  }

  late final _Z3_solver_assert_and_trackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver, Z3_ast,
              Z3_ast)>>('Z3_solver_assert_and_track');
  late final _Z3_solver_assert_and_track = _Z3_solver_assert_and_trackPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_ast, Z3_ast)>();

  /// \brief load solver assertions from a file.
  ///
  /// \sa Z3_solver_from_string
  /// \sa Z3_solver_to_string
  ///
  /// def_API('Z3_solver_from_file', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
  void Z3_solver_from_file(
    Z3_context c,
    Z3_solver s,
    Z3_string file_name,
  ) {
    return _Z3_solver_from_file(
      c,
      s,
      file_name,
    );
  }

  late final _Z3_solver_from_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_solver, Z3_string)>>('Z3_solver_from_file');
  late final _Z3_solver_from_file = _Z3_solver_from_filePtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_string)>();

  /// \brief load solver assertions from a string.
  ///
  /// \sa Z3_solver_from_file
  /// \sa Z3_solver_to_string
  ///
  /// def_API('Z3_solver_from_string', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
  void Z3_solver_from_string(
    Z3_context c,
    Z3_solver s,
    Z3_string file_name,
  ) {
    return _Z3_solver_from_string(
      c,
      s,
      file_name,
    );
  }

  late final _Z3_solver_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_solver, Z3_string)>>('Z3_solver_from_string');
  late final _Z3_solver_from_string = _Z3_solver_from_stringPtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_string)>();

  /// \brief Return the set of asserted formulas on the solver.
  ///
  /// def_API('Z3_solver_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector Z3_solver_get_assertions(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_assertions(
      c,
      s,
    );
  }

  late final _Z3_solver_get_assertionsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_assertions');
  late final _Z3_solver_get_assertions = _Z3_solver_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the set of units modulo model conversion.
  ///
  /// def_API('Z3_solver_get_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector Z3_solver_get_units(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_units(
      c,
      s,
    );
  }

  late final _Z3_solver_get_unitsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_units');
  late final _Z3_solver_get_units = _Z3_solver_get_unitsPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the trail modulo model conversion, in order of decision level
  /// The decision level can be retrieved using \c Z3_solver_get_level based on the trail.
  ///
  /// def_API('Z3_solver_get_trail', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector Z3_solver_get_trail(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_trail(
      c,
      s,
    );
  }

  late final _Z3_solver_get_trailPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_trail');
  late final _Z3_solver_get_trail = _Z3_solver_get_trailPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the set of non units in the solver state.
  ///
  /// def_API('Z3_solver_get_non_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector Z3_solver_get_non_units(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_non_units(
      c,
      s,
    );
  }

  late final _Z3_solver_get_non_unitsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_non_units');
  late final _Z3_solver_get_non_units = _Z3_solver_get_non_unitsPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief retrieve the decision depth of Boolean literals (variables or their negations).
  /// Assumes a check-sat call and no other calls (to extract models) have been invoked.
  ///
  /// def_API('Z3_solver_get_levels', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT), _in_array(3, UINT)))
  void Z3_solver_get_levels(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector literals,
    int sz,
    ffi.Pointer<ffi.UnsignedInt> levels,
  ) {
    return _Z3_solver_get_levels(
      c,
      s,
      literals,
      sz,
      levels,
    );
  }

  late final _Z3_solver_get_levelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_solver,
              Z3_ast_vector,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_solver_get_levels');
  late final _Z3_solver_get_levels = _Z3_solver_get_levelsPtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_ast_vector, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief register a user-properator with the solver.
  ///
  /// \param c - context.
  /// \param s - solver object.
  /// \param user_context - a context used to maintain state for callbacks.
  /// \param push_eh - a callback invoked when scopes are pushed
  /// \param pop_eh - a callback invoked when scopes are poped
  /// \param fresh_eh - a solver may spawn new solvers internally. This callback is used to produce a fresh user_context to be associated with fresh solvers.
  ///
  /// def_API('Z3_solver_propagate_init', VOID, (_in(CONTEXT), _in(SOLVER), _in(VOID_PTR), _fnptr(Z3_push_eh), _fnptr(Z3_pop_eh), _fnptr(Z3_fresh_eh)))
  void Z3_solver_propagate_init(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<ffi.Void> user_context,
    ffi.Pointer<Z3_push_eh> push_eh,
    ffi.Pointer<Z3_pop_eh> pop_eh,
    ffi.Pointer<Z3_fresh_eh> fresh_eh,
  ) {
    return _Z3_solver_propagate_init(
      c,
      s,
      user_context,
      push_eh,
      pop_eh,
      fresh_eh,
    );
  }

  late final _Z3_solver_propagate_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_solver,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_push_eh>,
              ffi.Pointer<Z3_pop_eh>,
              ffi.Pointer<Z3_fresh_eh>)>>('Z3_solver_propagate_init');
  late final _Z3_solver_propagate_init =
      _Z3_solver_propagate_initPtr.asFunction<
          void Function(
              Z3_context,
              Z3_solver,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_push_eh>,
              ffi.Pointer<Z3_pop_eh>,
              ffi.Pointer<Z3_fresh_eh>)>();

  /// \brief register a callback for when an expression is bound to a fixed value.
  /// The supported expression types are
  /// - Booleans
  /// - Bit-vectors
  ///
  /// def_API('Z3_solver_propagate_fixed', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_fixed_eh)))
  void Z3_solver_propagate_fixed(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_fixed_eh> fixed_eh,
  ) {
    return _Z3_solver_propagate_fixed(
      c,
      s,
      fixed_eh,
    );
  }

  late final _Z3_solver_propagate_fixedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_fixed_eh>)>>('Z3_solver_propagate_fixed');
  late final _Z3_solver_propagate_fixed =
      _Z3_solver_propagate_fixedPtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_fixed_eh>)>();

  /// \brief register a callback on final check.
  /// This provides freedom to the propagator to delay actions or implement a branch-and bound solver.
  /// The final check is invoked when all decision variables have been assigned by the solver.
  ///
  /// The \c final_eh callback takes as argument the original user_context that was used
  /// when calling \c Z3_solver_propagate_init, and it takes a callback context with the
  /// opaque type \c Z3_solver_callback.
  /// The callback context is passed as argument to invoke the \c Z3_solver_propagate_consequence function.
  /// The callback context can only be accessed (for propagation and for dynamically registering expressions) within a callback.
  /// If the callback context gets used for propagation or conflicts, those propagations take effect and
  /// may trigger new decision variables to be set.
  ///
  /// def_API('Z3_solver_propagate_final', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_final_eh)))
  void Z3_solver_propagate_final(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_final_eh> final_eh,
  ) {
    return _Z3_solver_propagate_final(
      c,
      s,
      final_eh,
    );
  }

  late final _Z3_solver_propagate_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_final_eh>)>>('Z3_solver_propagate_final');
  late final _Z3_solver_propagate_final =
      _Z3_solver_propagate_finalPtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_final_eh>)>();

  /// \brief register a callback on expression equalities.
  ///
  /// def_API('Z3_solver_propagate_eq', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_eq_eh)))
  void Z3_solver_propagate_eq(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_eq_eh> eq_eh,
  ) {
    return _Z3_solver_propagate_eq(
      c,
      s,
      eq_eh,
    );
  }

  late final _Z3_solver_propagate_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_eq_eh>)>>('Z3_solver_propagate_eq');
  late final _Z3_solver_propagate_eq = _Z3_solver_propagate_eqPtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_eq_eh>)>();

  /// \brief register a callback on expression dis-equalities.
  ///
  /// def_API('Z3_solver_propagate_diseq', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_eq_eh)))
  void Z3_solver_propagate_diseq(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_eq_eh> eq_eh,
  ) {
    return _Z3_solver_propagate_diseq(
      c,
      s,
      eq_eh,
    );
  }

  late final _Z3_solver_propagate_diseqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_eq_eh>)>>('Z3_solver_propagate_diseq');
  late final _Z3_solver_propagate_diseq =
      _Z3_solver_propagate_diseqPtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_eq_eh>)>();

  /// \brief register a callback when a new expression with a registered function is used by the solver
  /// The registered function appears at the top level and is created using \ref Z3_propagate_solver_declare.
  ///
  /// def_API('Z3_solver_propagate_created', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_created_eh)))
  void Z3_solver_propagate_created(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_created_eh> created_eh,
  ) {
    return _Z3_solver_propagate_created(
      c,
      s,
      created_eh,
    );
  }

  late final _Z3_solver_propagate_createdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_created_eh>)>>('Z3_solver_propagate_created');
  late final _Z3_solver_propagate_created =
      _Z3_solver_propagate_createdPtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_created_eh>)>();

  /// \brief register a callback when the solver decides to split on a registered expression.
  /// The callback may set the passed expression to another registered expression which will be selected instead.
  /// In case the expression is a bitvector the bit to split on is determined by the bit argument and the
  /// truth-value to try first is given by is_pos. In case the truth value is undefined the solver will decide.
  ///
  /// def_API('Z3_solver_propagate_decide', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_decide_eh)))
  void Z3_solver_propagate_decide(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_decide_eh> decide_eh,
  ) {
    return _Z3_solver_propagate_decide(
      c,
      s,
      decide_eh,
    );
  }

  late final _Z3_solver_propagate_decidePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_decide_eh>)>>('Z3_solver_propagate_decide');
  late final _Z3_solver_propagate_decide =
      _Z3_solver_propagate_decidePtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_decide_eh>)>();

  /// Sets the next expression to split on
  ///
  /// def_API('Z3_solver_next_split', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(AST), _in(UINT), _in(LBOOL)))
  void Z3_solver_next_split(
    Z3_context c,
    Z3_solver_callback cb,
    Z3_ast t,
    int idx,
    int phase,
  ) {
    return _Z3_solver_next_split(
      c,
      cb,
      t,
      idx,
      phase,
    );
  }

  late final _Z3_solver_next_splitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver_callback, Z3_ast,
              ffi.UnsignedInt, ffi.Int32)>>('Z3_solver_next_split');
  late final _Z3_solver_next_split = _Z3_solver_next_splitPtr.asFunction<
      void Function(Z3_context, Z3_solver_callback, Z3_ast, int, int)>();

  /// Create uninterpreted function declaration for the user propagator.
  /// When expressions using the function are created by the solver invoke a callback
  /// to \ref \Z3_solver_progate_created with arguments
  /// 1. context and callback solve
  /// 2. declared_expr: expression using function that was used as the top-level symbol
  /// 3. declared_id: a unique identifier (unique within the current scope) to track the expression.
  ///
  /// def_API('Z3_solver_propagate_declare', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl Z3_solver_propagate_declare(
    Z3_context c,
    Z3_symbol name,
    int n,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _Z3_solver_propagate_declare(
      c,
      name,
      n,
      domain,
      range,
    );
  }

  late final _Z3_solver_propagate_declarePtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_solver_propagate_declare');
  late final _Z3_solver_propagate_declare =
      _Z3_solver_propagate_declarePtr.asFunction<
          Z3_func_decl Function(
              Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief register an expression to propagate on with the solver.
  /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
  ///
  /// def_API('Z3_solver_propagate_register', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  void Z3_solver_propagate_register(
    Z3_context c,
    Z3_solver s,
    Z3_ast e,
  ) {
    return _Z3_solver_propagate_register(
      c,
      s,
      e,
    );
  }

  late final _Z3_solver_propagate_registerPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_propagate_register');
  late final _Z3_solver_propagate_register = _Z3_solver_propagate_registerPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief register an expression to propagate on with the solver.
  /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
  /// Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context
  /// as argument. It can be invoked during a callback to register new expressions.
  ///
  /// def_API('Z3_solver_propagate_register_cb', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(AST)))
  void Z3_solver_propagate_register_cb(
    Z3_context c,
    Z3_solver_callback cb,
    Z3_ast e,
  ) {
    return _Z3_solver_propagate_register_cb(
      c,
      cb,
      e,
    );
  }

  late final _Z3_solver_propagate_register_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver_callback,
              Z3_ast)>>('Z3_solver_propagate_register_cb');
  late final _Z3_solver_propagate_register_cb =
      _Z3_solver_propagate_register_cbPtr.asFunction<
          void Function(Z3_context, Z3_solver_callback, Z3_ast)>();

  /// \brief propagate a consequence based on fixed values.
  /// This is a callback a client may invoke during the fixed_eh callback.
  /// The callback adds a propagation consequence based on the fixed values of the
  /// \c ids.
  ///
  /// def_API('Z3_solver_propagate_consequence', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(UINT), _in_array(2, AST), _in(UINT), _in_array(4, AST), _in_array(4, AST), _in(AST)))
  void Z3_solver_propagate_consequence(
    Z3_context c,
    Z3_solver_callback arg1,
    int num_fixed,
    ffi.Pointer<Z3_ast> fixed,
    int num_eqs,
    ffi.Pointer<Z3_ast> eq_lhs,
    ffi.Pointer<Z3_ast> eq_rhs,
    Z3_ast conseq,
  ) {
    return _Z3_solver_propagate_consequence(
      c,
      arg1,
      num_fixed,
      fixed,
      num_eqs,
      eq_lhs,
      eq_rhs,
      conseq,
    );
  }

  late final _Z3_solver_propagate_consequencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_solver_callback,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_solver_propagate_consequence');
  late final _Z3_solver_propagate_consequence =
      _Z3_solver_propagate_consequencePtr.asFunction<
          void Function(
              Z3_context,
              Z3_solver_callback,
              int,
              ffi.Pointer<Z3_ast>,
              int,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>();

  /// \brief Check whether the assertions in a given solver are consistent or not.
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// Note that if the call returns \c Z3_L_UNDEF, Z3 does not
  /// ensure that calls to #Z3_solver_get_model succeed and any models
  /// produced in this case are not guaranteed to satisfy the assertions.
  ///
  /// The function #Z3_solver_get_proof retrieves a proof if proof
  /// generation was enabled when the context was created, and the
  /// assertions are unsatisfiable (i.e., the result is \c Z3_L_FALSE).
  ///
  /// \sa Z3_solver_check_assumptions
  ///
  /// def_API('Z3_solver_check', LBOOL, (_in(CONTEXT), _in(SOLVER)))
  int Z3_solver_check(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_check(
      c,
      s,
    );
  }

  late final _Z3_solver_checkPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_solver)>>(
          'Z3_solver_check');
  late final _Z3_solver_check =
      _Z3_solver_checkPtr.asFunction<int Function(Z3_context, Z3_solver)>();

  /// \brief Check whether the assertions in the given solver and
  /// optional assumptions are consistent or not.
  ///
  /// The function #Z3_solver_get_unsat_core retrieves the subset of the
  /// assumptions used in the unsatisfiability proof produced by Z3.
  ///
  /// \sa Z3_solver_check
  ///
  /// def_API('Z3_solver_check_assumptions', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST)))
  int Z3_solver_check_assumptions(
    Z3_context c,
    Z3_solver s,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
  ) {
    return _Z3_solver_check_assumptions(
      c,
      s,
      num_assumptions,
      assumptions,
    );
  }

  late final _Z3_solver_check_assumptionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_solver, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_solver_check_assumptions');
  late final _Z3_solver_check_assumptions =
      _Z3_solver_check_assumptionsPtr.asFunction<
          int Function(Z3_context, Z3_solver, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Retrieve congruence class representatives for terms.
  ///
  /// The function can be used for relying on Z3 to identify equal terms under the current
  /// set of assumptions. The array of terms and array of class identifiers should have
  /// the same length. The class identifiers are numerals that are assigned to the same
  /// value for their corresponding terms if the current context forces the terms to be
  /// equal. You cannot deduce that terms corresponding to different numerals must be all different,
  /// (especially when using non-convex theories).
  /// All implied equalities are returned by this call.
  /// This means that two terms map to the same class identifier if and only if
  /// the current context implies that they are equal.
  ///
  /// A side-effect of the function is a satisfiability check on the assertions on the solver that is passed in.
  /// The function return \c Z3_L_FALSE if the current assertions are not satisfiable.
  ///
  /// def_API('Z3_get_implied_equalities', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST), _out_array(2, UINT)))
  int Z3_get_implied_equalities(
    Z3_context c,
    Z3_solver s,
    int num_terms,
    ffi.Pointer<Z3_ast> terms,
    ffi.Pointer<ffi.UnsignedInt> class_ids,
  ) {
    return _Z3_get_implied_equalities(
      c,
      s,
      num_terms,
      terms,
      class_ids,
    );
  }

  late final _Z3_get_implied_equalitiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Z3_context,
              Z3_solver,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_implied_equalities');
  late final _Z3_get_implied_equalities =
      _Z3_get_implied_equalitiesPtr.asFunction<
          int Function(Z3_context, Z3_solver, int, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief retrieve consequences from solver that determine values of the supplied function symbols.
  ///
  /// def_API('Z3_solver_get_consequences', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(AST_VECTOR), _in(AST_VECTOR)))
  int Z3_solver_get_consequences(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector assumptions,
    Z3_ast_vector variables,
    Z3_ast_vector consequences,
  ) {
    return _Z3_solver_get_consequences(
      c,
      s,
      assumptions,
      variables,
      consequences,
    );
  }

  late final _Z3_solver_get_consequencesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_solver, Z3_ast_vector,
              Z3_ast_vector, Z3_ast_vector)>>('Z3_solver_get_consequences');
  late final _Z3_solver_get_consequences =
      _Z3_solver_get_consequencesPtr.asFunction<
          int Function(Z3_context, Z3_solver, Z3_ast_vector, Z3_ast_vector,
              Z3_ast_vector)>();

  /// \brief extract a next cube for a solver. The last cube is the constant \c true or \c false.
  /// The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled
  /// using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
  ///
  /// The third argument is a vector of variables that may be used for cubing.
  /// The contents of the vector is only used in the first call. The initial list of variables
  /// is used in subsequent calls until it returns the unsatisfiable cube.
  /// The vector is modified to contain a set of Autarky variables that occur in clauses that
  /// are affected by the (last literal in the) cube. These variables could be used by a different
  /// cuber (on a different solver object) for further recursive cubing.
  ///
  /// The last argument is a backtracking level. It instructs the cube process to backtrack below
  /// the indicated level for the next cube.
  ///
  /// def_API('Z3_solver_cube', AST_VECTOR, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT)))
  Z3_ast_vector Z3_solver_cube(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector vars,
    int backtrack_level,
  ) {
    return _Z3_solver_cube(
      c,
      s,
      vars,
      backtrack_level,
    );
  }

  late final _Z3_solver_cubePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_solver, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_solver_cube');
  late final _Z3_solver_cube = _Z3_solver_cubePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_solver, Z3_ast_vector, int)>();

  /// \brief Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions
  ///
  /// The error handler is invoked if a model is not available because
  /// the commands above were not invoked for the given solver, or if the result was \c Z3_L_FALSE.
  ///
  /// def_API('Z3_solver_get_model', MODEL, (_in(CONTEXT), _in(SOLVER)))
  Z3_model Z3_solver_get_model(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_model(
      c,
      s,
    );
  }

  late final _Z3_solver_get_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_model');
  late final _Z3_solver_get_model = _Z3_solver_get_modelPtr.asFunction<
      Z3_model Function(Z3_context, Z3_solver)>();

  /// \brief Retrieve the proof for the last #Z3_solver_check or #Z3_solver_check_assumptions
  ///
  /// The error handler is invoked if proof generation is not enabled,
  /// or if the commands above were not invoked for the given solver,
  /// or if the result was different from \c Z3_L_FALSE.
  ///
  /// def_API('Z3_solver_get_proof', AST, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast Z3_solver_get_proof(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_proof(
      c,
      s,
    );
  }

  late final _Z3_solver_get_proofPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_proof');
  late final _Z3_solver_get_proof = _Z3_solver_get_proofPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_solver)>();

  /// \brief Retrieve the unsat core for the last #Z3_solver_check_assumptions
  /// The unsat core is a subset of the assumptions \c a.
  ///
  /// By default, the unsat core will not be minimized. Generation of a minimized
  /// unsat core can be enabled via the `"sat.core.minimize"` and `"smt.core.minimize"`
  /// settings for SAT and SMT cores respectively. Generation of minimized unsat cores
  /// will be more expensive.
  ///
  /// def_API('Z3_solver_get_unsat_core', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector Z3_solver_get_unsat_core(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_unsat_core(
      c,
      s,
    );
  }

  late final _Z3_solver_get_unsat_corePtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_unsat_core');
  late final _Z3_solver_get_unsat_core = _Z3_solver_get_unsat_corePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return a brief justification for an "unknown" result (i.e., \c Z3_L_UNDEF) for
  /// the commands #Z3_solver_check and #Z3_solver_check_assumptions
  ///
  /// def_API('Z3_solver_get_reason_unknown', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string Z3_solver_get_reason_unknown(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_reason_unknown(
      c,
      s,
    );
  }

  late final _Z3_solver_get_reason_unknownPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_reason_unknown');
  late final _Z3_solver_get_reason_unknown = _Z3_solver_get_reason_unknownPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Return statistics for the given solver.
  ///
  /// \remark User must use #Z3_stats_inc_ref and #Z3_stats_dec_ref to manage Z3_stats objects.
  ///
  /// def_API('Z3_solver_get_statistics', STATS, (_in(CONTEXT), _in(SOLVER)))
  Z3_stats Z3_solver_get_statistics(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_get_statistics(
      c,
      s,
    );
  }

  late final _Z3_solver_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_statistics');
  late final _Z3_solver_get_statistics = _Z3_solver_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_solver)>();

  /// \brief Convert a solver into a string.
  ///
  /// \sa Z3_solver_from_file
  /// \sa Z3_solver_from_string
  ///
  /// def_API('Z3_solver_to_string', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string Z3_solver_to_string(
    Z3_context c,
    Z3_solver s,
  ) {
    return _Z3_solver_to_string(
      c,
      s,
    );
  }

  late final _Z3_solver_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_to_string');
  late final _Z3_solver_to_string = _Z3_solver_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Convert a solver into a DIMACS formatted string.
  /// \sa Z3_goal_to_diamcs_string for requirements.
  ///
  /// def_API('Z3_solver_to_dimacs_string', STRING, (_in(CONTEXT), _in(SOLVER), _in(BOOL)))
  Z3_string Z3_solver_to_dimacs_string(
    Z3_context c,
    Z3_solver s,
    int include_names,
  ) {
    return _Z3_solver_to_dimacs_string(
      c,
      s,
      include_names,
    );
  }

  late final _Z3_solver_to_dimacs_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(
              Z3_context, Z3_solver, ffi.Int)>>('Z3_solver_to_dimacs_string');
  late final _Z3_solver_to_dimacs_string = _Z3_solver_to_dimacs_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver, int)>();

  /// \brief Convert a statistics into a string.
  ///
  /// def_API('Z3_stats_to_string', STRING, (_in(CONTEXT), _in(STATS)))
  Z3_string Z3_stats_to_string(
    Z3_context c,
    Z3_stats s,
  ) {
    return _Z3_stats_to_string(
      c,
      s,
    );
  }

  late final _Z3_stats_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_stats)>>(
          'Z3_stats_to_string');
  late final _Z3_stats_to_string = _Z3_stats_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_stats)>();

  /// \brief Increment the reference counter of the given statistics object.
  ///
  /// def_API('Z3_stats_inc_ref', VOID, (_in(CONTEXT), _in(STATS)))
  void Z3_stats_inc_ref(
    Z3_context c,
    Z3_stats s,
  ) {
    return _Z3_stats_inc_ref(
      c,
      s,
    );
  }

  late final _Z3_stats_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_stats)>>(
          'Z3_stats_inc_ref');
  late final _Z3_stats_inc_ref =
      _Z3_stats_inc_refPtr.asFunction<void Function(Z3_context, Z3_stats)>();

  /// \brief Decrement the reference counter of the given statistics object.
  ///
  /// def_API('Z3_stats_dec_ref', VOID, (_in(CONTEXT), _in(STATS)))
  void Z3_stats_dec_ref(
    Z3_context c,
    Z3_stats s,
  ) {
    return _Z3_stats_dec_ref(
      c,
      s,
    );
  }

  late final _Z3_stats_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_stats)>>(
          'Z3_stats_dec_ref');
  late final _Z3_stats_dec_ref =
      _Z3_stats_dec_refPtr.asFunction<void Function(Z3_context, Z3_stats)>();

  /// \brief Return the number of statistical data in \c s.
  ///
  /// def_API('Z3_stats_size', UINT, (_in(CONTEXT), _in(STATS)))
  int Z3_stats_size(
    Z3_context c,
    Z3_stats s,
  ) {
    return _Z3_stats_size(
      c,
      s,
    );
  }

  late final _Z3_stats_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_stats)>>(
      'Z3_stats_size');
  late final _Z3_stats_size =
      _Z3_stats_sizePtr.asFunction<int Function(Z3_context, Z3_stats)>();

  /// \brief Return the key (a string) for a particular statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_get_key', STRING, (_in(CONTEXT), _in(STATS), _in(UINT)))
  Z3_string Z3_stats_get_key(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _Z3_stats_get_key(
      c,
      s,
      idx,
    );
  }

  late final _Z3_stats_get_keyPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_get_key');
  late final _Z3_stats_get_key = _Z3_stats_get_keyPtr.asFunction<
      Z3_string Function(Z3_context, Z3_stats, int)>();

  /// \brief Return \c true if the given statistical data is a unsigned integer.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_is_uint', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
  int Z3_stats_is_uint(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _Z3_stats_is_uint(
      c,
      s,
      idx,
    );
  }

  late final _Z3_stats_is_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_is_uint');
  late final _Z3_stats_is_uint = _Z3_stats_is_uintPtr.asFunction<
      int Function(Z3_context, Z3_stats, int)>();

  /// \brief Return \c true if the given statistical data is a double.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_is_double', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
  int Z3_stats_is_double(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _Z3_stats_is_double(
      c,
      s,
      idx,
    );
  }

  late final _Z3_stats_is_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_is_double');
  late final _Z3_stats_is_double = _Z3_stats_is_doublePtr.asFunction<
      int Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the unsigned value of the given statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s) && Z3_stats_is_uint(c, s)
  ///
  /// def_API('Z3_stats_get_uint_value', UINT, (_in(CONTEXT), _in(STATS), _in(UINT)))
  int Z3_stats_get_uint_value(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _Z3_stats_get_uint_value(
      c,
      s,
      idx,
    );
  }

  late final _Z3_stats_get_uint_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_stats,
              ffi.UnsignedInt)>>('Z3_stats_get_uint_value');
  late final _Z3_stats_get_uint_value = _Z3_stats_get_uint_valuePtr.asFunction<
      int Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the double value of the given statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s) && Z3_stats_is_double(c, s)
  ///
  /// def_API('Z3_stats_get_double_value', DOUBLE, (_in(CONTEXT), _in(STATS), _in(UINT)))
  double Z3_stats_get_double_value(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _Z3_stats_get_double_value(
      c,
      s,
      idx,
    );
  }

  late final _Z3_stats_get_double_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(Z3_context, Z3_stats,
              ffi.UnsignedInt)>>('Z3_stats_get_double_value');
  late final _Z3_stats_get_double_value = _Z3_stats_get_double_valuePtr
      .asFunction<double Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the estimated allocated memory in bytes.
  ///
  /// def_API('Z3_get_estimated_alloc_size', UINT64, ())
  int Z3_get_estimated_alloc_size() {
    return _Z3_get_estimated_alloc_size();
  }

  late final _Z3_get_estimated_alloc_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>(
          'Z3_get_estimated_alloc_size');
  late final _Z3_get_estimated_alloc_size =
      _Z3_get_estimated_alloc_sizePtr.asFunction<int Function()>();

  /// @name AST vectors */
  /// /**@{*/
  /// /**
  /// \brief Return an empty AST vector.
  ///
  /// \remark Reference counting must be used to manage AST vectors, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_ast_vector', AST_VECTOR, (_in(CONTEXT),))
  Z3_ast_vector Z3_mk_ast_vector(
    Z3_context c,
  ) {
    return _Z3_mk_ast_vector(
      c,
    );
  }

  late final _Z3_mk_ast_vectorPtr =
      _lookup<ffi.NativeFunction<Z3_ast_vector Function(Z3_context)>>(
          'Z3_mk_ast_vector');
  late final _Z3_mk_ast_vector =
      _Z3_mk_ast_vectorPtr.asFunction<Z3_ast_vector Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_inc_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
  void Z3_ast_vector_inc_ref(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _Z3_ast_vector_inc_ref(
      c,
      v,
    );
  }

  late final _Z3_ast_vector_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_vector)>>(
          'Z3_ast_vector_inc_ref');
  late final _Z3_ast_vector_inc_ref = _Z3_ast_vector_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_ast_vector)>();

  /// \brief Decrement the reference counter of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_dec_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
  void Z3_ast_vector_dec_ref(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _Z3_ast_vector_dec_ref(
      c,
      v,
    );
  }

  late final _Z3_ast_vector_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_vector)>>(
          'Z3_ast_vector_dec_ref');
  late final _Z3_ast_vector_dec_ref = _Z3_ast_vector_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_ast_vector)>();

  /// \brief Return the size of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_size', UINT, (_in(CONTEXT), _in(AST_VECTOR)))
  int Z3_ast_vector_size(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _Z3_ast_vector_size(
      c,
      v,
    );
  }

  late final _Z3_ast_vector_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_ast_vector)>>('Z3_ast_vector_size');
  late final _Z3_ast_vector_size = _Z3_ast_vector_sizePtr.asFunction<
      int Function(Z3_context, Z3_ast_vector)>();

  /// \brief Return the AST at position \c i in the AST vector \c v.
  ///
  /// \pre i < Z3_ast_vector_size(c, v)
  ///
  /// def_API('Z3_ast_vector_get', AST, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
  Z3_ast Z3_ast_vector_get(
    Z3_context c,
    Z3_ast_vector v,
    int i,
  ) {
    return _Z3_ast_vector_get(
      c,
      v,
      i,
    );
  }

  late final _Z3_ast_vector_getPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_ast_vector_get');
  late final _Z3_ast_vector_get = _Z3_ast_vector_getPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast_vector, int)>();

  /// \brief Update position \c i of the AST vector \c v with the AST \c a.
  ///
  /// \pre i < Z3_ast_vector_size(c, v)
  ///
  /// def_API('Z3_ast_vector_set', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT), _in(AST)))
  void Z3_ast_vector_set(
    Z3_context c,
    Z3_ast_vector v,
    int i,
    Z3_ast a,
  ) {
    return _Z3_ast_vector_set(
      c,
      v,
      i,
      a,
    );
  }

  late final _Z3_ast_vector_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast_vector, ffi.UnsignedInt,
              Z3_ast)>>('Z3_ast_vector_set');
  late final _Z3_ast_vector_set = _Z3_ast_vector_setPtr.asFunction<
      void Function(Z3_context, Z3_ast_vector, int, Z3_ast)>();

  /// \brief Resize the AST vector \c v.
  ///
  /// def_API('Z3_ast_vector_resize', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
  void Z3_ast_vector_resize(
    Z3_context c,
    Z3_ast_vector v,
    int n,
  ) {
    return _Z3_ast_vector_resize(
      c,
      v,
      n,
    );
  }

  late final _Z3_ast_vector_resizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_ast_vector_resize');
  late final _Z3_ast_vector_resize = _Z3_ast_vector_resizePtr.asFunction<
      void Function(Z3_context, Z3_ast_vector, int)>();

  /// \brief Add the AST \c a in the end of the AST vector \c v. The size of \c v is increased by one.
  ///
  /// def_API('Z3_ast_vector_push', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(AST)))
  void Z3_ast_vector_push(
    Z3_context c,
    Z3_ast_vector v,
    Z3_ast a,
  ) {
    return _Z3_ast_vector_push(
      c,
      v,
      a,
    );
  }

  late final _Z3_ast_vector_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_ast_vector, Z3_ast)>>('Z3_ast_vector_push');
  late final _Z3_ast_vector_push = _Z3_ast_vector_pushPtr.asFunction<
      void Function(Z3_context, Z3_ast_vector, Z3_ast)>();

  /// \brief Translate the AST vector \c v from context \c s into an AST vector in context \c t.
  ///
  /// def_API('Z3_ast_vector_translate', AST_VECTOR, (_in(CONTEXT), _in(AST_VECTOR), _in(CONTEXT)))
  Z3_ast_vector Z3_ast_vector_translate(
    Z3_context s,
    Z3_ast_vector v,
    Z3_context t,
  ) {
    return _Z3_ast_vector_translate(
      s,
      v,
      t,
    );
  }

  late final _Z3_ast_vector_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast_vector,
              Z3_context)>>('Z3_ast_vector_translate');
  late final _Z3_ast_vector_translate = _Z3_ast_vector_translatePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast_vector, Z3_context)>();

  /// \brief Convert AST vector into a string.
  ///
  /// def_API('Z3_ast_vector_to_string', STRING, (_in(CONTEXT), _in(AST_VECTOR)))
  Z3_string Z3_ast_vector_to_string(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _Z3_ast_vector_to_string(
      c,
      v,
    );
  }

  late final _Z3_ast_vector_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast_vector)>>(
      'Z3_ast_vector_to_string');
  late final _Z3_ast_vector_to_string = _Z3_ast_vector_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_ast_vector)>();

  /// @name AST maps */
  /// /**@{*/
  /// /**
  /// \brief Return an empty mapping from AST to AST
  ///
  /// \remark Reference counting must be used to manage AST maps, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_ast_map', AST_MAP, (_in(CONTEXT),) )
  Z3_ast_map Z3_mk_ast_map(
    Z3_context c,
  ) {
    return _Z3_mk_ast_map(
      c,
    );
  }

  late final _Z3_mk_ast_mapPtr =
      _lookup<ffi.NativeFunction<Z3_ast_map Function(Z3_context)>>(
          'Z3_mk_ast_map');
  late final _Z3_mk_ast_map =
      _Z3_mk_ast_mapPtr.asFunction<Z3_ast_map Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST map.
  ///
  /// def_API('Z3_ast_map_inc_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void Z3_ast_map_inc_ref(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_inc_ref(
      c,
      m,
    );
  }

  late final _Z3_ast_map_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_inc_ref');
  late final _Z3_ast_map_inc_ref = _Z3_ast_map_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_ast_map)>();

  /// \brief Decrement the reference counter of the given AST map.
  ///
  /// def_API('Z3_ast_map_dec_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void Z3_ast_map_dec_ref(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_dec_ref(
      c,
      m,
    );
  }

  late final _Z3_ast_map_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_dec_ref');
  late final _Z3_ast_map_dec_ref = _Z3_ast_map_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_ast_map)>();

  /// \brief Return true if the map \c m contains the AST key \c k.
  ///
  /// def_API('Z3_ast_map_contains', BOOL, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  int Z3_ast_map_contains(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _Z3_ast_map_contains(
      c,
      m,
      k,
    );
  }

  late final _Z3_ast_map_containsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast_map, Z3_ast)>>(
      'Z3_ast_map_contains');
  late final _Z3_ast_map_contains = _Z3_ast_map_containsPtr.asFunction<
      int Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Return the value associated with the key \c k.
  ///
  /// The procedure invokes the error handler if \c k is not in the map.
  ///
  /// def_API('Z3_ast_map_find', AST, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  Z3_ast Z3_ast_map_find(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _Z3_ast_map_find(
      c,
      m,
      k,
    );
  }

  late final _Z3_ast_map_findPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast_map, Z3_ast)>>(
      'Z3_ast_map_find');
  late final _Z3_ast_map_find = _Z3_ast_map_findPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Store/Replace a new key, value pair in the given map.
  ///
  /// def_API('Z3_ast_map_insert', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST), _in(AST)))
  void Z3_ast_map_insert(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
    Z3_ast v,
  ) {
    return _Z3_ast_map_insert(
      c,
      m,
      k,
      v,
    );
  }

  late final _Z3_ast_map_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_ast_map, Z3_ast, Z3_ast)>>('Z3_ast_map_insert');
  late final _Z3_ast_map_insert = _Z3_ast_map_insertPtr.asFunction<
      void Function(Z3_context, Z3_ast_map, Z3_ast, Z3_ast)>();

  /// \brief Erase a key from the map.
  ///
  /// def_API('Z3_ast_map_erase', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  void Z3_ast_map_erase(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _Z3_ast_map_erase(
      c,
      m,
      k,
    );
  }

  late final _Z3_ast_map_erasePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_ast_map, Z3_ast)>>('Z3_ast_map_erase');
  late final _Z3_ast_map_erase = _Z3_ast_map_erasePtr.asFunction<
      void Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Remove all keys from the given map.
  ///
  /// def_API('Z3_ast_map_reset', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void Z3_ast_map_reset(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_reset(
      c,
      m,
    );
  }

  late final _Z3_ast_map_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_reset');
  late final _Z3_ast_map_reset =
      _Z3_ast_map_resetPtr.asFunction<void Function(Z3_context, Z3_ast_map)>();

  /// \brief Return the size of the given map.
  ///
  /// def_API('Z3_ast_map_size', UINT, (_in(CONTEXT), _in(AST_MAP)))
  int Z3_ast_map_size(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_size(
      c,
      m,
    );
  }

  late final _Z3_ast_map_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast_map)>>(
      'Z3_ast_map_size');
  late final _Z3_ast_map_size =
      _Z3_ast_map_sizePtr.asFunction<int Function(Z3_context, Z3_ast_map)>();

  /// \brief Return the keys stored in the given map.
  ///
  /// def_API('Z3_ast_map_keys', AST_VECTOR, (_in(CONTEXT), _in(AST_MAP)))
  Z3_ast_vector Z3_ast_map_keys(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_keys(
      c,
      m,
    );
  }

  late final _Z3_ast_map_keysPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_ast_map)>>(
      'Z3_ast_map_keys');
  late final _Z3_ast_map_keys = _Z3_ast_map_keysPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast_map)>();

  /// \brief Convert the given map into a string.
  ///
  /// def_API('Z3_ast_map_to_string', STRING, (_in(CONTEXT), _in(AST_MAP)))
  Z3_string Z3_ast_map_to_string(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _Z3_ast_map_to_string(
      c,
      m,
    );
  }

  late final _Z3_ast_map_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_to_string');
  late final _Z3_ast_map_to_string = _Z3_ast_map_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_ast_map)>();

  /// @name Algebraic Numbers */
  /// /**@{*/
  /// /**
  /// \brief Return \c true if \c a can be used as value in the Z3 real algebraic
  /// number package.
  ///
  /// def_API('Z3_algebraic_is_value', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_is_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_is_value(
      c,
      a,
    );
  }

  late final _Z3_algebraic_is_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_value');
  late final _Z3_algebraic_is_value =
      _Z3_algebraic_is_valuePtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is positive, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_pos', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_is_pos(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_is_pos(
      c,
      a,
    );
  }

  late final _Z3_algebraic_is_posPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_pos');
  late final _Z3_algebraic_is_pos =
      _Z3_algebraic_is_posPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is negative, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_neg', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_is_neg(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_is_neg(
      c,
      a,
    );
  }

  late final _Z3_algebraic_is_negPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_neg');
  late final _Z3_algebraic_is_neg =
      _Z3_algebraic_is_negPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is zero, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_zero', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_is_zero(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_is_zero(
      c,
      a,
    );
  }

  late final _Z3_algebraic_is_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_zero');
  late final _Z3_algebraic_is_zero =
      _Z3_algebraic_is_zeroPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return 1 if \c a is positive, 0 if \c a is zero, and -1 if \c a is negative.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_sign', INT, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_sign(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_sign(
      c,
      a,
    );
  }

  late final _Z3_algebraic_signPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_sign');
  late final _Z3_algebraic_sign =
      _Z3_algebraic_signPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the value a + b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_algebraic_add(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_add(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_addPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_add');
  late final _Z3_algebraic_add = _Z3_algebraic_addPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a - b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_sub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_algebraic_sub(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_sub(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_subPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_sub');
  late final _Z3_algebraic_sub = _Z3_algebraic_subPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a * b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_mul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_algebraic_mul(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_mul(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_mulPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_mul');
  late final _Z3_algebraic_mul = _Z3_algebraic_mulPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a / b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \pre !Z3_algebraic_is_zero(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast Z3_algebraic_div(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_div(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_divPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_div');
  late final _Z3_algebraic_div = _Z3_algebraic_divPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the a^(1/k)
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre k is even => !Z3_algebraic_is_neg(c, a)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_root', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_algebraic_root(
    Z3_context c,
    Z3_ast a,
    int k,
  ) {
    return _Z3_algebraic_root(
      c,
      a,
      k,
    );
  }

  late final _Z3_algebraic_rootPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_algebraic_root');
  late final _Z3_algebraic_root = _Z3_algebraic_rootPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return the a^k
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast Z3_algebraic_power(
    Z3_context c,
    Z3_ast a,
    int k,
  ) {
    return _Z3_algebraic_power(
      c,
      a,
      k,
    );
  }

  late final _Z3_algebraic_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_algebraic_power');
  late final _Z3_algebraic_power = _Z3_algebraic_powerPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return \c true if a < b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_lt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_lt(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_lt(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_ltPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_lt');
  late final _Z3_algebraic_lt = _Z3_algebraic_ltPtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a > b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_gt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_gt(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_gt(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_gtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_gt');
  late final _Z3_algebraic_gt = _Z3_algebraic_gtPtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a <= b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_le', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_le(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_le(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_lePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_le');
  late final _Z3_algebraic_le = _Z3_algebraic_lePtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a >= b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_ge', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_ge(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_ge(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_gePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_ge');
  late final _Z3_algebraic_ge = _Z3_algebraic_gePtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a == b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_eq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_eq(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_eq(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_eqPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_eq');
  late final _Z3_algebraic_eq = _Z3_algebraic_eqPtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a != b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_neq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  int Z3_algebraic_neq(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _Z3_algebraic_neq(
      c,
      a,
      b,
    );
  }

  late final _Z3_algebraic_neqPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_neq');
  late final _Z3_algebraic_neq = _Z3_algebraic_neqPtr.asFunction<
      int Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}, x_n), returns the
  /// roots of the univariate polynomial p(a[0], ..., a[n-1], x_n).
  ///
  /// \pre p is a Z3 expression that contains only arithmetic terms and free variables.
  /// \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])
  /// \post forall r in result Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_roots', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast_vector Z3_algebraic_roots(
    Z3_context c,
    Z3_ast p,
    int n,
    ffi.Pointer<Z3_ast> a,
  ) {
    return _Z3_algebraic_roots(
      c,
      p,
      n,
      a,
    );
  }

  late final _Z3_algebraic_rootsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_algebraic_roots');
  late final _Z3_algebraic_roots = _Z3_algebraic_rootsPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}), return the
  /// sign of p(a[0], ..., a[n-1]).
  ///
  /// \pre p is a Z3 expression that contains only arithmetic terms and free variables.
  /// \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])
  ///
  /// def_API('Z3_algebraic_eval', INT, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  int Z3_algebraic_eval(
    Z3_context c,
    Z3_ast p,
    int n,
    ffi.Pointer<Z3_ast> a,
  ) {
    return _Z3_algebraic_eval(
      c,
      p,
      n,
      a,
    );
  }

  late final _Z3_algebraic_evalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_algebraic_eval');
  late final _Z3_algebraic_eval = _Z3_algebraic_evalPtr.asFunction<
      int Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Return the coefficients of the defining polynomial.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_get_poly', AST_VECTOR, (_in(CONTEXT), _in(AST)))
  Z3_ast_vector Z3_algebraic_get_poly(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_get_poly(
      c,
      a,
    );
  }

  late final _Z3_algebraic_get_polyPtr =
      _lookup<ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_get_poly');
  late final _Z3_algebraic_get_poly = _Z3_algebraic_get_polyPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast)>();

  /// \brief Return which root of the polynomial the algebraic number represents.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_get_i', UINT, (_in(CONTEXT), _in(AST)))
  int Z3_algebraic_get_i(
    Z3_context c,
    Z3_ast a,
  ) {
    return _Z3_algebraic_get_i(
      c,
      a,
    );
  }

  late final _Z3_algebraic_get_iPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_get_i');
  late final _Z3_algebraic_get_i =
      _Z3_algebraic_get_iPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the nonzero subresultants of \c p and \c q with respect to the "variable" \c x.
  ///
  /// \pre \c p, \c q and \c x are Z3 expressions where \c p and \c q are arithmetic terms.
  /// Note that, any subterm that cannot be viewed as a polynomial is assumed to be a variable.
  /// Example: \ccode{f(a)} is a considered to be a variable in the polynomial \ccode{
  /// f(a)*f(a) + 2*f(a) + 1}
  ///
  /// def_API('Z3_polynomial_subresultants', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast_vector Z3_polynomial_subresultants(
    Z3_context c,
    Z3_ast p,
    Z3_ast q,
    Z3_ast x,
  ) {
    return _Z3_polynomial_subresultants(
      c,
      p,
      q,
      x,
    );
  }

  late final _Z3_polynomial_subresultantsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast, Z3_ast,
              Z3_ast)>>('Z3_polynomial_subresultants');
  late final _Z3_polynomial_subresultants = _Z3_polynomial_subresultantsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// @name Real Closed Fields */
  /// /**@{*/
  /// /**
  /// \brief Delete a RCF numeral created using the RCF API.
  ///
  /// def_API('Z3_rcf_del', VOID, (_in(CONTEXT), _in(RCF_NUM)))
  void Z3_rcf_del(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _Z3_rcf_del(
      c,
      a,
    );
  }

  late final _Z3_rcf_delPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_del');
  late final _Z3_rcf_del =
      _Z3_rcf_delPtr.asFunction<void Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return a RCF rational using the given string.
  ///
  /// def_API('Z3_rcf_mk_rational', RCF_NUM, (_in(CONTEXT), _in(STRING)))
  Z3_rcf_num Z3_rcf_mk_rational(
    Z3_context c,
    Z3_string val,
  ) {
    return _Z3_rcf_mk_rational(
      c,
      val,
    );
  }

  late final _Z3_rcf_mk_rationalPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_string)>>(
          'Z3_rcf_mk_rational');
  late final _Z3_rcf_mk_rational = _Z3_rcf_mk_rationalPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_string)>();

  /// \brief Return a RCF small integer.
  ///
  /// def_API('Z3_rcf_mk_small_int', RCF_NUM, (_in(CONTEXT), _in(INT)))
  Z3_rcf_num Z3_rcf_mk_small_int(
    Z3_context c,
    int val,
  ) {
    return _Z3_rcf_mk_small_int(
      c,
      val,
    );
  }

  late final _Z3_rcf_mk_small_intPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, ffi.Int)>>(
          'Z3_rcf_mk_small_int');
  late final _Z3_rcf_mk_small_int = _Z3_rcf_mk_small_intPtr.asFunction<
      Z3_rcf_num Function(Z3_context, int)>();

  /// \brief Return Pi
  ///
  /// def_API('Z3_rcf_mk_pi', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num Z3_rcf_mk_pi(
    Z3_context c,
  ) {
    return _Z3_rcf_mk_pi(
      c,
    );
  }

  late final _Z3_rcf_mk_piPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_pi');
  late final _Z3_rcf_mk_pi =
      _Z3_rcf_mk_piPtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Return e (Euler's constant)
  ///
  /// def_API('Z3_rcf_mk_e', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num Z3_rcf_mk_e(
    Z3_context c,
  ) {
    return _Z3_rcf_mk_e(
      c,
    );
  }

  late final _Z3_rcf_mk_ePtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_e');
  late final _Z3_rcf_mk_e =
      _Z3_rcf_mk_ePtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Return a new infinitesimal that is smaller than all elements in the Z3 field.
  ///
  /// def_API('Z3_rcf_mk_infinitesimal', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num Z3_rcf_mk_infinitesimal(
    Z3_context c,
  ) {
    return _Z3_rcf_mk_infinitesimal(
      c,
    );
  }

  late final _Z3_rcf_mk_infinitesimalPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_infinitesimal');
  late final _Z3_rcf_mk_infinitesimal =
      _Z3_rcf_mk_infinitesimalPtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Store in roots the roots of the polynomial \ccode{a[n-1]*x^{n-1} + ... + a[0]}.
  /// The output vector \c roots must have size \c n.
  /// It returns the number of roots of the polynomial.
  ///
  /// \pre The input polynomial is not the zero polynomial.
  ///
  /// def_API('Z3_rcf_mk_roots', UINT, (_in(CONTEXT), _in(UINT), _in_array(1, RCF_NUM), _out_array(1, RCF_NUM)))
  int Z3_rcf_mk_roots(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_rcf_num> a,
    ffi.Pointer<Z3_rcf_num> roots,
  ) {
    return _Z3_rcf_mk_roots(
      c,
      n,
      a,
      roots,
    );
  }

  late final _Z3_rcf_mk_rootsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>>('Z3_rcf_mk_roots');
  late final _Z3_rcf_mk_roots = _Z3_rcf_mk_rootsPtr.asFunction<
      int Function(
          Z3_context, int, ffi.Pointer<Z3_rcf_num>, ffi.Pointer<Z3_rcf_num>)>();

  /// \brief Return the value \ccode{a + b}.
  ///
  /// def_API('Z3_rcf_add', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_add(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_add(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_addPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_add');
  late final _Z3_rcf_add = _Z3_rcf_addPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a - b}.
  ///
  /// def_API('Z3_rcf_sub', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_sub(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_sub(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_subPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_sub');
  late final _Z3_rcf_sub = _Z3_rcf_subPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a * b}.
  ///
  /// def_API('Z3_rcf_mul', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_mul(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_mul(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_mulPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_mul');
  late final _Z3_rcf_mul = _Z3_rcf_mulPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a / b}.
  ///
  /// def_API('Z3_rcf_div', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_div(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_div(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_divPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_div');
  late final _Z3_rcf_div = _Z3_rcf_divPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{-a}.
  ///
  /// def_API('Z3_rcf_neg', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_neg(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _Z3_rcf_neg(
      c,
      a,
    );
  }

  late final _Z3_rcf_negPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_neg');
  late final _Z3_rcf_neg =
      _Z3_rcf_negPtr.asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return the value \ccode{1/a}.
  ///
  /// def_API('Z3_rcf_inv', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
  Z3_rcf_num Z3_rcf_inv(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _Z3_rcf_inv(
      c,
      a,
    );
  }

  late final _Z3_rcf_invPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_inv');
  late final _Z3_rcf_inv =
      _Z3_rcf_invPtr.asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a^k}.
  ///
  /// def_API('Z3_rcf_power', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
  Z3_rcf_num Z3_rcf_power(
    Z3_context c,
    Z3_rcf_num a,
    int k,
  ) {
    return _Z3_rcf_power(
      c,
      a,
      k,
    );
  }

  late final _Z3_rcf_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, ffi.UnsignedInt)>>('Z3_rcf_power');
  late final _Z3_rcf_power = _Z3_rcf_powerPtr.asFunction<
      Z3_rcf_num Function(Z3_context, Z3_rcf_num, int)>();

  /// \brief Return \c true if \ccode{a < b}.
  ///
  /// def_API('Z3_rcf_lt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_lt(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_lt(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_ltPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_lt');
  late final _Z3_rcf_lt = _Z3_rcf_ltPtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a > b}.
  ///
  /// def_API('Z3_rcf_gt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_gt(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_gt(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_gtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_gt');
  late final _Z3_rcf_gt = _Z3_rcf_gtPtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a <= b}.
  ///
  /// def_API('Z3_rcf_le', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_le(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_le(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_lePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_le');
  late final _Z3_rcf_le = _Z3_rcf_lePtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a >= b}.
  ///
  /// def_API('Z3_rcf_ge', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_ge(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_ge(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_gePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_ge');
  late final _Z3_rcf_ge = _Z3_rcf_gePtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a == b}.
  ///
  /// def_API('Z3_rcf_eq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_eq(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_eq(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_eq');
  late final _Z3_rcf_eq = _Z3_rcf_eqPtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a != b}.
  ///
  /// def_API('Z3_rcf_neq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  int Z3_rcf_neq(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _Z3_rcf_neq(
      c,
      a,
      b,
    );
  }

  late final _Z3_rcf_neqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_neq');
  late final _Z3_rcf_neq = _Z3_rcf_neqPtr.asFunction<
      int Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Convert the RCF numeral into a string.
  ///
  /// def_API('Z3_rcf_num_to_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(BOOL), _in(BOOL)))
  Z3_string Z3_rcf_num_to_string(
    Z3_context c,
    Z3_rcf_num a,
    int compact,
    int html,
  ) {
    return _Z3_rcf_num_to_string(
      c,
      a,
      compact,
      html,
    );
  }

  late final _Z3_rcf_num_to_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_rcf_num, ffi.Int,
              ffi.Int)>>('Z3_rcf_num_to_string');
  late final _Z3_rcf_num_to_string = _Z3_rcf_num_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_rcf_num, int, int)>();

  /// \brief Convert the RCF numeral into a string in decimal notation.
  ///
  /// def_API('Z3_rcf_num_to_decimal_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
  Z3_string Z3_rcf_num_to_decimal_string(
    Z3_context c,
    Z3_rcf_num a,
    int prec,
  ) {
    return _Z3_rcf_num_to_decimal_string(
      c,
      a,
      prec,
    );
  }

  late final _Z3_rcf_num_to_decimal_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_rcf_num,
              ffi.UnsignedInt)>>('Z3_rcf_num_to_decimal_string');
  late final _Z3_rcf_num_to_decimal_string = _Z3_rcf_num_to_decimal_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_rcf_num, int)>();

  /// \brief Extract the "numerator" and "denominator" of the given RCF numeral.
  /// We have that \ccode{a = n/d}, moreover \c n and \c d are not represented using rational functions.
  ///
  /// def_API('Z3_rcf_get_numerator_denominator', VOID, (_in(CONTEXT), _in(RCF_NUM), _out(RCF_NUM), _out(RCF_NUM)))
  void Z3_rcf_get_numerator_denominator(
    Z3_context c,
    Z3_rcf_num a,
    ffi.Pointer<Z3_rcf_num> n,
    ffi.Pointer<Z3_rcf_num> d,
  ) {
    return _Z3_rcf_get_numerator_denominator(
      c,
      a,
      n,
      d,
    );
  }

  late final _Z3_rcf_get_numerator_denominatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_rcf_num, ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>>('Z3_rcf_get_numerator_denominator');
  late final _Z3_rcf_get_numerator_denominator =
      _Z3_rcf_get_numerator_denominatorPtr.asFunction<
          void Function(Z3_context, Z3_rcf_num, ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>();

  /// @name Fixedpoint facilities */
  /// /**@{*/
  /// /**
  /// \brief Create a new fixedpoint context.
  ///
  /// \remark User must use #Z3_fixedpoint_inc_ref and #Z3_fixedpoint_dec_ref to manage fixedpoint objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_fixedpoint', FIXEDPOINT, (_in(CONTEXT), ))
  Z3_fixedpoint Z3_mk_fixedpoint(
    Z3_context c,
  ) {
    return _Z3_mk_fixedpoint(
      c,
    );
  }

  late final _Z3_mk_fixedpointPtr =
      _lookup<ffi.NativeFunction<Z3_fixedpoint Function(Z3_context)>>(
          'Z3_mk_fixedpoint');
  late final _Z3_mk_fixedpoint =
      _Z3_mk_fixedpointPtr.asFunction<Z3_fixedpoint Function(Z3_context)>();

  /// \brief Increment the reference counter of the given fixedpoint context
  ///
  /// def_API('Z3_fixedpoint_inc_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
  void Z3_fixedpoint_inc_ref(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_inc_ref(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_inc_ref');
  late final _Z3_fixedpoint_inc_ref = _Z3_fixedpoint_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Decrement the reference counter of the given fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_dec_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
  void Z3_fixedpoint_dec_ref(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_dec_ref(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_dec_ref');
  late final _Z3_fixedpoint_dec_ref = _Z3_fixedpoint_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Add a universal Horn clause as a named rule.
  /// The \c horn_rule should be of the form:
  ///
  /// \code
  /// horn_rule ::= (forall (bound-vars) horn_rule)
  /// |  (=> atoms horn_rule)
  /// |  atom
  /// \endcode
  ///
  /// def_API('Z3_fixedpoint_add_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
  void Z3_fixedpoint_add_rule(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast rule,
    Z3_symbol name,
  ) {
    return _Z3_fixedpoint_add_rule(
      c,
      d,
      rule,
      name,
    );
  }

  late final _Z3_fixedpoint_add_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              Z3_symbol)>>('Z3_fixedpoint_add_rule');
  late final _Z3_fixedpoint_add_rule = _Z3_fixedpoint_add_rulePtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_ast, Z3_symbol)>();

  /// \brief Add a Database fact.
  ///
  /// \param c - context
  /// \param d - fixed point context
  /// \param r - relation signature for the row.
  /// \param num_args - number of columns for the given row.
  /// \param args - array of the row elements.
  ///
  /// The number of arguments \c num_args should be equal to the number
  /// of sorts in the domain of \c r. Each sort in the domain should be an integral
  /// (bit-vector, Boolean or or finite domain sort).
  ///
  /// The call has the same effect as adding a rule where \c r is applied to the arguments.
  ///
  /// def_API('Z3_fixedpoint_add_fact', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, UINT)))
  void Z3_fixedpoint_add_fact(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl r,
    int num_args,
    ffi.Pointer<ffi.UnsignedInt> args,
  ) {
    return _Z3_fixedpoint_add_fact(
      c,
      d,
      r,
      num_args,
      args,
    );
  }

  late final _Z3_fixedpoint_add_factPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_fixedpoint,
              Z3_func_decl,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_fixedpoint_add_fact');
  late final _Z3_fixedpoint_add_fact = _Z3_fixedpoint_add_factPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Assert a constraint to the fixedpoint context.
  ///
  /// The constraints are used as background axioms when the fixedpoint engine uses the PDR mode.
  /// They are ignored for standard Datalog mode.
  ///
  /// def_API('Z3_fixedpoint_assert', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
  void Z3_fixedpoint_assert(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast axiom,
  ) {
    return _Z3_fixedpoint_assert(
      c,
      d,
      axiom,
    );
  }

  late final _Z3_fixedpoint_assertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_fixedpoint, Z3_ast)>>('Z3_fixedpoint_assert');
  late final _Z3_fixedpoint_assert = _Z3_fixedpoint_assertPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_ast)>();

  /// \brief Pose a query against the asserted rules.
  ///
  /// \code
  /// query ::= (exists (bound-vars) query)
  /// |  literals
  /// \endcode
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
  int Z3_fixedpoint_query(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast query,
  ) {
    return _Z3_fixedpoint_query(
      c,
      d,
      query,
    );
  }

  late final _Z3_fixedpoint_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Z3_context, Z3_fixedpoint, Z3_ast)>>('Z3_fixedpoint_query');
  late final _Z3_fixedpoint_query = _Z3_fixedpoint_queryPtr.asFunction<
      int Function(Z3_context, Z3_fixedpoint, Z3_ast)>();

  /// \brief Pose multiple queries against the asserted rules.
  ///
  /// The queries are encoded as relations (function declarations).
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query_relations', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, FUNC_DECL)))
  int Z3_fixedpoint_query_relations(
    Z3_context c,
    Z3_fixedpoint d,
    int num_relations,
    ffi.Pointer<Z3_func_decl> relations,
  ) {
    return _Z3_fixedpoint_query_relations(
      c,
      d,
      num_relations,
      relations,
    );
  }

  late final _Z3_fixedpoint_query_relationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_fixedpoint, ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>)>>('Z3_fixedpoint_query_relations');
  late final _Z3_fixedpoint_query_relations =
      _Z3_fixedpoint_query_relationsPtr.asFunction<
          int Function(
              Z3_context, Z3_fixedpoint, int, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Retrieve a formula that encodes satisfying answers to the query.
  ///
  ///
  /// When used in Datalog mode, the returned answer is a disjunction of conjuncts.
  /// Each conjunct encodes values of the bound variables of the query that are satisfied.
  /// In PDR mode, the returned answer is a single conjunction.
  ///
  /// When used in Datalog mode the previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
  /// When used with the PDR engine, the previous call must have been either \c Z3_L_TRUE or \c Z3_L_FALSE.
  ///
  /// def_API('Z3_fixedpoint_get_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast Z3_fixedpoint_get_answer(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_answer(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_answerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_answer');
  late final _Z3_fixedpoint_get_answer = _Z3_fixedpoint_get_answerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Retrieve a string that describes the last status returned by #Z3_fixedpoint_query.
  ///
  /// Use this method when #Z3_fixedpoint_query returns \c Z3_L_UNDEF.
  ///
  /// def_API('Z3_fixedpoint_get_reason_unknown', STRING, (_in(CONTEXT), _in(FIXEDPOINT) ))
  Z3_string Z3_fixedpoint_get_reason_unknown(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_reason_unknown(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_reason_unknownPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_reason_unknown');
  late final _Z3_fixedpoint_get_reason_unknown =
      _Z3_fixedpoint_get_reason_unknownPtr.asFunction<
          Z3_string Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Update a named rule.
  /// A rule with the same name must have been previously created.
  ///
  /// def_API('Z3_fixedpoint_update_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
  void Z3_fixedpoint_update_rule(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast a,
    Z3_symbol name,
  ) {
    return _Z3_fixedpoint_update_rule(
      c,
      d,
      a,
      name,
    );
  }

  late final _Z3_fixedpoint_update_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              Z3_symbol)>>('Z3_fixedpoint_update_rule');
  late final _Z3_fixedpoint_update_rule =
      _Z3_fixedpoint_update_rulePtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_ast, Z3_symbol)>();

  /// \brief Query the PDR engine for the maximal levels properties are known about predicate.
  ///
  /// This call retrieves the maximal number of relevant unfoldings
  /// of \c pred with respect to the current exploration state.
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_get_num_levels', UINT, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  int Z3_fixedpoint_get_num_levels(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
  ) {
    return _Z3_fixedpoint_get_num_levels(
      c,
      d,
      pred,
    );
  }

  late final _Z3_fixedpoint_get_num_levelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_get_num_levels');
  late final _Z3_fixedpoint_get_num_levels = _Z3_fixedpoint_get_num_levelsPtr
      .asFunction<int Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// Retrieve the current cover of \c pred up to \c level unfoldings.
  /// Return just the delta that is known at \c level. To
  /// obtain the full set of properties of \c pred one should query
  /// at \c level+1 , \c level+2 etc, and include \c level=-1.
  ///
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_get_cover_delta', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL)))
  Z3_ast Z3_fixedpoint_get_cover_delta(
    Z3_context c,
    Z3_fixedpoint d,
    int level,
    Z3_func_decl pred,
  ) {
    return _Z3_fixedpoint_get_cover_delta(
      c,
      d,
      level,
      pred,
    );
  }

  late final _Z3_fixedpoint_get_cover_deltaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint, ffi.Int,
              Z3_func_decl)>>('Z3_fixedpoint_get_cover_delta');
  late final _Z3_fixedpoint_get_cover_delta =
      _Z3_fixedpoint_get_cover_deltaPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint, int, Z3_func_decl)>();

  /// \brief Add property about the predicate \c pred.
  /// Add a property of predicate \c pred at \c level.
  /// It gets pushed forward when possible.
  ///
  /// Note: level = -1 is treated as the fixedpoint. So passing -1 for the \c level
  /// means that the property is true of the fixed-point unfolding with respect to \c pred.
  ///
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_add_cover', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL), _in(AST)))
  void Z3_fixedpoint_add_cover(
    Z3_context c,
    Z3_fixedpoint d,
    int level,
    Z3_func_decl pred,
    Z3_ast property,
  ) {
    return _Z3_fixedpoint_add_cover(
      c,
      d,
      level,
      pred,
      property,
    );
  }

  late final _Z3_fixedpoint_add_coverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, ffi.Int, Z3_func_decl,
              Z3_ast)>>('Z3_fixedpoint_add_cover');
  late final _Z3_fixedpoint_add_cover = _Z3_fixedpoint_add_coverPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, int, Z3_func_decl, Z3_ast)>();

  /// \brief Retrieve statistics information from the last call to #Z3_fixedpoint_query.
  ///
  /// def_API('Z3_fixedpoint_get_statistics', STATS, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_stats Z3_fixedpoint_get_statistics(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_statistics(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_statistics');
  late final _Z3_fixedpoint_get_statistics = _Z3_fixedpoint_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Register relation as Fixedpoint defined.
  /// Fixedpoint defined relations have least-fixedpoint semantics.
  /// For example, the relation is empty if it does not occur
  /// in a head or a fact.
  ///
  /// def_API('Z3_fixedpoint_register_relation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  void Z3_fixedpoint_register_relation(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl f,
  ) {
    return _Z3_fixedpoint_register_relation(
      c,
      d,
      f,
    );
  }

  late final _Z3_fixedpoint_register_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_register_relation');
  late final _Z3_fixedpoint_register_relation =
      _Z3_fixedpoint_register_relationPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// \brief Configure the predicate representation.
  ///
  /// It sets the predicate to use a set of domains given by the list of symbols.
  /// The domains given by the list of symbols must belong to a set
  /// of built-in domains.
  ///
  /// def_API('Z3_fixedpoint_set_predicate_representation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, SYMBOL)))
  void Z3_fixedpoint_set_predicate_representation(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl f,
    int num_relations,
    ffi.Pointer<Z3_symbol> relation_kinds,
  ) {
    return _Z3_fixedpoint_set_predicate_representation(
      c,
      d,
      f,
      num_relations,
      relation_kinds,
    );
  }

  late final _Z3_fixedpoint_set_predicate_representationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_func_decl,
                  ffi.UnsignedInt, ffi.Pointer<Z3_symbol>)>>(
      'Z3_fixedpoint_set_predicate_representation');
  late final _Z3_fixedpoint_set_predicate_representation =
      _Z3_fixedpoint_set_predicate_representationPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, int,
              ffi.Pointer<Z3_symbol>)>();

  /// \brief Retrieve set of rules from fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_get_rules', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
  Z3_ast_vector Z3_fixedpoint_get_rules(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _Z3_fixedpoint_get_rules(
      c,
      f,
    );
  }

  late final _Z3_fixedpoint_get_rulesPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context, Z3_fixedpoint)>>('Z3_fixedpoint_get_rules');
  late final _Z3_fixedpoint_get_rules = _Z3_fixedpoint_get_rulesPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Retrieve set of background assertions from fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_get_assertions', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
  Z3_ast_vector Z3_fixedpoint_get_assertions(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _Z3_fixedpoint_get_assertions(
      c,
      f,
    );
  }

  late final _Z3_fixedpoint_get_assertionsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context, Z3_fixedpoint)>>('Z3_fixedpoint_get_assertions');
  late final _Z3_fixedpoint_get_assertions = _Z3_fixedpoint_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Set parameters on fixedpoint context.
  ///
  /// \sa Z3_fixedpoint_get_help
  /// \sa Z3_fixedpoint_get_param_descrs
  ///
  /// def_API('Z3_fixedpoint_set_params', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(PARAMS)))
  void Z3_fixedpoint_set_params(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_params p,
  ) {
    return _Z3_fixedpoint_set_params(
      c,
      f,
      p,
    );
  }

  late final _Z3_fixedpoint_set_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              Z3_params)>>('Z3_fixedpoint_set_params');
  late final _Z3_fixedpoint_set_params = _Z3_fixedpoint_set_paramsPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_params)>();

  /// \brief Return a string describing all fixedpoint available parameters.
  ///
  /// \sa Z3_fixedpoint_get_param_descrs
  /// \sa Z3_fixedpoint_set_params
  ///
  /// def_API('Z3_fixedpoint_get_help', STRING, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_string Z3_fixedpoint_get_help(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _Z3_fixedpoint_get_help(
      c,
      f,
    );
  }

  late final _Z3_fixedpoint_get_helpPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_help');
  late final _Z3_fixedpoint_get_help = _Z3_fixedpoint_get_helpPtr.asFunction<
      Z3_string Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Return the parameter description set for the given fixedpoint object.
  ///
  /// \sa Z3_fixedpoint_get_help
  /// \sa Z3_fixedpoint_set_params
  ///
  /// def_API('Z3_fixedpoint_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_param_descrs Z3_fixedpoint_get_param_descrs(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _Z3_fixedpoint_get_param_descrs(
      c,
      f,
    );
  }

  late final _Z3_fixedpoint_get_param_descrsPtr = _lookup<
      ffi.NativeFunction<
          Z3_param_descrs Function(
              Z3_context, Z3_fixedpoint)>>('Z3_fixedpoint_get_param_descrs');
  late final _Z3_fixedpoint_get_param_descrs =
      _Z3_fixedpoint_get_param_descrsPtr.asFunction<
          Z3_param_descrs Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Print the current rules and background axioms as a string.
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param num_queries - number of additional queries to print.
  /// \param queries - additional queries.
  ///
  /// \sa Z3_fixedpoint_from_file
  /// \sa Z3_fixedpoint_from_string
  ///
  /// def_API('Z3_fixedpoint_to_string', STRING, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, AST)))
  Z3_string Z3_fixedpoint_to_string(
    Z3_context c,
    Z3_fixedpoint f,
    int num_queries,
    ffi.Pointer<Z3_ast> queries,
  ) {
    return _Z3_fixedpoint_to_string(
      c,
      f,
      num_queries,
      queries,
    );
  }

  late final _Z3_fixedpoint_to_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_fixedpoint, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_fixedpoint_to_string');
  late final _Z3_fixedpoint_to_string = _Z3_fixedpoint_to_stringPtr.asFunction<
      Z3_string Function(
          Z3_context, Z3_fixedpoint, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Parse an SMT-LIB2 string with fixedpoint rules.
  /// Add the rules to the current fixedpoint context.
  /// Return the set of queries in the string.
  ///
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param s - string containing SMT2 specification.
  ///
  /// \sa Z3_fixedpoint_from_file
  /// \sa Z3_fixedpoint_to_string
  ///
  /// def_API('Z3_fixedpoint_from_string', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
  Z3_ast_vector Z3_fixedpoint_from_string(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_string s,
  ) {
    return _Z3_fixedpoint_from_string(
      c,
      f,
      s,
    );
  }

  late final _Z3_fixedpoint_from_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint,
              Z3_string)>>('Z3_fixedpoint_from_string');
  late final _Z3_fixedpoint_from_string =
      _Z3_fixedpoint_from_stringPtr.asFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint, Z3_string)>();

  /// \brief Parse an SMT-LIB2 file with fixedpoint rules.
  /// Add the rules to the current fixedpoint context.
  /// Return the set of queries in the file.
  ///
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param s - path to file containing SMT2 specification.
  ///
  /// \sa Z3_fixedpoint_from_string
  /// \sa Z3_fixedpoint_to_string
  ///
  /// def_API('Z3_fixedpoint_from_file', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
  Z3_ast_vector Z3_fixedpoint_from_file(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_string s,
  ) {
    return _Z3_fixedpoint_from_file(
      c,
      f,
      s,
    );
  }

  late final _Z3_fixedpoint_from_filePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint,
              Z3_string)>>('Z3_fixedpoint_from_file');
  late final _Z3_fixedpoint_from_file = _Z3_fixedpoint_from_filePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_fixedpoint, Z3_string)>();

  /// \brief Initialize the context with a user-defined state.
  void Z3_fixedpoint_init(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<ffi.Void> state,
  ) {
    return _Z3_fixedpoint_init(
      c,
      d,
      state,
    );
  }

  late final _Z3_fixedpoint_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<ffi.Void>)>>('Z3_fixedpoint_init');
  late final _Z3_fixedpoint_init = _Z3_fixedpoint_initPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, ffi.Pointer<ffi.Void>)>();

  /// \brief Register a callback to destructive updates.
  ///
  /// Registers are identified with terms encoded as fresh constants,
  void Z3_fixedpoint_set_reduce_assign_callback(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr> cb,
  ) {
    return _Z3_fixedpoint_set_reduce_assign_callback(
      c,
      d,
      cb,
    );
  }

  late final _Z3_fixedpoint_set_reduce_assign_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint,
                  ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr>)>>(
      'Z3_fixedpoint_set_reduce_assign_callback');
  late final _Z3_fixedpoint_set_reduce_assign_callback =
      _Z3_fixedpoint_set_reduce_assign_callbackPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr>)>();

  /// \brief Register a callback for building terms based on the relational operators.
  void Z3_fixedpoint_set_reduce_app_callback(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr> cb,
  ) {
    return _Z3_fixedpoint_set_reduce_app_callback(
      c,
      d,
      cb,
    );
  }

  late final _Z3_fixedpoint_set_reduce_app_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint,
                  ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr>)>>(
      'Z3_fixedpoint_set_reduce_app_callback');
  late final _Z3_fixedpoint_set_reduce_app_callback =
      _Z3_fixedpoint_set_reduce_app_callbackPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr>)>();

  /// \brief set export callback for lemmas
  void Z3_fixedpoint_add_callback(
    Z3_context ctx,
    Z3_fixedpoint f,
    ffi.Pointer<ffi.Void> state,
    Z3_fixedpoint_new_lemma_eh new_lemma_eh,
    Z3_fixedpoint_predecessor_eh predecessor_eh,
    Z3_fixedpoint_unfold_eh unfold_eh,
  ) {
    return _Z3_fixedpoint_add_callback(
      ctx,
      f,
      state,
      new_lemma_eh,
      predecessor_eh,
      unfold_eh,
    );
  }

  late final _Z3_fixedpoint_add_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_fixedpoint,
              ffi.Pointer<ffi.Void>,
              Z3_fixedpoint_new_lemma_eh,
              Z3_fixedpoint_predecessor_eh,
              Z3_fixedpoint_unfold_eh)>>('Z3_fixedpoint_add_callback');
  late final _Z3_fixedpoint_add_callback =
      _Z3_fixedpoint_add_callbackPtr.asFunction<
          void Function(
              Z3_context,
              Z3_fixedpoint,
              ffi.Pointer<ffi.Void>,
              Z3_fixedpoint_new_lemma_eh,
              Z3_fixedpoint_predecessor_eh,
              Z3_fixedpoint_unfold_eh)>();

  void Z3_fixedpoint_add_constraint(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast e,
    int lvl,
  ) {
    return _Z3_fixedpoint_add_constraint(
      c,
      d,
      e,
      lvl,
    );
  }

  late final _Z3_fixedpoint_add_constraintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              ffi.UnsignedInt)>>('Z3_fixedpoint_add_constraint');
  late final _Z3_fixedpoint_add_constraint = _Z3_fixedpoint_add_constraintPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_ast, int)>();

  /// @name Optimization facilities */
  /// /**@{*/
  /// /**
  /// \brief Create a new optimize context.
  ///
  /// \remark User must use #Z3_optimize_inc_ref and #Z3_optimize_dec_ref to manage optimize objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_optimize', OPTIMIZE, (_in(CONTEXT), ))
  Z3_optimize Z3_mk_optimize(
    Z3_context c,
  ) {
    return _Z3_mk_optimize(
      c,
    );
  }

  late final _Z3_mk_optimizePtr =
      _lookup<ffi.NativeFunction<Z3_optimize Function(Z3_context)>>(
          'Z3_mk_optimize');
  late final _Z3_mk_optimize =
      _Z3_mk_optimizePtr.asFunction<Z3_optimize Function(Z3_context)>();

  /// \brief Increment the reference counter of the given optimize context
  ///
  /// def_API('Z3_optimize_inc_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void Z3_optimize_inc_ref(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_inc_ref(
      c,
      d,
    );
  }

  late final _Z3_optimize_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_inc_ref');
  late final _Z3_optimize_inc_ref = _Z3_optimize_inc_refPtr.asFunction<
      void Function(Z3_context, Z3_optimize)>();

  /// \brief Decrement the reference counter of the given optimize context.
  ///
  /// def_API('Z3_optimize_dec_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void Z3_optimize_dec_ref(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_dec_ref(
      c,
      d,
    );
  }

  late final _Z3_optimize_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_dec_ref');
  late final _Z3_optimize_dec_ref = _Z3_optimize_dec_refPtr.asFunction<
      void Function(Z3_context, Z3_optimize)>();

  /// \brief Assert hard constraint to the optimization context.
  ///
  /// \sa Z3_optimize_assert_soft
  /// \sa Z3_optimize_assert_and_track
  ///
  /// def_API('Z3_optimize_assert', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  void Z3_optimize_assert(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
  ) {
    return _Z3_optimize_assert(
      c,
      o,
      a,
    );
  }

  late final _Z3_optimize_assertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_ast)>>('Z3_optimize_assert');
  late final _Z3_optimize_assert = _Z3_optimize_assertPtr.asFunction<
      void Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Assert tracked hard constraint to the optimization context.
  ///
  /// \sa Z3_optimize_assert
  /// \sa Z3_optimize_assert_soft
  ///
  /// def_API('Z3_optimize_assert_and_track', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(AST)))
  void Z3_optimize_assert_and_track(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
    Z3_ast t,
  ) {
    return _Z3_optimize_assert_and_track(
      c,
      o,
      a,
      t,
    );
  }

  late final _Z3_optimize_assert_and_trackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_optimize, Z3_ast,
              Z3_ast)>>('Z3_optimize_assert_and_track');
  late final _Z3_optimize_assert_and_track = _Z3_optimize_assert_and_trackPtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_ast, Z3_ast)>();

  /// \brief Assert soft constraint to the optimization context.
  /// \param c - context
  /// \param o - optimization context
  /// \param a - formula
  /// \param weight - a penalty for violating soft constraint. Negative weights convert into rewards.
  /// \param id - optional identifier to group soft constraints
  ///
  /// \sa Z3_optimize_assert
  /// \sa Z3_optimize_assert_and_track
  ///
  /// def_API('Z3_optimize_assert_soft', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(STRING), _in(SYMBOL)))
  int Z3_optimize_assert_soft(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
    Z3_string weight,
    Z3_symbol id,
  ) {
    return _Z3_optimize_assert_soft(
      c,
      o,
      a,
      weight,
      id,
    );
  }

  late final _Z3_optimize_assert_softPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_optimize, Z3_ast, Z3_string,
              Z3_symbol)>>('Z3_optimize_assert_soft');
  late final _Z3_optimize_assert_soft = _Z3_optimize_assert_softPtr.asFunction<
      int Function(Z3_context, Z3_optimize, Z3_ast, Z3_string, Z3_symbol)>();

  /// \brief Add a maximization constraint.
  /// \param c - context
  /// \param o - optimization context
  /// \param t - arithmetical term
  ///
  /// \sa Z3_optimize_minimize
  ///
  /// def_API('Z3_optimize_maximize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  int Z3_optimize_maximize(
    Z3_context c,
    Z3_optimize o,
    Z3_ast t,
  ) {
    return _Z3_optimize_maximize(
      c,
      o,
      t,
    );
  }

  late final _Z3_optimize_maximizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_optimize, Z3_ast)>>('Z3_optimize_maximize');
  late final _Z3_optimize_maximize = _Z3_optimize_maximizePtr.asFunction<
      int Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Add a minimization constraint.
  /// \param c - context
  /// \param o - optimization context
  /// \param t - arithmetical term
  ///
  /// \sa Z3_optimize_maximize
  ///
  /// def_API('Z3_optimize_minimize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  int Z3_optimize_minimize(
    Z3_context c,
    Z3_optimize o,
    Z3_ast t,
  ) {
    return _Z3_optimize_minimize(
      c,
      o,
      t,
    );
  }

  late final _Z3_optimize_minimizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_optimize, Z3_ast)>>('Z3_optimize_minimize');
  late final _Z3_optimize_minimize = _Z3_optimize_minimizePtr.asFunction<
      int Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Create a backtracking point.
  ///
  /// The optimize solver contains a set of rules, added facts and assertions.
  /// The set of rules, facts and assertions are restored upon calling #Z3_optimize_pop.
  ///
  /// \sa Z3_optimize_pop
  ///
  /// def_API('Z3_optimize_push', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void Z3_optimize_push(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_push(
      c,
      d,
    );
  }

  late final _Z3_optimize_pushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_push');
  late final _Z3_optimize_push =
      _Z3_optimize_pushPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Backtrack one level.
  ///
  /// \sa Z3_optimize_push
  ///
  /// \pre The number of calls to pop cannot exceed calls to push.
  ///
  /// def_API('Z3_optimize_pop', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void Z3_optimize_pop(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_pop(
      c,
      d,
    );
  }

  late final _Z3_optimize_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_pop');
  late final _Z3_optimize_pop =
      _Z3_optimize_popPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Check consistency and produce optimal values.
  /// \param c - context
  /// \param o - optimization context
  /// \param num_assumptions - number of additional assumptions
  /// \param assumptions - the additional assumptions
  ///
  /// \sa Z3_optimize_get_reason_unknown
  /// \sa Z3_optimize_get_model
  /// \sa Z3_optimize_get_statistics
  /// \sa Z3_optimize_get_unsat_core
  ///
  /// def_API('Z3_optimize_check', LBOOL, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT), _in_array(2, AST)))
  int Z3_optimize_check(
    Z3_context c,
    Z3_optimize o,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
  ) {
    return _Z3_optimize_check(
      c,
      o,
      num_assumptions,
      assumptions,
    );
  }

  late final _Z3_optimize_checkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_optimize, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_optimize_check');
  late final _Z3_optimize_check = _Z3_optimize_checkPtr.asFunction<
      int Function(Z3_context, Z3_optimize, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Retrieve a string that describes the last status returned by #Z3_optimize_check.
  ///
  /// Use this method when #Z3_optimize_check returns \c Z3_L_UNDEF.
  ///
  /// def_API('Z3_optimize_get_reason_unknown', STRING, (_in(CONTEXT), _in(OPTIMIZE) ))
  Z3_string Z3_optimize_get_reason_unknown(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_get_reason_unknown(
      c,
      d,
    );
  }

  late final _Z3_optimize_get_reason_unknownPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_reason_unknown');
  late final _Z3_optimize_get_reason_unknown =
      _Z3_optimize_get_reason_unknownPtr.asFunction<
          Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve the model for the last #Z3_optimize_check
  ///
  /// The error handler is invoked if a model is not available because
  /// the commands above were not invoked for the given optimization
  /// solver, or if the result was \c Z3_L_FALSE.
  ///
  /// def_API('Z3_optimize_get_model', MODEL, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_model Z3_optimize_get_model(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_get_model(
      c,
      o,
    );
  }

  late final _Z3_optimize_get_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_model');
  late final _Z3_optimize_get_model = _Z3_optimize_get_modelPtr.asFunction<
      Z3_model Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve the unsat core for the last #Z3_optimize_check
  /// The unsat core is a subset of the assumptions \c a.
  ///
  /// def_API('Z3_optimize_get_unsat_core', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector Z3_optimize_get_unsat_core(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_get_unsat_core(
      c,
      o,
    );
  }

  late final _Z3_optimize_get_unsat_corePtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_unsat_core');
  late final _Z3_optimize_get_unsat_core = _Z3_optimize_get_unsat_corePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief Set parameters on optimization context.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param p - parameters
  ///
  /// \sa Z3_optimize_get_help
  /// \sa Z3_optimize_get_param_descrs
  ///
  /// def_API('Z3_optimize_set_params', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(PARAMS)))
  void Z3_optimize_set_params(
    Z3_context c,
    Z3_optimize o,
    Z3_params p,
  ) {
    return _Z3_optimize_set_params(
      c,
      o,
      p,
    );
  }

  late final _Z3_optimize_set_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_params)>>('Z3_optimize_set_params');
  late final _Z3_optimize_set_params = _Z3_optimize_set_paramsPtr.asFunction<
      void Function(Z3_context, Z3_optimize, Z3_params)>();

  /// \brief Return the parameter description set for the given optimize object.
  ///
  /// \param c - context
  /// \param o - optimization context
  ///
  /// \sa Z3_optimize_get_help
  /// \sa Z3_optimize_set_params
  ///
  /// def_API('Z3_optimize_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_param_descrs Z3_optimize_get_param_descrs(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_get_param_descrs(
      c,
      o,
    );
  }

  late final _Z3_optimize_get_param_descrsPtr = _lookup<
      ffi.NativeFunction<
          Z3_param_descrs Function(
              Z3_context, Z3_optimize)>>('Z3_optimize_get_param_descrs');
  late final _Z3_optimize_get_param_descrs = _Z3_optimize_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve lower bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_lower_as_vector
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_lower', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast Z3_optimize_get_lower(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _Z3_optimize_get_lower(
      c,
      o,
      idx,
    );
  }

  late final _Z3_optimize_get_lowerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_lower');
  late final _Z3_optimize_get_lower = _Z3_optimize_get_lowerPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve upper bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_lower_as_vector
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_upper', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast Z3_optimize_get_upper(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _Z3_optimize_get_upper(
      c,
      o,
      idx,
    );
  }

  late final _Z3_optimize_get_upperPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_upper');
  late final _Z3_optimize_get_upper = _Z3_optimize_get_upperPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve lower bound value or approximation for the i'th optimization objective.
  /// The returned vector is of length 3. It always contains numerals.
  /// The three numerals are coefficients \c a, \c b, \c c and encode the result of
  /// #Z3_optimize_get_lower \ccode{a * infinity + b + c * epsilon}.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_lower_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast_vector Z3_optimize_get_lower_as_vector(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _Z3_optimize_get_lower_as_vector(
      c,
      o,
      idx,
    );
  }

  late final _Z3_optimize_get_lower_as_vectorPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_lower_as_vector');
  late final _Z3_optimize_get_lower_as_vector =
      _Z3_optimize_get_lower_as_vectorPtr.asFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve upper bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_lower_as_vector
  ///
  /// def_API('Z3_optimize_get_upper_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast_vector Z3_optimize_get_upper_as_vector(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _Z3_optimize_get_upper_as_vector(
      c,
      o,
      idx,
    );
  }

  late final _Z3_optimize_get_upper_as_vectorPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_upper_as_vector');
  late final _Z3_optimize_get_upper_as_vector =
      _Z3_optimize_get_upper_as_vectorPtr.asFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize, int)>();

  /// \brief Print the current context as a string.
  /// \param c - context.
  /// \param o - optimization context.
  ///
  /// \sa Z3_optimize_from_file
  /// \sa Z3_optimize_from_string
  ///
  /// def_API('Z3_optimize_to_string', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_string Z3_optimize_to_string(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_to_string(
      c,
      o,
    );
  }

  late final _Z3_optimize_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_to_string');
  late final _Z3_optimize_to_string = _Z3_optimize_to_stringPtr.asFunction<
      Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Parse an SMT-LIB2 string with assertions,
  /// soft constraints and optimization objectives.
  /// Add the parsed constraints and objectives to the optimization context.
  ///
  /// \param c - context.
  /// \param o - optimize context.
  /// \param s - string containing SMT2 specification.
  ///
  /// \sa Z3_optimize_from_file
  /// \sa Z3_optimize_to_string
  ///
  /// def_API('Z3_optimize_from_string', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
  void Z3_optimize_from_string(
    Z3_context c,
    Z3_optimize o,
    Z3_string s,
  ) {
    return _Z3_optimize_from_string(
      c,
      o,
      s,
    );
  }

  late final _Z3_optimize_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_string)>>('Z3_optimize_from_string');
  late final _Z3_optimize_from_string = _Z3_optimize_from_stringPtr.asFunction<
      void Function(Z3_context, Z3_optimize, Z3_string)>();

  /// \brief Parse an SMT-LIB2 file with assertions,
  /// soft constraints and optimization objectives.
  /// Add the parsed constraints and objectives to the optimization context.
  ///
  /// \param c - context.
  /// \param o - optimize context.
  /// \param s - path to file containing SMT2 specification.
  ///
  /// \sa Z3_optimize_from_string
  /// \sa Z3_optimize_to_string
  ///
  /// def_API('Z3_optimize_from_file', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
  void Z3_optimize_from_file(
    Z3_context c,
    Z3_optimize o,
    Z3_string s,
  ) {
    return _Z3_optimize_from_file(
      c,
      o,
      s,
    );
  }

  late final _Z3_optimize_from_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_string)>>('Z3_optimize_from_file');
  late final _Z3_optimize_from_file = _Z3_optimize_from_filePtr.asFunction<
      void Function(Z3_context, Z3_optimize, Z3_string)>();

  /// \brief Return a string containing a description of parameters accepted by optimize.
  ///
  /// \sa Z3_optimize_get_param_descrs
  /// \sa Z3_optimize_set_params
  ///
  /// def_API('Z3_optimize_get_help', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_string Z3_optimize_get_help(
    Z3_context c,
    Z3_optimize t,
  ) {
    return _Z3_optimize_get_help(
      c,
      t,
    );
  }

  late final _Z3_optimize_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_help');
  late final _Z3_optimize_get_help = _Z3_optimize_get_helpPtr.asFunction<
      Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve statistics information from the last call to #Z3_optimize_check
  ///
  /// def_API('Z3_optimize_get_statistics', STATS, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_stats Z3_optimize_get_statistics(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _Z3_optimize_get_statistics(
      c,
      d,
    );
  }

  late final _Z3_optimize_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_statistics');
  late final _Z3_optimize_get_statistics = _Z3_optimize_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_optimize)>();

  /// \brief Return the set of asserted formulas on the optimization context.
  ///
  /// def_API('Z3_optimize_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector Z3_optimize_get_assertions(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_get_assertions(
      c,
      o,
    );
  }

  late final _Z3_optimize_get_assertionsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_assertions');
  late final _Z3_optimize_get_assertions = _Z3_optimize_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief Return objectives on the optimization context.
  /// If the objective function is a max-sat objective it is returned
  /// as a Pseudo-Boolean (minimization) sum of the form \ccode{(+ (if f1 w1 0) (if f2 w2 0) ...)}
  /// If the objective function is entered as a maximization objective, then return
  /// the corresponding minimization objective. In this way the resulting objective
  /// function is always returned as a minimization objective.
  ///
  /// def_API('Z3_optimize_get_objectives', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector Z3_optimize_get_objectives(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _Z3_optimize_get_objectives(
      c,
      o,
    );
  }

  late final _Z3_optimize_get_objectivesPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_objectives');
  late final _Z3_optimize_get_objectives = _Z3_optimize_get_objectivesPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief register a model event handler for new models.
  void Z3_optimize_register_model_eh(
    Z3_context c,
    Z3_optimize o,
    Z3_model m,
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<Z3_model_eh> model_eh,
  ) {
    return _Z3_optimize_register_model_eh(
      c,
      o,
      m,
      ctx,
      model_eh,
    );
  }

  late final _Z3_optimize_register_model_ehPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_optimize,
              Z3_model,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_model_eh>)>>('Z3_optimize_register_model_eh');
  late final _Z3_optimize_register_model_eh =
      _Z3_optimize_register_model_ehPtr.asFunction<
          void Function(Z3_context, Z3_optimize, Z3_model,
              ffi.Pointer<ffi.Void>, ffi.Pointer<Z3_model_eh>)>();

  /// @name Floating-Point Arithmetic */
  /// /**@{*/
  /// /**
  /// \brief Create the RoundingMode sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rounding_mode_sort', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_rounding_mode_sort(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rounding_mode_sort(
      c,
    );
  }

  late final _Z3_mk_fpa_rounding_mode_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_rounding_mode_sort');
  late final _Z3_mk_fpa_rounding_mode_sort = _Z3_mk_fpa_rounding_mode_sortPtr
      .asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_nearest_ties_to_even', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_round_nearest_ties_to_even(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_round_nearest_ties_to_even(
      c,
    );
  }

  late final _Z3_mk_fpa_round_nearest_ties_to_evenPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_nearest_ties_to_even');
  late final _Z3_mk_fpa_round_nearest_ties_to_even =
      _Z3_mk_fpa_round_nearest_ties_to_evenPtr.asFunction<
          Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rne', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_rne(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rne(
      c,
    );
  }

  late final _Z3_mk_fpa_rnePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rne');
  late final _Z3_mk_fpa_rne =
      _Z3_mk_fpa_rnePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_nearest_ties_to_away', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_round_nearest_ties_to_away(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_round_nearest_ties_to_away(
      c,
    );
  }

  late final _Z3_mk_fpa_round_nearest_ties_to_awayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_nearest_ties_to_away');
  late final _Z3_mk_fpa_round_nearest_ties_to_away =
      _Z3_mk_fpa_round_nearest_ties_to_awayPtr.asFunction<
          Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rna', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_rna(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rna(
      c,
    );
  }

  late final _Z3_mk_fpa_rnaPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rna');
  late final _Z3_mk_fpa_rna =
      _Z3_mk_fpa_rnaPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_positive', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_round_toward_positive(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_round_toward_positive(
      c,
    );
  }

  late final _Z3_mk_fpa_round_toward_positivePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_positive');
  late final _Z3_mk_fpa_round_toward_positive =
      _Z3_mk_fpa_round_toward_positivePtr.asFunction<
          Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtp', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_rtp(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rtp(
      c,
    );
  }

  late final _Z3_mk_fpa_rtpPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtp');
  late final _Z3_mk_fpa_rtp =
      _Z3_mk_fpa_rtpPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_negative', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_round_toward_negative(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_round_toward_negative(
      c,
    );
  }

  late final _Z3_mk_fpa_round_toward_negativePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_negative');
  late final _Z3_mk_fpa_round_toward_negative =
      _Z3_mk_fpa_round_toward_negativePtr.asFunction<
          Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtn', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_rtn(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rtn(
      c,
    );
  }

  late final _Z3_mk_fpa_rtnPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtn');
  late final _Z3_mk_fpa_rtn =
      _Z3_mk_fpa_rtnPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_zero', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_round_toward_zero(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_round_toward_zero(
      c,
    );
  }

  late final _Z3_mk_fpa_round_toward_zeroPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_zero');
  late final _Z3_mk_fpa_round_toward_zero =
      _Z3_mk_fpa_round_toward_zeroPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtz', AST, (_in(CONTEXT),))
  Z3_ast Z3_mk_fpa_rtz(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_rtz(
      c,
    );
  }

  late final _Z3_mk_fpa_rtzPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtz');
  late final _Z3_mk_fpa_rtz =
      _Z3_mk_fpa_rtzPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param ebits number of exponent bits
  /// \param sbits number of significand bits
  ///
  /// \remark \c ebits must be larger than 1 and \c sbits must be larger than 2.
  ///
  /// def_API('Z3_mk_fpa_sort', SORT, (_in(CONTEXT), _in(UINT), _in(UINT)))
  Z3_sort Z3_mk_fpa_sort(
    Z3_context c,
    int ebits,
    int sbits,
  ) {
    return _Z3_mk_fpa_sort(
      c,
      ebits,
      sbits,
    );
  }

  late final _Z3_mk_fpa_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, ffi.UnsignedInt, ffi.UnsignedInt)>>('Z3_mk_fpa_sort');
  late final _Z3_mk_fpa_sort =
      _Z3_mk_fpa_sortPtr.asFunction<Z3_sort Function(Z3_context, int, int)>();

  /// \brief Create the half-precision (16-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_half', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_half(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_half(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_halfPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_half');
  late final _Z3_mk_fpa_sort_half =
      _Z3_mk_fpa_sort_halfPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the half-precision (16-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_16', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_16(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_16(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_16Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_16');
  late final _Z3_mk_fpa_sort_16 =
      _Z3_mk_fpa_sort_16Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the single-precision (32-bit) FloatingPoint sort.
  ///
  /// \param c logical context.
  ///
  /// def_API('Z3_mk_fpa_sort_single', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_single(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_single(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_singlePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_single');
  late final _Z3_mk_fpa_sort_single =
      _Z3_mk_fpa_sort_singlePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the single-precision (32-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_32', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_32(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_32(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_32Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_32');
  late final _Z3_mk_fpa_sort_32 =
      _Z3_mk_fpa_sort_32Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the double-precision (64-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_double', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_double(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_double(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_doublePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_double');
  late final _Z3_mk_fpa_sort_double =
      _Z3_mk_fpa_sort_doublePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the double-precision (64-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_64', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_64(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_64(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_64Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_64');
  late final _Z3_mk_fpa_sort_64 =
      _Z3_mk_fpa_sort_64Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the quadruple-precision (128-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_quadruple', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_quadruple(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_quadruple(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_quadruplePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_quadruple');
  late final _Z3_mk_fpa_sort_quadruple =
      _Z3_mk_fpa_sort_quadruplePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the quadruple-precision (128-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_128', SORT, (_in(CONTEXT),))
  Z3_sort Z3_mk_fpa_sort_128(
    Z3_context c,
  ) {
    return _Z3_mk_fpa_sort_128(
      c,
    );
  }

  late final _Z3_mk_fpa_sort_128Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_128');
  late final _Z3_mk_fpa_sort_128 =
      _Z3_mk_fpa_sort_128Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a floating-point NaN of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  ///
  /// \sa Z3_mk_fpa_inf
  /// \sa Z3_mk_fpa_zero
  ///
  /// def_API('Z3_mk_fpa_nan', AST, (_in(CONTEXT),_in(SORT)))
  Z3_ast Z3_mk_fpa_nan(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_nan(
      c,
      s,
    );
  }

  late final _Z3_mk_fpa_nanPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_fpa_nan');
  late final _Z3_mk_fpa_nan =
      _Z3_mk_fpa_nanPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a floating-point infinity of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  /// \param negative indicates whether the result should be negative
  ///
  /// When \c negative is \c true, -oo will be generated instead of +oo.
  ///
  /// \sa Z3_mk_fpa_nan
  /// \sa Z3_mk_fpa_zero
  ///
  /// def_API('Z3_mk_fpa_inf', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
  Z3_ast Z3_mk_fpa_inf(
    Z3_context c,
    Z3_sort s,
    int negative,
  ) {
    return _Z3_mk_fpa_inf(
      c,
      s,
      negative,
    );
  }

  late final _Z3_mk_fpa_infPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, ffi.Int)>>(
      'Z3_mk_fpa_inf');
  late final _Z3_mk_fpa_inf =
      _Z3_mk_fpa_infPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort, int)>();

  /// \brief Create a floating-point zero of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  /// \param negative indicates whether the result should be negative
  ///
  /// When \c negative is \c true, -zero will be generated instead of +zero.
  ///
  /// \sa Z3_mk_fpa_inf
  /// \sa Z3_mk_fpa_nan
  ///
  /// def_API('Z3_mk_fpa_zero', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
  Z3_ast Z3_mk_fpa_zero(
    Z3_context c,
    Z3_sort s,
    int negative,
  ) {
    return _Z3_mk_fpa_zero(
      c,
      s,
      negative,
    );
  }

  late final _Z3_mk_fpa_zeroPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, ffi.Int)>>(
      'Z3_mk_fpa_zero');
  late final _Z3_mk_fpa_zero = _Z3_mk_fpa_zeroPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_sort, int)>();

  /// \brief Create an expression of FloatingPoint sort from three bit-vector expressions.
  ///
  /// This is the operator named `fp' in the SMT FP theory definition.
  /// Note that \c sgn is required to be a bit-vector of size 1. Significand and exponent
  /// are required to be longer than 1 and 2 respectively. The FloatingPoint sort
  /// of the resulting expression is automatically determined from the bit-vector sizes
  /// of the arguments. The exponent is assumed to be in IEEE-754 biased representation.
  ///
  /// \param c logical context
  /// \param sgn sign
  /// \param exp exponent
  /// \param sig significand
  ///
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_fp', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast Z3_mk_fpa_fp(
    Z3_context c,
    Z3_ast sgn,
    Z3_ast exp,
    Z3_ast sig,
  ) {
    return _Z3_mk_fpa_fp(
      c,
      sgn,
      exp,
      sig,
    );
  }

  late final _Z3_mk_fpa_fpPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_fp');
  late final _Z3_mk_fpa_fp = _Z3_mk_fpa_fpPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Create a numeral of FloatingPoint sort from a float.
  ///
  /// This function is used to create numerals that fit in a float value.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_float', AST, (_in(CONTEXT), _in(FLOAT), _in(SORT)))
  Z3_ast Z3_mk_fpa_numeral_float(
    Z3_context c,
    double v,
    Z3_sort ty,
  ) {
    return _Z3_mk_fpa_numeral_float(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_fpa_numeral_floatPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Float, Z3_sort)>>(
      'Z3_mk_fpa_numeral_float');
  late final _Z3_mk_fpa_numeral_float = _Z3_mk_fpa_numeral_floatPtr.asFunction<
      Z3_ast Function(Z3_context, double, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a double.
  ///
  /// This function is used to create numerals that fit in a double value.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_double', AST, (_in(CONTEXT), _in(DOUBLE), _in(SORT)))
  Z3_ast Z3_mk_fpa_numeral_double(
    Z3_context c,
    double v,
    Z3_sort ty,
  ) {
    return _Z3_mk_fpa_numeral_double(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_fpa_numeral_doublePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Double, Z3_sort)>>(
      'Z3_mk_fpa_numeral_double');
  late final _Z3_mk_fpa_numeral_double = _Z3_mk_fpa_numeral_doublePtr
      .asFunction<Z3_ast Function(Z3_context, double, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a signed integer.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
  Z3_ast Z3_mk_fpa_numeral_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _Z3_mk_fpa_numeral_int(
      c,
      v,
      ty,
    );
  }

  late final _Z3_mk_fpa_numeral_intPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, Z3_sort)>>(
      'Z3_mk_fpa_numeral_int');
  late final _Z3_mk_fpa_numeral_int = _Z3_mk_fpa_numeral_intPtr.asFunction<
      Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a sign bit and two integers.
  ///
  /// \param c logical context
  /// \param sgn sign bit (true == negative)
  /// \param sig significand
  /// \param exp exponent
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int_uint', AST, (_in(CONTEXT), _in(BOOL), _in(INT), _in(UINT), _in(SORT)))
  Z3_ast Z3_mk_fpa_numeral_int_uint(
    Z3_context c,
    int sgn,
    int exp,
    int sig,
    Z3_sort ty,
  ) {
    return _Z3_mk_fpa_numeral_int_uint(
      c,
      sgn,
      exp,
      sig,
      ty,
    );
  }

  late final _Z3_mk_fpa_numeral_int_uintPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.Int, ffi.Int, ffi.UnsignedInt,
              Z3_sort)>>('Z3_mk_fpa_numeral_int_uint');
  late final _Z3_mk_fpa_numeral_int_uint = _Z3_mk_fpa_numeral_int_uintPtr
      .asFunction<Z3_ast Function(Z3_context, int, int, int, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers.
  ///
  /// \param c logical context
  /// \param sgn sign bit (true == negative)
  /// \param sig significand
  /// \param exp exponent
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int64_uint64', AST, (_in(CONTEXT), _in(BOOL), _in(INT64), _in(UINT64), _in(SORT)))
  Z3_ast Z3_mk_fpa_numeral_int64_uint64(
    Z3_context c,
    int sgn,
    int exp,
    int sig,
    Z3_sort ty,
  ) {
    return _Z3_mk_fpa_numeral_int64_uint64(
      c,
      sgn,
      exp,
      sig,
      ty,
    );
  }

  late final _Z3_mk_fpa_numeral_int64_uint64Ptr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.Int, ffi.Int64, ffi.Uint64,
              Z3_sort)>>('Z3_mk_fpa_numeral_int64_uint64');
  late final _Z3_mk_fpa_numeral_int64_uint64 =
      _Z3_mk_fpa_numeral_int64_uint64Ptr.asFunction<
          Z3_ast Function(Z3_context, int, int, int, Z3_sort)>();

  /// \brief Floating-point absolute value
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_abs', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_abs(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_abs(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_absPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_abs');
  late final _Z3_mk_fpa_abs =
      _Z3_mk_fpa_absPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Floating-point negation
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_neg', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_neg(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_neg(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_negPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_neg');
  late final _Z3_mk_fpa_neg =
      _Z3_mk_fpa_negPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Floating-point addition
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_add', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_add(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_add(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_addPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_add');
  late final _Z3_mk_fpa_add = _Z3_mk_fpa_addPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point subtraction
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_sub', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_sub(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_sub(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_subPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_sub');
  late final _Z3_mk_fpa_sub = _Z3_mk_fpa_subPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point multiplication
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_mul', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_mul(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_mul(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_mulPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_mul');
  late final _Z3_mk_fpa_mul = _Z3_mk_fpa_mulPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point division
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort.
  /// \param t2 term of FloatingPoint sort
  ///
  /// The nodes \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_div', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_div(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_div(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_divPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_div');
  late final _Z3_mk_fpa_div = _Z3_mk_fpa_divPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point fused multiply-add.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  /// \param t3 term of FloatingPoint sort
  ///
  /// The result is \ccode{round((t1 * t2) + t3)}.
  ///
  /// \c rm must be of RoundingMode sort, \c t1, \c t2, and \c t3 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_fma', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_fma(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
    Z3_ast t3,
  ) {
    return _Z3_mk_fpa_fma(
      c,
      rm,
      t1,
      t2,
      t3,
    );
  }

  late final _Z3_mk_fpa_fmaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_fma');
  late final _Z3_mk_fpa_fma = _Z3_mk_fpa_fmaPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point square root
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_sqrt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_sqrt(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_sqrt(
      c,
      rm,
      t,
    );
  }

  late final _Z3_mk_fpa_sqrtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_sqrt');
  late final _Z3_mk_fpa_sqrt = _Z3_mk_fpa_sqrtPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point remainder
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_rem', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_rem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_rem(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_remPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_rem');
  late final _Z3_mk_fpa_rem = _Z3_mk_fpa_remPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point roundToIntegral. Rounds a floating-point number to
  /// the closest integer, again represented as a floating-point number.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must be of FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_round_to_integral', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_round_to_integral(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_round_to_integral(
      c,
      rm,
      t,
    );
  }

  late final _Z3_mk_fpa_round_to_integralPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_round_to_integral');
  late final _Z3_mk_fpa_round_to_integral = _Z3_mk_fpa_round_to_integralPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Minimum of floating-point numbers.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1, \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_min', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_min(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_min(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_minPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_min');
  late final _Z3_mk_fpa_min = _Z3_mk_fpa_minPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Maximum of floating-point numbers.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1, \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_max', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_max(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_max(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_maxPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_max');
  late final _Z3_mk_fpa_max = _Z3_mk_fpa_maxPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point less than or equal.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_leq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_leq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_leq(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_leqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_leq');
  late final _Z3_mk_fpa_leq = _Z3_mk_fpa_leqPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point less than.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_lt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_lt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_lt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_lt');
  late final _Z3_mk_fpa_lt = _Z3_mk_fpa_ltPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point greater than or equal.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_geq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_geq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_geq(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_geqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_geq');
  late final _Z3_mk_fpa_geq = _Z3_mk_fpa_geqPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point greater than.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_gt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_gt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_gt(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_gtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_gt');
  late final _Z3_mk_fpa_gt = _Z3_mk_fpa_gtPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point equality.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// Note that this is IEEE 754 equality (as opposed to SMT-LIB \ccode{=}).
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_eq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast Z3_mk_fpa_eq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _Z3_mk_fpa_eq(
      c,
      t1,
      t2,
    );
  }

  late final _Z3_mk_fpa_eqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_eq');
  late final _Z3_mk_fpa_eq = _Z3_mk_fpa_eqPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a normal floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_normal', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_normal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_normal(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_normalPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_normal');
  late final _Z3_mk_fpa_is_normal =
      _Z3_mk_fpa_is_normalPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a subnormal floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_subnormal', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_subnormal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_subnormal(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_subnormalPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_subnormal');
  late final _Z3_mk_fpa_is_subnormal = _Z3_mk_fpa_is_subnormalPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a floating-point number with zero value, i.e., +zero or -zero.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_zero', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_zero(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_zero(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_zeroPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_zero');
  late final _Z3_mk_fpa_is_zero =
      _Z3_mk_fpa_is_zeroPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a floating-point number representing +oo or -oo.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_infinite', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_infinite(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_infinite(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_infinitePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_infinite');
  late final _Z3_mk_fpa_is_infinite = _Z3_mk_fpa_is_infinitePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a NaN.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_nan', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_nan(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_nan(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_nanPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_nan');
  late final _Z3_mk_fpa_is_nan =
      _Z3_mk_fpa_is_nanPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a negative floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_negative', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_negative(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_negative(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_negativePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_negative');
  late final _Z3_mk_fpa_is_negative = _Z3_mk_fpa_is_negativePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a positive floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_positive', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_is_positive(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_is_positive(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_is_positivePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_positive');
  late final _Z3_mk_fpa_is_positive = _Z3_mk_fpa_is_positivePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Conversion of a single IEEE 754-2008 bit-vector into a floating-point number.
  ///
  /// Produces a term that represents the conversion of a bit-vector term \c bv to a
  /// floating-point term of sort \c s.
  ///
  /// \param c logical context
  /// \param bv a bit-vector term
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c t must be of bit-vector sort, and the bit-vector
  /// size of \c bv must be equal to \ccode{ebits+sbits} of \c s. The format of the bit-vector is
  /// as defined by the IEEE 754-2008 interchange format.
  ///
  /// def_API('Z3_mk_fpa_to_fp_bv', AST, (_in(CONTEXT),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_bv(
    Z3_context c,
    Z3_ast bv,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_bv(
      c,
      bv,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_sort)>>(
          'Z3_mk_fpa_to_fp_bv');
  late final _Z3_mk_fpa_to_fp_bv = _Z3_mk_fpa_to_fp_bvPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a FloatingPoint term into another term of different FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of a floating-point term \c t to a
  /// floating-point term of sort \c s. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of floating-point sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_float', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_float(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_float(
      c,
      rm,
      t,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_floatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_float');
  late final _Z3_mk_fpa_to_fp_float = _Z3_mk_fpa_to_fp_floatPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a term of real sort into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of term \c t of real sort into a
  /// floating-point term of sort \c s. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of Real sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of real sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_real(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_real(
      c,
      rm,
      t,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_realPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_real');
  late final _Z3_mk_fpa_to_fp_real = _Z3_mk_fpa_to_fp_realPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of the bit-vector term \c t into a
  /// floating-point term of sort \c s. The bit-vector \c t is taken to be in signed
  /// 2's complement format. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of bit-vector sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_signed', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_signed(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_signed(
      c,
      rm,
      t,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_signedPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_signed');
  late final _Z3_mk_fpa_to_fp_signed = _Z3_mk_fpa_to_fp_signedPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of the bit-vector term \c t into a
  /// floating-point term of sort \c s. The bit-vector \c t is taken to be in unsigned
  /// 2's complement format. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of bit-vector sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_unsigned', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_unsigned(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_unsigned(
      c,
      rm,
      t,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_unsignedPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              Z3_sort)>>('Z3_mk_fpa_to_fp_unsigned');
  late final _Z3_mk_fpa_to_fp_unsigned = _Z3_mk_fpa_to_fp_unsignedPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a floating-point term into an unsigned bit-vector.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// bit-vector term of size \c sz in unsigned 2's complement format. If necessary, the result
  /// will be rounded according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param sz size of the resulting bit-vector
  ///
  /// def_API('Z3_mk_fpa_to_ubv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
  Z3_ast Z3_mk_fpa_to_ubv(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    int sz,
  ) {
    return _Z3_mk_fpa_to_ubv(
      c,
      rm,
      t,
      sz,
    );
  }

  late final _Z3_mk_fpa_to_ubvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.UnsignedInt)>>('Z3_mk_fpa_to_ubv');
  late final _Z3_mk_fpa_to_ubv = _Z3_mk_fpa_to_ubvPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Conversion of a floating-point term into a signed bit-vector.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// bit-vector term of size \c sz in signed 2's complement format. If necessary, the result
  /// will be rounded according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param sz size of the resulting bit-vector
  ///
  /// def_API('Z3_mk_fpa_to_sbv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
  Z3_ast Z3_mk_fpa_to_sbv(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    int sz,
  ) {
    return _Z3_mk_fpa_to_sbv(
      c,
      rm,
      t,
      sz,
    );
  }

  late final _Z3_mk_fpa_to_sbvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.UnsignedInt)>>('Z3_mk_fpa_to_sbv');
  late final _Z3_mk_fpa_to_sbv = _Z3_mk_fpa_to_sbvPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Conversion of a floating-point term into a real-numbered term.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// real number. Note that this type of conversion will often result in non-linear
  /// constraints over real terms.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_to_real', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_to_real(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_to_real(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_to_realPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_to_real');
  late final _Z3_mk_fpa_to_real =
      _Z3_mk_fpa_to_realPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Z3-specific floating-point extensions */
  /// /**@{*/
  /// /**
  /// \brief Retrieves the number of bits reserved for the exponent in a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param s FloatingPoint sort
  ///
  /// def_API('Z3_fpa_get_ebits', UINT, (_in(CONTEXT),_in(SORT)))
  int Z3_fpa_get_ebits(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_fpa_get_ebits(
      c,
      s,
    );
  }

  late final _Z3_fpa_get_ebitsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_fpa_get_ebits');
  late final _Z3_fpa_get_ebits =
      _Z3_fpa_get_ebitsPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Retrieves the number of bits reserved for the significand in a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param s FloatingPoint sort
  ///
  /// def_API('Z3_fpa_get_sbits', UINT, (_in(CONTEXT),_in(SORT)))
  int Z3_fpa_get_sbits(
    Z3_context c,
    Z3_sort s,
  ) {
    return _Z3_fpa_get_sbits(
      c,
      s,
    );
  }

  late final _Z3_fpa_get_sbitsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_fpa_get_sbits');
  late final _Z3_fpa_get_sbits =
      _Z3_fpa_get_sbitsPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Checks whether a given floating-point numeral is a NaN.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_nan', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_nan(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_nan(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_nanPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_nan');
  late final _Z3_fpa_is_numeral_nan =
      _Z3_fpa_is_numeral_nanPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is a +oo or -oo.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_inf', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_inf(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_inf(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_infPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_inf');
  late final _Z3_fpa_is_numeral_inf =
      _Z3_fpa_is_numeral_infPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is +zero or -zero.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_zero', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_zero(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_zero(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_zero');
  late final _Z3_fpa_is_numeral_zero =
      _Z3_fpa_is_numeral_zeroPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is normal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_normal', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_normal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_normal(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_normalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_normal');
  late final _Z3_fpa_is_numeral_normal = _Z3_fpa_is_numeral_normalPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is subnormal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_subnormal', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_subnormal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_subnormal(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_subnormalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_subnormal');
  late final _Z3_fpa_is_numeral_subnormal = _Z3_fpa_is_numeral_subnormalPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is positive.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_positive', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_positive(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_positive(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_positivePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_positive');
  late final _Z3_fpa_is_numeral_positive = _Z3_fpa_is_numeral_positivePtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is negative.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_negative', BOOL, (_in(CONTEXT), _in(AST)))
  int Z3_fpa_is_numeral_negative(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_is_numeral_negative(
      c,
      t,
    );
  }

  late final _Z3_fpa_is_numeral_negativePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_negative');
  late final _Z3_fpa_is_numeral_negative = _Z3_fpa_is_numeral_negativePtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the sign of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// Remarks: NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_sign_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_fpa_get_numeral_sign_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_get_numeral_sign_bv(
      c,
      t,
    );
  }

  late final _Z3_fpa_get_numeral_sign_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_sign_bv');
  late final _Z3_fpa_get_numeral_sign_bv = _Z3_fpa_get_numeral_sign_bvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the significand of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// Remarks: NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast Z3_fpa_get_numeral_significand_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_get_numeral_significand_bv(
      c,
      t,
    );
  }

  late final _Z3_fpa_get_numeral_significand_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_significand_bv');
  late final _Z3_fpa_get_numeral_significand_bv =
      _Z3_fpa_get_numeral_significand_bvPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the sign of a floating-point literal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param sgn the retrieved sign
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: sets \c sgn to 0 if `t' is positive and to 1 otherwise, except for
  /// NaN, which is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_sign', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
  int Z3_fpa_get_numeral_sign(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Int> sgn,
  ) {
    return _Z3_fpa_get_numeral_sign(
      c,
      t,
      sgn,
    );
  }

  late final _Z3_fpa_get_numeral_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Int>)>>('Z3_fpa_get_numeral_sign');
  late final _Z3_fpa_get_numeral_sign = _Z3_fpa_get_numeral_signPtr.asFunction<
      int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>();

  /// \brief Return the significand value of a floating-point numeral as a string.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: The significand \c s is always \ccode{0.0 <= s < 2.0}; the resulting string is long
  /// enough to represent the real significand precisely.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string Z3_fpa_get_numeral_significand_string(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_fpa_get_numeral_significand_string(
      c,
      t,
    );
  }

  late final _Z3_fpa_get_numeral_significand_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_significand_string');
  late final _Z3_fpa_get_numeral_significand_string =
      _Z3_fpa_get_numeral_significand_stringPtr.asFunction<
          Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return the significand value of a floating-point numeral as a uint64.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param n pointer to output uint64
  ///
  /// Remarks: This function extracts the significand bits in `t`, without the
  /// hidden bit or normalization. Sets the \c Z3_INVALID_ARG error code if the
  /// significand does not fit into a \c uint64. NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
  int Z3_fpa_get_numeral_significand_uint64(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Uint64> n,
  ) {
    return _Z3_fpa_get_numeral_significand_uint64(
      c,
      t,
      n,
    );
  }

  late final _Z3_fpa_get_numeral_significand_uint64Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>>(
      'Z3_fpa_get_numeral_significand_uint64');
  late final _Z3_fpa_get_numeral_significand_uint64 =
      _Z3_fpa_get_numeral_significand_uint64Ptr.asFunction<
          int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Return the exponent value of a floating-point numeral as a string.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param biased flag to indicate whether the result is in biased representation
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_string', STRING, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_string Z3_fpa_get_numeral_exponent_string(
    Z3_context c,
    Z3_ast t,
    int biased,
  ) {
    return _Z3_fpa_get_numeral_exponent_string(
      c,
      t,
      biased,
    );
  }

  late final _Z3_fpa_get_numeral_exponent_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast, ffi.Int)>>(
      'Z3_fpa_get_numeral_exponent_string');
  late final _Z3_fpa_get_numeral_exponent_string =
      _Z3_fpa_get_numeral_exponent_stringPtr.asFunction<
          Z3_string Function(Z3_context, Z3_ast, int)>();

  /// \brief Return the exponent value of a floating-point numeral as a signed 64-bit integer
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param n exponent
  /// \param biased flag to indicate whether the result is in biased representation
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _in(BOOL)))
  int Z3_fpa_get_numeral_exponent_int64(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Int64> n,
    int biased,
  ) {
    return _Z3_fpa_get_numeral_exponent_int64(
      c,
      t,
      n,
      biased,
    );
  }

  late final _Z3_fpa_get_numeral_exponent_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Int)>>('Z3_fpa_get_numeral_exponent_int64');
  late final _Z3_fpa_get_numeral_exponent_int64 =
      _Z3_fpa_get_numeral_exponent_int64Ptr.asFunction<
          int Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>, int)>();

  /// \brief Retrieves the exponent of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param biased flag to indicate whether the result is in biased representation
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid arguments.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_bv', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_ast Z3_fpa_get_numeral_exponent_bv(
    Z3_context c,
    Z3_ast t,
    int biased,
  ) {
    return _Z3_fpa_get_numeral_exponent_bv(
      c,
      t,
      biased,
    );
  }

  late final _Z3_fpa_get_numeral_exponent_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, ffi.Int)>>(
          'Z3_fpa_get_numeral_exponent_bv');
  late final _Z3_fpa_get_numeral_exponent_bv =
      _Z3_fpa_get_numeral_exponent_bvPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort. The size of the resulting bit-vector is automatically
  /// determined.
  ///
  /// Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion
  /// knows only one NaN and it will always produce the same bit-vector representation of
  /// that NaN.
  ///
  /// def_API('Z3_mk_fpa_to_ieee_bv', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast Z3_mk_fpa_to_ieee_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _Z3_mk_fpa_to_ieee_bv(
      c,
      t,
    );
  }

  late final _Z3_mk_fpa_to_ieee_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_to_ieee_bv');
  late final _Z3_mk_fpa_to_ieee_bv = _Z3_mk_fpa_to_ieee_bvPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of \ccode{sig * 2^exp} into a
  /// floating-point term of sort \c s. If necessary, the result will be rounded
  /// according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param exp exponent term of Int sort
  /// \param sig significand term of Real sort
  /// \param s FloatingPoint sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c exp must be of int sort, \c sig must be of real sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_int_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(SORT)))
  Z3_ast Z3_mk_fpa_to_fp_int_real(
    Z3_context c,
    Z3_ast rm,
    Z3_ast exp,
    Z3_ast sig,
    Z3_sort s,
  ) {
    return _Z3_mk_fpa_to_fp_int_real(
      c,
      rm,
      exp,
      sig,
      s,
    );
  }

  late final _Z3_mk_fpa_to_fp_int_realPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast,
              Z3_sort)>>('Z3_mk_fpa_to_fp_int_real');
  late final _Z3_mk_fpa_to_fp_int_real =
      _Z3_mk_fpa_to_fp_int_realPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_sort)>();

  /// @name Spacer facilities */
  /// /**@{*/
  /// /**
  /// \brief Pose a query against the asserted rules at the given level.
  ///
  /// \code
  /// query ::= (exists (bound-vars) query)
  /// |  literals
  /// \endcode
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query_from_lvl', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(UINT)))
  int Z3_fixedpoint_query_from_lvl(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast query,
    int lvl,
  ) {
    return _Z3_fixedpoint_query_from_lvl(
      c,
      d,
      query,
      lvl,
    );
  }

  late final _Z3_fixedpoint_query_from_lvlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_fixedpoint, Z3_ast,
              ffi.UnsignedInt)>>('Z3_fixedpoint_query_from_lvl');
  late final _Z3_fixedpoint_query_from_lvl = _Z3_fixedpoint_query_from_lvlPtr
      .asFunction<int Function(Z3_context, Z3_fixedpoint, Z3_ast, int)>();

  /// \brief Retrieve a bottom-up (from query) sequence of ground facts
  ///
  /// The previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
  ///
  /// def_API('Z3_fixedpoint_get_ground_sat_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast Z3_fixedpoint_get_ground_sat_answer(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_ground_sat_answer(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_ground_sat_answerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_ground_sat_answer');
  late final _Z3_fixedpoint_get_ground_sat_answer =
      _Z3_fixedpoint_get_ground_sat_answerPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Obtain the list of rules along the counterexample trace.
  ///
  /// def_API('Z3_fixedpoint_get_rules_along_trace', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast_vector Z3_fixedpoint_get_rules_along_trace(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_rules_along_trace(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_rules_along_tracePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context,
              Z3_fixedpoint)>>('Z3_fixedpoint_get_rules_along_trace');
  late final _Z3_fixedpoint_get_rules_along_trace =
      _Z3_fixedpoint_get_rules_along_tracePtr.asFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Obtain the list of rules along the counterexample trace.
  ///
  /// def_API('Z3_fixedpoint_get_rule_names_along_trace', SYMBOL, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_symbol Z3_fixedpoint_get_rule_names_along_trace(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _Z3_fixedpoint_get_rule_names_along_trace(
      c,
      d,
    );
  }

  late final _Z3_fixedpoint_get_rule_names_along_tracePtr = _lookup<
          ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_rule_names_along_trace');
  late final _Z3_fixedpoint_get_rule_names_along_trace =
      _Z3_fixedpoint_get_rule_names_along_tracePtr.asFunction<
          Z3_symbol Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Add an invariant for the predicate \c pred.
  /// Add an assumed invariant of predicate \c pred.
  ///
  /// Note: this functionality is Spacer specific.
  ///
  /// def_API('Z3_fixedpoint_add_invariant', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(AST)))
  void Z3_fixedpoint_add_invariant(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
    Z3_ast property,
  ) {
    return _Z3_fixedpoint_add_invariant(
      c,
      d,
      pred,
      property,
    );
  }

  late final _Z3_fixedpoint_add_invariantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_func_decl,
              Z3_ast)>>('Z3_fixedpoint_add_invariant');
  late final _Z3_fixedpoint_add_invariant =
      _Z3_fixedpoint_add_invariantPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, Z3_ast)>();

  /// Retrieve reachable states of a predicate.
  /// Note: this functionality is Spacer specific.
  ///
  /// def_API('Z3_fixedpoint_get_reachable', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  Z3_ast Z3_fixedpoint_get_reachable(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
  ) {
    return _Z3_fixedpoint_get_reachable(
      c,
      d,
      pred,
    );
  }

  late final _Z3_fixedpoint_get_reachablePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_get_reachable');
  late final _Z3_fixedpoint_get_reachable = _Z3_fixedpoint_get_reachablePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// \brief Project variables given a model
  ///
  /// def_API('Z3_qe_model_project', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST)))
  Z3_ast Z3_qe_model_project(
    Z3_context c,
    Z3_model m,
    int num_bounds,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
  ) {
    return _Z3_qe_model_project(
      c,
      m,
      num_bounds,
      bound,
      body,
    );
  }

  late final _Z3_qe_model_projectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_model, ffi.UnsignedInt,
              ffi.Pointer<Z3_app>, Z3_ast)>>('Z3_qe_model_project');
  late final _Z3_qe_model_project = _Z3_qe_model_projectPtr.asFunction<
      Z3_ast Function(
          Z3_context, Z3_model, int, ffi.Pointer<Z3_app>, Z3_ast)>();

  /// \brief Project variables given a model
  ///
  /// def_API('Z3_qe_model_project_skolem', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST), _in(AST_MAP)))
  Z3_ast Z3_qe_model_project_skolem(
    Z3_context c,
    Z3_model m,
    int num_bounds,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
    Z3_ast_map map,
  ) {
    return _Z3_qe_model_project_skolem(
      c,
      m,
      num_bounds,
      bound,
      body,
      map,
    );
  }

  late final _Z3_qe_model_project_skolemPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              Z3_model,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              Z3_ast,
              Z3_ast_map)>>('Z3_qe_model_project_skolem');
  late final _Z3_qe_model_project_skolem =
      _Z3_qe_model_project_skolemPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_model, int, ffi.Pointer<Z3_app>,
              Z3_ast, Z3_ast_map)>();

  /// \brief Extrapolates a model of a formula
  ///
  /// def_API('Z3_model_extrapolate', AST, (_in(CONTEXT), _in(MODEL), _in(AST)))
  Z3_ast Z3_model_extrapolate(
    Z3_context c,
    Z3_model m,
    Z3_ast fml,
  ) {
    return _Z3_model_extrapolate(
      c,
      m,
      fml,
    );
  }

  late final _Z3_model_extrapolatePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_model, Z3_ast)>>(
      'Z3_model_extrapolate');
  late final _Z3_model_extrapolate = _Z3_model_extrapolatePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_model, Z3_ast)>();

  /// \brief Best-effort quantifier elimination
  ///
  /// def_API ('Z3_qe_lite', AST, (_in(CONTEXT), _in(AST_VECTOR), _in(AST)))
  Z3_ast Z3_qe_lite(
    Z3_context c,
    Z3_ast_vector vars,
    Z3_ast body,
  ) {
    return _Z3_qe_lite(
      c,
      vars,
      body,
    );
  }

  late final _Z3_qe_litePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast_vector, Z3_ast)>>('Z3_qe_lite');
  late final _Z3_qe_lite = _Z3_qe_litePtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast_vector, Z3_ast)>();
}

class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

class __mbstate_t extends ffi.Struct {
  @ffi.Int()
  external int __count;

  external UnnamedUnion1 __value;
}

class UnnamedUnion1 extends ffi.Union {
  @ffi.UnsignedInt()
  external int __wch;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __wchb;
}

class _G_fpos_t extends ffi.Struct {
  @__off_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off_t = ffi.Long;

class _G_fpos64_t extends ffi.Struct {
  @__off64_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off64_t = ffi.Long;

class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Int()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Char()
  external int _unused2;
}

class _IO_marker extends ffi.Opaque {}

typedef _IO_lock_t = ffi.Void;

class _IO_codecvt extends ffi.Opaque {}

class _IO_wide_data extends ffi.Opaque {}

typedef FILE = _IO_FILE;
typedef __ssize_t = ffi.Long;
typedef fpos_t = __fpos_t;
typedef __fpos_t = _G_fpos_t;

class _Z3_symbol extends ffi.Opaque {}

class _Z3_literals extends ffi.Opaque {}

class _Z3_config extends ffi.Opaque {}

class _Z3_context extends ffi.Opaque {}

class _Z3_sort extends ffi.Opaque {}

class _Z3_func_decl extends ffi.Opaque {}

class _Z3_ast extends ffi.Opaque {}

class _Z3_app extends ffi.Opaque {}

class _Z3_pattern extends ffi.Opaque {}

class _Z3_model extends ffi.Opaque {}

class _Z3_constructor extends ffi.Opaque {}

class _Z3_constructor_list extends ffi.Opaque {}

class _Z3_params extends ffi.Opaque {}

class _Z3_param_descrs extends ffi.Opaque {}

class _Z3_goal extends ffi.Opaque {}

class _Z3_tactic extends ffi.Opaque {}

class _Z3_probe extends ffi.Opaque {}

class _Z3_stats extends ffi.Opaque {}

class _Z3_solver extends ffi.Opaque {}

class _Z3_solver_callback extends ffi.Opaque {}

class _Z3_ast_vector extends ffi.Opaque {}

class _Z3_ast_map extends ffi.Opaque {}

class _Z3_apply_result extends ffi.Opaque {}

class _Z3_func_interp extends ffi.Opaque {}

class _Z3_func_entry extends ffi.Opaque {}

class _Z3_fixedpoint extends ffi.Opaque {}

class _Z3_optimize extends ffi.Opaque {}

class _Z3_rcf_num extends ffi.Opaque {}

/// \brief Lifted Boolean type: \c false, \c undefined, \c true.
abstract class Z3_lbool {
  static const int Z3_L_FALSE = -1;
  static const int Z3_L_UNDEF = 0;
  static const int Z3_L_TRUE = 1;
}

/// \brief The different kinds of symbol.
/// In Z3, a symbol can be represented using integers and strings (See #Z3_get_symbol_kind).
///
/// \sa Z3_mk_int_symbol
/// \sa Z3_mk_string_symbol
abstract class Z3_symbol_kind {
  static const int Z3_INT_SYMBOL = 0;
  static const int Z3_STRING_SYMBOL = 1;
}

/// \brief The different kinds of parameters that can be associated with function symbols.
/// \sa Z3_get_decl_num_parameters
/// \sa Z3_get_decl_parameter_kind
///
/// - Z3_PARAMETER_INT is used for integer parameters.
/// - Z3_PARAMETER_DOUBLE is used for double parameters.
/// - Z3_PARAMETER_RATIONAL is used for parameters that are rational numbers.
/// - Z3_PARAMETER_SYMBOL is used for parameters that are symbols.
/// - Z3_PARAMETER_SORT is used for sort parameters.
/// - Z3_PARAMETER_AST is used for expression parameters.
/// - Z3_PARAMETER_FUNC_DECL is used for function declaration parameters.
abstract class Z3_parameter_kind {
  static const int Z3_PARAMETER_INT = 0;
  static const int Z3_PARAMETER_DOUBLE = 1;
  static const int Z3_PARAMETER_RATIONAL = 2;
  static const int Z3_PARAMETER_SYMBOL = 3;
  static const int Z3_PARAMETER_SORT = 4;
  static const int Z3_PARAMETER_AST = 5;
  static const int Z3_PARAMETER_FUNC_DECL = 6;
}

/// \brief The different kinds of Z3 types (See #Z3_get_sort_kind).
abstract class Z3_sort_kind {
  static const int Z3_UNINTERPRETED_SORT = 0;
  static const int Z3_BOOL_SORT = 1;
  static const int Z3_INT_SORT = 2;
  static const int Z3_REAL_SORT = 3;
  static const int Z3_BV_SORT = 4;
  static const int Z3_ARRAY_SORT = 5;
  static const int Z3_DATATYPE_SORT = 6;
  static const int Z3_RELATION_SORT = 7;
  static const int Z3_FINITE_DOMAIN_SORT = 8;
  static const int Z3_FLOATING_POINT_SORT = 9;
  static const int Z3_ROUNDING_MODE_SORT = 10;
  static const int Z3_SEQ_SORT = 11;
  static const int Z3_RE_SORT = 12;
  static const int Z3_CHAR_SORT = 13;
  static const int Z3_UNKNOWN_SORT = 1000;
}

/// \brief
/// The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
///
/// - Z3_APP_AST:            constant and applications
/// - Z3_NUMERAL_AST:        numeral constants
/// - Z3_VAR_AST:            bound variables
/// - Z3_QUANTIFIER_AST:     quantifiers
/// - Z3_SORT_AST:           sort
/// - Z3_FUNC_DECL_AST:      function declaration
/// - Z3_UNKNOWN_AST:        internal
abstract class Z3_ast_kind {
  static const int Z3_NUMERAL_AST = 0;
  static const int Z3_APP_AST = 1;
  static const int Z3_VAR_AST = 2;
  static const int Z3_QUANTIFIER_AST = 3;
  static const int Z3_SORT_AST = 4;
  static const int Z3_FUNC_DECL_AST = 5;
  static const int Z3_UNKNOWN_AST = 1000;
}

/// \brief The different kinds of interpreted function kinds.
///
/// - Z3_OP_TRUE The constant true.
///
/// - Z3_OP_FALSE The constant false.
///
/// - Z3_OP_EQ The equality predicate.
///
/// - Z3_OP_DISTINCT The n-ary distinct predicate (every argument is mutually distinct).
///
/// - Z3_OP_ITE The ternary if-then-else term.
///
/// - Z3_OP_AND n-ary conjunction.
///
/// - Z3_OP_OR n-ary disjunction.
///
/// - Z3_OP_IFF equivalence (binary).
///
/// - Z3_OP_XOR Exclusive or.
///
/// - Z3_OP_NOT Negation.
///
/// - Z3_OP_IMPLIES Implication.
///
/// - Z3_OP_OEQ Binary equivalence modulo namings. This binary predicate is used in proof terms.
/// It captures equisatisfiability and equivalence modulo renamings.
///
/// - Z3_OP_ANUM Arithmetic numeral.
///
/// - Z3_OP_AGNUM Arithmetic algebraic numeral. Algebraic numbers are used to represent irrational numbers in Z3.
///
/// - Z3_OP_LE <=.
///
/// - Z3_OP_GE >=.
///
/// - Z3_OP_LT <.
///
/// - Z3_OP_GT >.
///
/// - Z3_OP_ADD Addition - Binary.
///
/// - Z3_OP_SUB Binary subtraction.
///
/// - Z3_OP_UMINUS Unary minus.
///
/// - Z3_OP_MUL Multiplication - Binary.
///
/// - Z3_OP_DIV Division - Binary.
///
/// - Z3_OP_IDIV Integer division - Binary.
///
/// - Z3_OP_REM Remainder - Binary.
///
/// - Z3_OP_MOD Modulus - Binary.
///
/// - Z3_OP_TO_REAL Coercion of integer to real - Unary.
///
/// - Z3_OP_TO_INT Coercion of real to integer - Unary.
///
/// - Z3_OP_IS_INT Check if real is also an integer - Unary.
///
/// - Z3_OP_POWER Power operator x^y.
///
/// - Z3_OP_STORE Array store. It satisfies select(store(a,i,v),j) = if i = j then v else select(a,j).
/// Array store takes at least 3 arguments.
///
/// - Z3_OP_SELECT Array select.
///
/// - Z3_OP_CONST_ARRAY The constant array. For example, select(const(v),i) = v holds for every v and i. The function is unary.
///
/// - Z3_OP_ARRAY_DEFAULT Default value of arrays. For example default(const(v)) = v. The function is unary.
///
/// - Z3_OP_ARRAY_MAP Array map operator.
/// It satisfies map[f](a1,..,a_n)[i] = f(a1[i],...,a_n[i]) for every i.
///
/// - Z3_OP_SET_UNION Set union between two Boolean arrays (two arrays whose range type is Boolean). The function is binary.
///
/// - Z3_OP_SET_INTERSECT Set intersection between two Boolean arrays. The function is binary.
///
/// - Z3_OP_SET_DIFFERENCE Set difference between two Boolean arrays. The function is binary.
///
/// - Z3_OP_SET_COMPLEMENT Set complement of a Boolean array. The function is unary.
///
/// - Z3_OP_SET_SUBSET Subset predicate between two Boolean arrays. The relation is binary.
///
/// - Z3_OP_AS_ARRAY An array value that behaves as the function graph of the
/// function passed as parameter.
///
/// - Z3_OP_ARRAY_EXT Array extensionality function. It takes two arrays as arguments and produces an index, such that the arrays
/// are different if they are different on the index.
///
/// - Z3_OP_BNUM Bit-vector numeral.
///
/// - Z3_OP_BIT1 One bit bit-vector.
///
/// - Z3_OP_BIT0 Zero bit bit-vector.
///
/// - Z3_OP_BNEG Unary minus.
///
/// - Z3_OP_BADD Binary addition.
///
/// - Z3_OP_BSUB Binary subtraction.
///
/// - Z3_OP_BMUL Binary multiplication.
///
/// - Z3_OP_BSDIV Binary signed division.
///
/// - Z3_OP_BUDIV Binary unsigned division.
///
/// - Z3_OP_BSREM Binary signed remainder.
///
/// - Z3_OP_BUREM Binary unsigned remainder.
///
/// - Z3_OP_BSMOD Binary signed modulus.
///
/// - Z3_OP_BSDIV0 Unary function. bsdiv(x,0) is congruent to bsdiv0(x).
///
/// - Z3_OP_BUDIV0 Unary function. budiv(x,0) is congruent to budiv0(x).
///
/// - Z3_OP_BSREM0 Unary function. bsrem(x,0) is congruent to bsrem0(x).
///
/// - Z3_OP_BUREM0 Unary function. burem(x,0) is congruent to burem0(x).
///
/// - Z3_OP_BSMOD0 Unary function. bsmod(x,0) is congruent to bsmod0(x).
///
/// - Z3_OP_ULEQ Unsigned bit-vector <= - Binary relation.
///
/// - Z3_OP_SLEQ Signed bit-vector  <= - Binary relation.
///
/// - Z3_OP_UGEQ Unsigned bit-vector  >= - Binary relation.
///
/// - Z3_OP_SGEQ Signed bit-vector  >= - Binary relation.
///
/// - Z3_OP_ULT Unsigned bit-vector  < - Binary relation.
///
/// - Z3_OP_SLT Signed bit-vector < - Binary relation.
///
/// - Z3_OP_UGT Unsigned bit-vector > - Binary relation.
///
/// - Z3_OP_SGT Signed bit-vector > - Binary relation.
///
/// - Z3_OP_BAND Bit-wise and - Binary.
///
/// - Z3_OP_BOR Bit-wise or - Binary.
///
/// - Z3_OP_BNOT Bit-wise not - Unary.
///
/// - Z3_OP_BXOR Bit-wise xor - Binary.
///
/// - Z3_OP_BNAND Bit-wise nand - Binary.
///
/// - Z3_OP_BNOR Bit-wise nor - Binary.
///
/// - Z3_OP_BXNOR Bit-wise xnor - Binary.
///
/// - Z3_OP_CONCAT Bit-vector concatenation - Binary.
///
/// - Z3_OP_SIGN_EXT Bit-vector sign extension.
///
/// - Z3_OP_ZERO_EXT Bit-vector zero extension.
///
/// - Z3_OP_EXTRACT Bit-vector extraction.
///
/// - Z3_OP_REPEAT Repeat bit-vector n times.
///
/// - Z3_OP_BREDOR Bit-vector reduce or - Unary.
///
/// - Z3_OP_BREDAND Bit-vector reduce and - Unary.
///
/// - Z3_OP_BCOMP .
///
/// - Z3_OP_BSHL Shift left.
///
/// - Z3_OP_BLSHR Logical shift right.
///
/// - Z3_OP_BASHR Arithmetical shift right.
///
/// - Z3_OP_ROTATE_LEFT Left rotation.
///
/// - Z3_OP_ROTATE_RIGHT Right rotation.
///
/// - Z3_OP_EXT_ROTATE_LEFT (extended) Left rotation. Similar to Z3_OP_ROTATE_LEFT, but it is a binary operator instead of a parametric one.
///
/// - Z3_OP_EXT_ROTATE_RIGHT (extended) Right rotation. Similar to Z3_OP_ROTATE_RIGHT, but it is a binary operator instead of a parametric one.
///
/// - Z3_OP_INT2BV Coerce integer to bit-vector. NB. This function
/// is not supported by the decision procedures. Only the most
/// rudimentary simplification rules are applied to this function.
///
/// - Z3_OP_BV2INT Coerce bit-vector to integer. NB. This function
/// is not supported by the decision procedures. Only the most
/// rudimentary simplification rules are applied to this function.
///
/// - Z3_OP_CARRY Compute the carry bit in a full-adder.
/// The meaning is given by the equivalence
/// (carry l1 l2 l3) <=> (or (and l1 l2) (and l1 l3) (and l2 l3)))
///
/// - Z3_OP_XOR3 Compute ternary XOR.
/// The meaning is given by the equivalence
/// (xor3 l1 l2 l3) <=> (xor (xor l1 l2) l3)
///
/// - Z3_OP_BSMUL_NO_OVFL: a predicate to check that bit-wise signed multiplication does not overflow.
/// Signed multiplication overflows if the operands have the same sign and the result of multiplication
/// does not fit within the available bits. \sa Z3_mk_bvmul_no_overflow.
///
/// - Z3_OP_BUMUL_NO_OVFL: check that bit-wise unsigned multiplication does not overflow.
/// Unsigned multiplication overflows if the result does not fit within the available bits.
/// \sa Z3_mk_bvmul_no_overflow.
///
/// - Z3_OP_BSMUL_NO_UDFL: check that bit-wise signed multiplication does not underflow.
/// Signed multiplication underflows if the operands have opposite signs and the result of multiplication
/// does not fit within the available bits. Z3_mk_bvmul_no_underflow.
///
/// - Z3_OP_BSDIV_I: Binary signed division.
/// It has the same semantics as Z3_OP_BSDIV, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BUDIV_I: Binary unsigned division.
/// It has the same semantics as Z3_OP_BUDIV, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BSREM_I: Binary signed remainder.
/// It has the same semantics as Z3_OP_BSREM, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BUREM_I: Binary unsigned remainder.
/// It has the same semantics as Z3_OP_BUREM, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BSMOD_I: Binary signed modulus.
/// It has the same semantics as Z3_OP_BSMOD, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_PR_UNDEF: Undef/Null proof object.
///
/// - Z3_OP_PR_TRUE: Proof for the expression 'true'.
///
/// - Z3_OP_PR_ASSERTED: Proof for a fact asserted by the user.
///
/// - Z3_OP_PR_GOAL: Proof for a fact (tagged as goal) asserted by the user.
///
/// - Z3_OP_PR_MODUS_PONENS: Given a proof for p and a proof for (implies p q), produces a proof for q.
///
/// T1: p
/// T2: (implies p q)
/// [mp T1 T2]: q
///
/// The second antecedents may also be a proof for (iff p q).
///
/// - Z3_OP_PR_REFLEXIVITY: A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
/// The only reflexive relations that are used are
/// equivalence modulo namings, equality and equivalence.
/// That is, R is either '~', '=' or 'iff'.
///
/// - Z3_OP_PR_SYMMETRY: Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
/// \nicebox{
/// T1: (R t s)
/// [symmetry T1]: (R s t)
/// }
/// T1 is the antecedent of this proof object.
///
/// - Z3_OP_PR_TRANSITIVITY: Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
/// for (R t u).
/// \nicebox{
/// T1: (R t s)
/// T2: (R s u)
/// [trans T1 T2]: (R t u)
/// }
///
/// - Z3_OP_PR_TRANSITIVITY_STAR: Condensed transitivity proof.
/// It combines several symmetry and transitivity proofs. Example:
/// \nicebox{
/// T1: (R a b)
/// T2: (R c b)
/// T3: (R c d)
/// [trans* T1 T2 T3]: (R a d)
/// }
/// R must be a symmetric and transitive relation.
///
/// Assuming that this proof object is a proof for (R s t), then
/// a proof checker must check if it is possible to prove (R s t)
/// using the antecedents, symmetry and transitivity.  That is,
/// if there is a path from s to t, if we view every
/// antecedent (R a b) as an edge between a and b.
///
/// - Z3_OP_PR_MONOTONICITY: Monotonicity proof object.
///
/// T1: (R t_1 s_1)
/// ...
/// Tn: (R t_n s_n)
/// [monotonicity T1 ... Tn]: (R (f t_1 ... t_n) (f s_1 ... s_n))
///
/// Remark: if t_i == s_i, then the antecedent Ti is suppressed.
/// That is, reflexivity proofs are suppressed to save space.
///
/// - Z3_OP_PR_QUANT_INTRO: Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).
///
/// T1: (~ p q)
/// [quant-intro T1]: (~ (forall (x) p) (forall (x) q))
///
/// - Z3_OP_PR_BIND: Given a proof p, produces a proof of lambda x . p, where x are free variables in p.
///
/// T1: f
/// [proof-bind T1] forall (x) f
///
/// - Z3_OP_PR_DISTRIBUTIVITY: Distributivity proof object.
/// Given that f (= or) distributes over g (= and), produces a proof for
/// \nicebox{
/// (= (f a (g c d))
/// (g (f a c) (f a d)))
/// }
/// If f and g are associative, this proof also justifies the following equality:
/// \nicebox{
/// (= (f (g a b) (g c d))
/// (g (f a c) (f a d) (f b c) (f b d)))
/// }
/// where each f and g can have arbitrary number of arguments.
///
/// This proof object has no antecedents.
/// Remark. This rule is used by the CNF conversion pass and
/// instantiated by f = or, and g = and.
///
/// - Z3_OP_PR_AND_ELIM: Given a proof for (and l_1 ... l_n), produces a proof for l_i
///
/// T1: (and l_1 ... l_n)
/// [and-elim T1]: l_i
///
/// - Z3_OP_PR_NOT_OR_ELIM: Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).
///
/// T1: (not (or l_1 ... l_n))
/// [not-or-elim T1]: (not l_i)
///
/// - Z3_OP_PR_REWRITE: A proof for a local rewriting step (= t s).
/// The head function symbol of t is interpreted.
///
/// This proof object has no antecedents.
/// The conclusion of a rewrite rule is either an equality (= t s),
/// an equivalence (iff t s), or equi-satisfiability (~ t s).
/// Remark: if f is bool, then = is iff.
/// Examples:
/// \nicebox{
/// (= (+ x 0) x)
/// (= (+ x 1 2) (+ 3 x))
/// (iff (or x false) x)
/// }
///
/// - Z3_OP_PR_REWRITE_STAR: A proof for rewriting an expression t into an expression s.
/// This proof object can have n antecedents.
/// The antecedents are proofs for equalities used as substitution rules.
/// The proof rule is used in a few cases. The cases are:
/// - When applying contextual simplification (CONTEXT_SIMPLIFIER=true)
/// - When converting bit-vectors to Booleans (BIT2BOOL=true)
///
/// - Z3_OP_PR_PULL_QUANT: A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.
///
/// - Z3_OP_PR_PUSH_QUANT: A proof for:
/// \nicebox{
/// (iff (forall (x_1 ... x_m) (and p_1[x_1 ... x_m] ... p_n[x_1 ... x_m]))
/// (and (forall (x_1 ... x_m) p_1[x_1 ... x_m])
/// ...
/// (forall (x_1 ... x_m) p_n[x_1 ... x_m])))
/// }
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_ELIM_UNUSED_VARS:
/// A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p[x_1 ... x_n])
/// (forall (x_1 ... x_n) p[x_1 ... x_n]))
///
/// It is used to justify the elimination of unused variables.
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_DER: A proof for destructive equality resolution:
/// (iff (forall (x) (or (not (= x t)) P[x])) P[t])
/// if x does not occur in t.
///
/// This proof object has no antecedents.
///
/// Several variables can be eliminated simultaneously.
///
/// - Z3_OP_PR_QUANT_INST: A proof of (or (not (forall (x) (P x))) (P a))
///
/// - Z3_OP_PR_HYPOTHESIS: Mark a hypothesis in a natural deduction style proof.
///
/// - Z3_OP_PR_LEMMA:
///
/// T1: false
/// [lemma T1]: (or (not l_1) ... (not l_n))
///
/// This proof object has one antecedent: a hypothetical proof for false.
/// It converts the proof in a proof for (or (not l_1) ... (not l_n)),
/// when T1 contains the open hypotheses: l_1, ..., l_n.
/// The hypotheses are closed after an application of a lemma.
/// Furthermore, there are no other open hypotheses in the subtree covered by
/// the lemma.
///
/// - Z3_OP_PR_UNIT_RESOLUTION:
/// \nicebox{
/// T1:      (or l_1 ... l_n l_1' ... l_m')
/// T2:      (not l_1)
/// ...
/// T(n+1):  (not l_n)
/// [unit-resolution T1 ... T(n+1)]: (or l_1' ... l_m')
/// }
///
/// - Z3_OP_PR_IFF_TRUE:
/// \nicebox{
/// T1: p
/// [iff-true T1]: (iff p true)
/// }
///
/// - Z3_OP_PR_IFF_FALSE:
/// \nicebox{
/// T1: (not p)
/// [iff-false T1]: (iff p false)
/// }
///
/// - Z3_OP_PR_COMMUTATIVITY:
///
/// [comm]: (= (f a b) (f b a))
///
/// f is a commutative operator.
///
/// This proof object has no antecedents.
/// Remark: if f is bool, then = is iff.
///
/// - Z3_OP_PR_DEF_AXIOM: Proof object used to justify Tseitin's like axioms:
/// \nicebox{
/// (or (not (and p q)) p)
/// (or (not (and p q)) q)
/// (or (not (and p q r)) p)
/// (or (not (and p q r)) q)
/// (or (not (and p q r)) r)
/// ...
/// (or (and p q) (not p) (not q))
/// (or (not (or p q)) p q)
/// (or (or p q) (not p))
/// (or (or p q) (not q))
/// (or (not (iff p q)) (not p) q)
/// (or (not (iff p q)) p (not q))
/// (or (iff p q) (not p) (not q))
/// (or (iff p q) p q)
/// (or (not (ite a b c)) (not a) b)
/// (or (not (ite a b c)) a c)
/// (or (ite a b c) (not a) (not b))
/// (or (ite a b c) a (not c))
/// (or (not (not a)) (not a))
/// (or (not a) a)
/// }
/// This proof object has no antecedents.
/// Note: all axioms are propositional tautologies.
/// Note also that 'and' and 'or' can take multiple arguments.
/// You can recover the propositional tautologies by
/// unfolding the Boolean connectives in the axioms a small
/// bounded number of steps (=3).
///
/// - Z3_OP_PR_ASSUMPTION_ADD
/// Clausal proof adding axiom
///
/// - Z3_OP_PR_LEMMA_ADD
/// Clausal proof lemma addition
///
/// - Z3_OP_PR_REDUNDANT_DEL
/// Clausal proof lemma deletion
///
/// - Z3_OP_PR_CLAUSE_TRAIL,
/// Clausal proof trail of additions and deletions
///
/// - Z3_OP_PR_DEF_INTRO: Introduces a name for a formula/term.
/// Suppose e is an expression with free variables x, and def-intro
/// introduces the name n(x). The possible cases are:
///
/// When e is of Boolean type:
/// [def-intro]: (and (or n (not e)) (or (not n) e))
///
/// or:
/// [def-intro]: (or (not n) e)
/// when e only occurs positively.
///
/// When e is of the form (ite cond th el):
/// [def-intro]: (and (or (not cond) (= n th)) (or cond (= n el)))
///
/// Otherwise:
/// [def-intro]: (= n e)
///
/// - Z3_OP_PR_APPLY_DEF:
///
/// [apply-def T1]: F ~ n
///
/// F is 'equivalent' to n, given that T1 is a proof that
/// n is a name for F.
///
/// - Z3_OP_PR_IFF_OEQ:
///
/// T1: (iff p q)
/// [iff~ T1]: (~ p q)
///
/// - Z3_OP_PR_NNF_POS: Proof for a (positive) NNF step. Example:
///
/// T1: (not s_1) ~ r_1
/// T2: (not s_2) ~ r_2
/// T3: s_1 ~ r_1'
/// T4: s_2 ~ r_2'
/// [nnf-pos T1 T2 T3 T4]: (~ (iff s_1 s_2) (and (or r_1 r_2') (or r_1' r_2)))
///
/// The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
/// (a) When creating the NNF of a positive force quantifier.
/// The quantifier is retained (unless the bound variables are eliminated).
/// Example
///
/// T1: q ~ q_new
/// [nnf-pos T1]: (~ (forall (x T) q) (forall (x T) q_new))
///
/// (b) When recursively creating NNF over Boolean formulas, where the top-level
/// connective is changed during NNF conversion. The relevant Boolean connectives
/// for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
/// NNF_NEG furthermore handles the case where negation is pushed
/// over Boolean connectives 'and' and 'or'.
///
///
/// - Z3_OP_PR_NNF_NEG: Proof for a (negative) NNF step. Examples:
///
/// T1: (not s_1) ~ r_1
/// ...
/// Tn: (not s_n) ~ r_n
/// [nnf-neg T1 ... Tn]: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
///
/// and
///
/// T1: (not s_1) ~ r_1
/// ...
/// Tn: (not s_n) ~ r_n
/// [nnf-neg T1 ... Tn]: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
///
/// and
///
/// T1: (not s_1) ~ r_1
/// T2: (not s_2) ~ r_2
/// T3: s_1 ~ r_1'
/// T4: s_2 ~ r_2'
/// [nnf-neg T1 T2 T3 T4]: (~ (not (iff s_1 s_2))
/// (and (or r_1 r_2) (or r_1' r_2')))
///
/// - Z3_OP_PR_SKOLEMIZE: Proof for:
///
/// [sk]: (~ (not (forall x (p x y))) (not (p (sk y) y)))
/// [sk]: (~ (exists x (p x y)) (p (sk y) y))
///
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_MODUS_PONENS_OEQ: Modus ponens style rule for equi-satisfiability.
///
/// T1: p
/// T2: (~ p q)
/// [mp~ T1 T2]: q
///
/// - Z3_OP_PR_TH_LEMMA: Generic proof for theory lemmas.
/// The theory lemma function comes with one or more parameters.
/// The first parameter indicates the name of the theory.
/// For the theory of arithmetic, additional parameters provide hints for
/// checking the theory lemma.
/// The hints for arithmetic are:
///
/// - farkas - followed by rational coefficients. Multiply the coefficients to the
/// inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.
///
/// - triangle-eq - Indicates a lemma related to the equivalence:
///
/// (iff (= t1 t2) (and (<= t1 t2) (<= t2 t1)))
///
/// - gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.
///
///
/// - Z3_OP_PR_HYPER_RESOLVE: Hyper-resolution rule.
///
/// The premises of the rules is a sequence of clauses.
/// The first clause argument is the main clause of the rule.
/// with a literal from the first (main) clause.
///
/// Premises of the rules are of the form
/// \nicebox{
/// (or l0 l1 l2 .. ln)
/// }
/// or
/// \nicebox{
/// (=> (and l1 l2 .. ln) l0)
/// }
/// or in the most general (ground) form:
/// \nicebox{
/// (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln))
/// }
/// In other words we use the following (Prolog style) convention for Horn
/// implications:
/// The head of a Horn implication is position 0,
/// the first conjunct in the body of an implication is position 1
/// the second conjunct in the body of an implication is position 2
///
/// For general implications where the head is a disjunction, the
/// first n positions correspond to the n disjuncts in the head.
/// The next m positions correspond to the m conjuncts in the body.
///
/// The premises can be universally quantified so that the most
/// general non-ground form is:
///
/// \nicebox{
/// (forall (vars) (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln)))
/// }
///
/// The hyper-resolution rule takes a sequence of parameters.
/// The parameters are substitutions of bound variables separated by pairs
/// of literal positions from the main clause and side clause.
///
///
/// - Z3_OP_RA_STORE: Insert a record into a relation.
/// The function takes \c n+1 arguments, where the first argument is the relation and the remaining \c n elements
/// correspond to the \c n columns of the relation.
///
/// - Z3_OP_RA_EMPTY: Creates the empty relation.
///
/// - Z3_OP_RA_IS_EMPTY: Tests if the relation is empty.
///
/// - Z3_OP_RA_JOIN: Create the relational join.
///
/// - Z3_OP_RA_UNION: Create the union or convex hull of two relations.
/// The function takes two arguments.
///
/// - Z3_OP_RA_WIDEN: Widen two relations.
/// The function takes two arguments.
///
/// - Z3_OP_RA_PROJECT: Project the columns (provided as numbers in the parameters).
/// The function takes one argument.
///
/// - Z3_OP_RA_FILTER: Filter (restrict) a relation with respect to a predicate.
/// The first argument is a relation.
/// The second argument is a predicate with free de-Bruijn indices
/// corresponding to the columns of the relation.
/// So the first column in the relation has index 0.
///
/// - Z3_OP_RA_NEGATION_FILTER: Intersect the first relation with respect to negation
/// of the second relation (the function takes two arguments).
/// Logically, the specification can be described by a function
///
/// target = filter_by_negation(pos, neg, columns)
///
/// where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
/// target are elements in x in pos, such that there is no y in neg that agrees with
/// x on the columns c1, d1, .., cN, dN.
///
///
/// - Z3_OP_RA_RENAME: rename columns in the relation.
/// The function takes one argument.
/// The parameters contain the renaming as a cycle.
///
/// - Z3_OP_RA_COMPLEMENT: Complement the relation.
///
/// - Z3_OP_RA_SELECT: Check if a record is an element of the relation.
/// The function takes \c n+1 arguments, where the first argument is a relation,
/// and the remaining \c n arguments correspond to a record.
///
/// - Z3_OP_RA_CLONE: Create a fresh copy (clone) of a relation.
/// The function is logically the identity, but
/// in the context of a register machine allows
/// for #Z3_OP_RA_UNION to perform destructive updates to the first argument.
///
///
/// - Z3_OP_FD_LT: A less than predicate over the finite domain Z3_FINITE_DOMAIN_SORT.
///
/// - Z3_OP_LABEL: A label (used by the Boogie Verification condition generator).
/// The label has two parameters, a string and a Boolean polarity.
/// It takes one argument, a formula.
///
/// - Z3_OP_LABEL_LIT: A label literal (used by the Boogie Verification condition generator).
/// A label literal has a set of string parameters. It takes no arguments.
///
/// - Z3_OP_DT_CONSTRUCTOR: datatype constructor.
///
/// - Z3_OP_DT_RECOGNISER: datatype recognizer.
///
/// - Z3_OP_DT_IS: datatype recognizer.
///
/// - Z3_OP_DT_ACCESSOR: datatype accessor.
///
/// - Z3_OP_DT_UPDATE_FIELD: datatype field update.
///
/// - Z3_OP_PB_AT_MOST: Cardinality constraint.
/// E.g., x + y + z <= 2
///
/// - Z3_OP_PB_AT_LEAST: Cardinality constraint.
/// E.g., x + y + z >= 2
///
/// - Z3_OP_PB_LE: Generalized Pseudo-Boolean cardinality constraint.
/// Example  2*x + 3*y <= 4
///
/// - Z3_OP_PB_GE: Generalized Pseudo-Boolean cardinality constraint.
/// Example  2*x + 3*y + 2*z >= 4
///
/// - Z3_OP_PB_EQ: Generalized Pseudo-Boolean equality constraint.
/// Example  2*x + 1*y + 2*z + 1*u = 4
///
/// - Z3_OP_SPECIAL_RELATION_LO: A relation that is a total linear order
///
/// - Z3_OP_SPECIAL_RELATION_PO: A relation that is a partial order
///
/// - Z3_OP_SPECIAL_RELATION_PLO: A relation that is a piecewise linear order
///
/// - Z3_OP_SPECIAL_RELATION_TO: A relation that is a tree order
///
/// - Z3_OP_SPECIAL_RELATION_TC: Transitive closure of a relation
///
/// - Z3_OP_SPECIAL_RELATION_TRC: Transitive reflexive closure of a relation
///
/// - Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN: Floating-point rounding mode RNE
///
/// - Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY: Floating-point rounding mode RNA
///
/// - Z3_OP_FPA_RM_TOWARD_POSITIVE: Floating-point rounding mode RTP
///
/// - Z3_OP_FPA_RM_TOWARD_NEGATIVE: Floating-point rounding mode RTN
///
/// - Z3_OP_FPA_RM_TOWARD_ZERO: Floating-point rounding mode RTZ
///
/// - Z3_OP_FPA_NUM: Floating-point value
///
/// - Z3_OP_FPA_PLUS_INF: Floating-point +oo
///
/// - Z3_OP_FPA_MINUS_INF: Floating-point -oo
///
/// - Z3_OP_FPA_NAN: Floating-point NaN
///
/// - Z3_OP_FPA_PLUS_ZERO: Floating-point +zero
///
/// - Z3_OP_FPA_MINUS_ZERO: Floating-point -zero
///
/// - Z3_OP_FPA_ADD: Floating-point addition
///
/// - Z3_OP_FPA_SUB: Floating-point subtraction
///
/// - Z3_OP_FPA_NEG: Floating-point negation
///
/// - Z3_OP_FPA_MUL: Floating-point multiplication
///
/// - Z3_OP_FPA_DIV: Floating-point division
///
/// - Z3_OP_FPA_REM: Floating-point remainder
///
/// - Z3_OP_FPA_ABS: Floating-point absolute value
///
/// - Z3_OP_FPA_MIN: Floating-point minimum
///
/// - Z3_OP_FPA_MAX: Floating-point maximum
///
/// - Z3_OP_FPA_FMA: Floating-point fused multiply-add
///
/// - Z3_OP_FPA_SQRT: Floating-point square root
///
/// - Z3_OP_FPA_ROUND_TO_INTEGRAL: Floating-point round to integral
///
/// - Z3_OP_FPA_EQ: Floating-point equality
///
/// - Z3_OP_FPA_LT: Floating-point less than
///
/// - Z3_OP_FPA_GT: Floating-point greater than
///
/// - Z3_OP_FPA_LE: Floating-point less than or equal
///
/// - Z3_OP_FPA_GE: Floating-point greater than or equal
///
/// - Z3_OP_FPA_IS_NAN: Floating-point isNaN
///
/// - Z3_OP_FPA_IS_INF: Floating-point isInfinite
///
/// - Z3_OP_FPA_IS_ZERO: Floating-point isZero
///
/// - Z3_OP_FPA_IS_NORMAL: Floating-point isNormal
///
/// - Z3_OP_FPA_IS_SUBNORMAL: Floating-point isSubnormal
///
/// - Z3_OP_FPA_IS_NEGATIVE: Floating-point isNegative
///
/// - Z3_OP_FPA_IS_POSITIVE: Floating-point isPositive
///
/// - Z3_OP_FPA_FP: Floating-point constructor from 3 bit-vectors
///
/// - Z3_OP_FPA_TO_FP: Floating-point conversion (various)
///
/// - Z3_OP_FPA_TO_FP_UNSIGNED: Floating-point conversion from unsigned bit-vector
///
/// - Z3_OP_FPA_TO_UBV: Floating-point conversion to unsigned bit-vector
///
/// - Z3_OP_FPA_TO_SBV: Floating-point conversion to signed bit-vector
///
/// - Z3_OP_FPA_TO_REAL: Floating-point conversion to real number
///
/// - Z3_OP_FPA_TO_IEEE_BV: Floating-point conversion to IEEE-754 bit-vector
///
/// - Z3_OP_FPA_BVWRAP: (Implicitly) represents the internal bitvector-
/// representation of a floating-point term (used for the lazy encoding
/// of non-relevant terms in theory_fpa)
///
/// - Z3_OP_FPA_BV2RM: Conversion of a 3-bit bit-vector term to a
/// floating-point rounding-mode term
///
/// The conversion uses the following values:
/// 0 = 000 = Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN,
/// 1 = 001 = Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY,
/// 2 = 010 = Z3_OP_FPA_RM_TOWARD_POSITIVE,
/// 3 = 011 = Z3_OP_FPA_RM_TOWARD_NEGATIVE,
/// 4 = 100 = Z3_OP_FPA_RM_TOWARD_ZERO.
///
/// - Z3_OP_INTERNAL: internal (often interpreted) symbol, but no additional
/// information is exposed. Tools may use the string representation of the
/// function declaration to obtain more information.
///
/// - Z3_OP_RECURSIVE: function declared as recursive
///
/// - Z3_OP_UNINTERPRETED: kind used for uninterpreted symbols.
abstract class Z3_decl_kind {
  static const int Z3_OP_TRUE = 256;
  static const int Z3_OP_FALSE = 257;
  static const int Z3_OP_EQ = 258;
  static const int Z3_OP_DISTINCT = 259;
  static const int Z3_OP_ITE = 260;
  static const int Z3_OP_AND = 261;
  static const int Z3_OP_OR = 262;
  static const int Z3_OP_IFF = 263;
  static const int Z3_OP_XOR = 264;
  static const int Z3_OP_NOT = 265;
  static const int Z3_OP_IMPLIES = 266;
  static const int Z3_OP_OEQ = 267;
  static const int Z3_OP_ANUM = 512;
  static const int Z3_OP_AGNUM = 513;
  static const int Z3_OP_LE = 514;
  static const int Z3_OP_GE = 515;
  static const int Z3_OP_LT = 516;
  static const int Z3_OP_GT = 517;
  static const int Z3_OP_ADD = 518;
  static const int Z3_OP_SUB = 519;
  static const int Z3_OP_UMINUS = 520;
  static const int Z3_OP_MUL = 521;
  static const int Z3_OP_DIV = 522;
  static const int Z3_OP_IDIV = 523;
  static const int Z3_OP_REM = 524;
  static const int Z3_OP_MOD = 525;
  static const int Z3_OP_TO_REAL = 526;
  static const int Z3_OP_TO_INT = 527;
  static const int Z3_OP_IS_INT = 528;
  static const int Z3_OP_POWER = 529;
  static const int Z3_OP_STORE = 768;
  static const int Z3_OP_SELECT = 769;
  static const int Z3_OP_CONST_ARRAY = 770;
  static const int Z3_OP_ARRAY_MAP = 771;
  static const int Z3_OP_ARRAY_DEFAULT = 772;
  static const int Z3_OP_SET_UNION = 773;
  static const int Z3_OP_SET_INTERSECT = 774;
  static const int Z3_OP_SET_DIFFERENCE = 775;
  static const int Z3_OP_SET_COMPLEMENT = 776;
  static const int Z3_OP_SET_SUBSET = 777;
  static const int Z3_OP_AS_ARRAY = 778;
  static const int Z3_OP_ARRAY_EXT = 779;
  static const int Z3_OP_SET_HAS_SIZE = 780;
  static const int Z3_OP_SET_CARD = 781;
  static const int Z3_OP_BNUM = 1024;
  static const int Z3_OP_BIT1 = 1025;
  static const int Z3_OP_BIT0 = 1026;
  static const int Z3_OP_BNEG = 1027;
  static const int Z3_OP_BADD = 1028;
  static const int Z3_OP_BSUB = 1029;
  static const int Z3_OP_BMUL = 1030;
  static const int Z3_OP_BSDIV = 1031;
  static const int Z3_OP_BUDIV = 1032;
  static const int Z3_OP_BSREM = 1033;
  static const int Z3_OP_BUREM = 1034;
  static const int Z3_OP_BSMOD = 1035;
  static const int Z3_OP_BSDIV0 = 1036;
  static const int Z3_OP_BUDIV0 = 1037;
  static const int Z3_OP_BSREM0 = 1038;
  static const int Z3_OP_BUREM0 = 1039;
  static const int Z3_OP_BSMOD0 = 1040;
  static const int Z3_OP_ULEQ = 1041;
  static const int Z3_OP_SLEQ = 1042;
  static const int Z3_OP_UGEQ = 1043;
  static const int Z3_OP_SGEQ = 1044;
  static const int Z3_OP_ULT = 1045;
  static const int Z3_OP_SLT = 1046;
  static const int Z3_OP_UGT = 1047;
  static const int Z3_OP_SGT = 1048;
  static const int Z3_OP_BAND = 1049;
  static const int Z3_OP_BOR = 1050;
  static const int Z3_OP_BNOT = 1051;
  static const int Z3_OP_BXOR = 1052;
  static const int Z3_OP_BNAND = 1053;
  static const int Z3_OP_BNOR = 1054;
  static const int Z3_OP_BXNOR = 1055;
  static const int Z3_OP_CONCAT = 1056;
  static const int Z3_OP_SIGN_EXT = 1057;
  static const int Z3_OP_ZERO_EXT = 1058;
  static const int Z3_OP_EXTRACT = 1059;
  static const int Z3_OP_REPEAT = 1060;
  static const int Z3_OP_BREDOR = 1061;
  static const int Z3_OP_BREDAND = 1062;
  static const int Z3_OP_BCOMP = 1063;
  static const int Z3_OP_BSHL = 1064;
  static const int Z3_OP_BLSHR = 1065;
  static const int Z3_OP_BASHR = 1066;
  static const int Z3_OP_ROTATE_LEFT = 1067;
  static const int Z3_OP_ROTATE_RIGHT = 1068;
  static const int Z3_OP_EXT_ROTATE_LEFT = 1069;
  static const int Z3_OP_EXT_ROTATE_RIGHT = 1070;
  static const int Z3_OP_BIT2BOOL = 1071;
  static const int Z3_OP_INT2BV = 1072;
  static const int Z3_OP_BV2INT = 1073;
  static const int Z3_OP_CARRY = 1074;
  static const int Z3_OP_XOR3 = 1075;
  static const int Z3_OP_BSMUL_NO_OVFL = 1076;
  static const int Z3_OP_BUMUL_NO_OVFL = 1077;
  static const int Z3_OP_BSMUL_NO_UDFL = 1078;
  static const int Z3_OP_BSDIV_I = 1079;
  static const int Z3_OP_BUDIV_I = 1080;
  static const int Z3_OP_BSREM_I = 1081;
  static const int Z3_OP_BUREM_I = 1082;
  static const int Z3_OP_BSMOD_I = 1083;
  static const int Z3_OP_PR_UNDEF = 1280;
  static const int Z3_OP_PR_TRUE = 1281;
  static const int Z3_OP_PR_ASSERTED = 1282;
  static const int Z3_OP_PR_GOAL = 1283;
  static const int Z3_OP_PR_MODUS_PONENS = 1284;
  static const int Z3_OP_PR_REFLEXIVITY = 1285;
  static const int Z3_OP_PR_SYMMETRY = 1286;
  static const int Z3_OP_PR_TRANSITIVITY = 1287;
  static const int Z3_OP_PR_TRANSITIVITY_STAR = 1288;
  static const int Z3_OP_PR_MONOTONICITY = 1289;
  static const int Z3_OP_PR_QUANT_INTRO = 1290;
  static const int Z3_OP_PR_BIND = 1291;
  static const int Z3_OP_PR_DISTRIBUTIVITY = 1292;
  static const int Z3_OP_PR_AND_ELIM = 1293;
  static const int Z3_OP_PR_NOT_OR_ELIM = 1294;
  static const int Z3_OP_PR_REWRITE = 1295;
  static const int Z3_OP_PR_REWRITE_STAR = 1296;
  static const int Z3_OP_PR_PULL_QUANT = 1297;
  static const int Z3_OP_PR_PUSH_QUANT = 1298;
  static const int Z3_OP_PR_ELIM_UNUSED_VARS = 1299;
  static const int Z3_OP_PR_DER = 1300;
  static const int Z3_OP_PR_QUANT_INST = 1301;
  static const int Z3_OP_PR_HYPOTHESIS = 1302;
  static const int Z3_OP_PR_LEMMA = 1303;
  static const int Z3_OP_PR_UNIT_RESOLUTION = 1304;
  static const int Z3_OP_PR_IFF_TRUE = 1305;
  static const int Z3_OP_PR_IFF_FALSE = 1306;
  static const int Z3_OP_PR_COMMUTATIVITY = 1307;
  static const int Z3_OP_PR_DEF_AXIOM = 1308;
  static const int Z3_OP_PR_ASSUMPTION_ADD = 1309;
  static const int Z3_OP_PR_LEMMA_ADD = 1310;
  static const int Z3_OP_PR_REDUNDANT_DEL = 1311;
  static const int Z3_OP_PR_CLAUSE_TRAIL = 1312;
  static const int Z3_OP_PR_DEF_INTRO = 1313;
  static const int Z3_OP_PR_APPLY_DEF = 1314;
  static const int Z3_OP_PR_IFF_OEQ = 1315;
  static const int Z3_OP_PR_NNF_POS = 1316;
  static const int Z3_OP_PR_NNF_NEG = 1317;
  static const int Z3_OP_PR_SKOLEMIZE = 1318;
  static const int Z3_OP_PR_MODUS_PONENS_OEQ = 1319;
  static const int Z3_OP_PR_TH_LEMMA = 1320;
  static const int Z3_OP_PR_HYPER_RESOLVE = 1321;
  static const int Z3_OP_RA_STORE = 1536;
  static const int Z3_OP_RA_EMPTY = 1537;
  static const int Z3_OP_RA_IS_EMPTY = 1538;
  static const int Z3_OP_RA_JOIN = 1539;
  static const int Z3_OP_RA_UNION = 1540;
  static const int Z3_OP_RA_WIDEN = 1541;
  static const int Z3_OP_RA_PROJECT = 1542;
  static const int Z3_OP_RA_FILTER = 1543;
  static const int Z3_OP_RA_NEGATION_FILTER = 1544;
  static const int Z3_OP_RA_RENAME = 1545;
  static const int Z3_OP_RA_COMPLEMENT = 1546;
  static const int Z3_OP_RA_SELECT = 1547;
  static const int Z3_OP_RA_CLONE = 1548;
  static const int Z3_OP_FD_CONSTANT = 1549;
  static const int Z3_OP_FD_LT = 1550;
  static const int Z3_OP_SEQ_UNIT = 1551;
  static const int Z3_OP_SEQ_EMPTY = 1552;
  static const int Z3_OP_SEQ_CONCAT = 1553;
  static const int Z3_OP_SEQ_PREFIX = 1554;
  static const int Z3_OP_SEQ_SUFFIX = 1555;
  static const int Z3_OP_SEQ_CONTAINS = 1556;
  static const int Z3_OP_SEQ_EXTRACT = 1557;
  static const int Z3_OP_SEQ_REPLACE = 1558;
  static const int Z3_OP_SEQ_REPLACE_RE = 1559;
  static const int Z3_OP_SEQ_REPLACE_RE_ALL = 1560;
  static const int Z3_OP_SEQ_REPLACE_ALL = 1561;
  static const int Z3_OP_SEQ_AT = 1562;
  static const int Z3_OP_SEQ_NTH = 1563;
  static const int Z3_OP_SEQ_LENGTH = 1564;
  static const int Z3_OP_SEQ_INDEX = 1565;
  static const int Z3_OP_SEQ_LAST_INDEX = 1566;
  static const int Z3_OP_SEQ_TO_RE = 1567;
  static const int Z3_OP_SEQ_IN_RE = 1568;
  static const int Z3_OP_STR_TO_INT = 1569;
  static const int Z3_OP_INT_TO_STR = 1570;
  static const int Z3_OP_UBV_TO_STR = 1571;
  static const int Z3_OP_SBV_TO_STR = 1572;
  static const int Z3_OP_STR_TO_CODE = 1573;
  static const int Z3_OP_STR_FROM_CODE = 1574;
  static const int Z3_OP_STRING_LT = 1575;
  static const int Z3_OP_STRING_LE = 1576;
  static const int Z3_OP_RE_PLUS = 1577;
  static const int Z3_OP_RE_STAR = 1578;
  static const int Z3_OP_RE_OPTION = 1579;
  static const int Z3_OP_RE_CONCAT = 1580;
  static const int Z3_OP_RE_UNION = 1581;
  static const int Z3_OP_RE_RANGE = 1582;
  static const int Z3_OP_RE_DIFF = 1583;
  static const int Z3_OP_RE_INTERSECT = 1584;
  static const int Z3_OP_RE_LOOP = 1585;
  static const int Z3_OP_RE_POWER = 1586;
  static const int Z3_OP_RE_COMPLEMENT = 1587;
  static const int Z3_OP_RE_EMPTY_SET = 1588;
  static const int Z3_OP_RE_FULL_SET = 1589;
  static const int Z3_OP_RE_FULL_CHAR_SET = 1590;
  static const int Z3_OP_RE_OF_PRED = 1591;
  static const int Z3_OP_RE_REVERSE = 1592;
  static const int Z3_OP_RE_DERIVATIVE = 1593;
  static const int Z3_OP_CHAR_CONST = 1594;
  static const int Z3_OP_CHAR_LE = 1595;
  static const int Z3_OP_CHAR_TO_INT = 1596;
  static const int Z3_OP_CHAR_TO_BV = 1597;
  static const int Z3_OP_CHAR_FROM_BV = 1598;
  static const int Z3_OP_CHAR_IS_DIGIT = 1599;
  static const int Z3_OP_LABEL = 1792;
  static const int Z3_OP_LABEL_LIT = 1793;
  static const int Z3_OP_DT_CONSTRUCTOR = 2048;
  static const int Z3_OP_DT_RECOGNISER = 2049;
  static const int Z3_OP_DT_IS = 2050;
  static const int Z3_OP_DT_ACCESSOR = 2051;
  static const int Z3_OP_DT_UPDATE_FIELD = 2052;
  static const int Z3_OP_PB_AT_MOST = 2304;
  static const int Z3_OP_PB_AT_LEAST = 2305;
  static const int Z3_OP_PB_LE = 2306;
  static const int Z3_OP_PB_GE = 2307;
  static const int Z3_OP_PB_EQ = 2308;
  static const int Z3_OP_SPECIAL_RELATION_LO = 40960;
  static const int Z3_OP_SPECIAL_RELATION_PO = 40961;
  static const int Z3_OP_SPECIAL_RELATION_PLO = 40962;
  static const int Z3_OP_SPECIAL_RELATION_TO = 40963;
  static const int Z3_OP_SPECIAL_RELATION_TC = 40964;
  static const int Z3_OP_SPECIAL_RELATION_TRC = 40965;
  static const int Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN = 45056;
  static const int Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY = 45057;
  static const int Z3_OP_FPA_RM_TOWARD_POSITIVE = 45058;
  static const int Z3_OP_FPA_RM_TOWARD_NEGATIVE = 45059;
  static const int Z3_OP_FPA_RM_TOWARD_ZERO = 45060;
  static const int Z3_OP_FPA_NUM = 45061;
  static const int Z3_OP_FPA_PLUS_INF = 45062;
  static const int Z3_OP_FPA_MINUS_INF = 45063;
  static const int Z3_OP_FPA_NAN = 45064;
  static const int Z3_OP_FPA_PLUS_ZERO = 45065;
  static const int Z3_OP_FPA_MINUS_ZERO = 45066;
  static const int Z3_OP_FPA_ADD = 45067;
  static const int Z3_OP_FPA_SUB = 45068;
  static const int Z3_OP_FPA_NEG = 45069;
  static const int Z3_OP_FPA_MUL = 45070;
  static const int Z3_OP_FPA_DIV = 45071;
  static const int Z3_OP_FPA_REM = 45072;
  static const int Z3_OP_FPA_ABS = 45073;
  static const int Z3_OP_FPA_MIN = 45074;
  static const int Z3_OP_FPA_MAX = 45075;
  static const int Z3_OP_FPA_FMA = 45076;
  static const int Z3_OP_FPA_SQRT = 45077;
  static const int Z3_OP_FPA_ROUND_TO_INTEGRAL = 45078;
  static const int Z3_OP_FPA_EQ = 45079;
  static const int Z3_OP_FPA_LT = 45080;
  static const int Z3_OP_FPA_GT = 45081;
  static const int Z3_OP_FPA_LE = 45082;
  static const int Z3_OP_FPA_GE = 45083;
  static const int Z3_OP_FPA_IS_NAN = 45084;
  static const int Z3_OP_FPA_IS_INF = 45085;
  static const int Z3_OP_FPA_IS_ZERO = 45086;
  static const int Z3_OP_FPA_IS_NORMAL = 45087;
  static const int Z3_OP_FPA_IS_SUBNORMAL = 45088;
  static const int Z3_OP_FPA_IS_NEGATIVE = 45089;
  static const int Z3_OP_FPA_IS_POSITIVE = 45090;
  static const int Z3_OP_FPA_FP = 45091;
  static const int Z3_OP_FPA_TO_FP = 45092;
  static const int Z3_OP_FPA_TO_FP_UNSIGNED = 45093;
  static const int Z3_OP_FPA_TO_UBV = 45094;
  static const int Z3_OP_FPA_TO_SBV = 45095;
  static const int Z3_OP_FPA_TO_REAL = 45096;
  static const int Z3_OP_FPA_TO_IEEE_BV = 45097;
  static const int Z3_OP_FPA_BVWRAP = 45098;
  static const int Z3_OP_FPA_BV2RM = 45099;
  static const int Z3_OP_INTERNAL = 45100;
  static const int Z3_OP_RECURSIVE = 45101;
  static const int Z3_OP_UNINTERPRETED = 45102;
}

/// \brief The different kinds of parameters that can be associated with parameter sets.
/// (see #Z3_mk_params).
///
/// - Z3_PK_UINT integer parameters.
/// - Z3_PK_BOOL boolean parameters.
/// - Z3_PK_DOUBLE double parameters.
/// - Z3_PK_SYMBOL symbol parameters.
/// - Z3_PK_STRING string parameters.
/// - Z3_PK_OTHER all internal parameter kinds which are not exposed in the API.
/// - Z3_PK_INVALID invalid parameter.
abstract class Z3_param_kind {
  static const int Z3_PK_UINT = 0;
  static const int Z3_PK_BOOL = 1;
  static const int Z3_PK_DOUBLE = 2;
  static const int Z3_PK_SYMBOL = 3;
  static const int Z3_PK_STRING = 4;
  static const int Z3_PK_OTHER = 5;
  static const int Z3_PK_INVALID = 6;
}

/// \brief Z3 pretty printing modes (See #Z3_set_ast_print_mode).
///
/// - Z3_PRINT_SMTLIB_FULL:   Print AST nodes in SMTLIB verbose format.
/// - Z3_PRINT_LOW_LEVEL:     Print AST nodes using a low-level format.
/// - Z3_PRINT_SMTLIB2_COMPLIANT: Print AST nodes in SMTLIB 2.x compliant format.
abstract class Z3_ast_print_mode {
  static const int Z3_PRINT_SMTLIB_FULL = 0;
  static const int Z3_PRINT_LOW_LEVEL = 1;
  static const int Z3_PRINT_SMTLIB2_COMPLIANT = 2;
}

/// \brief Z3 error codes (See #Z3_get_error_code).
///
/// - Z3_OK:            No error.
/// - Z3_SORT_ERROR:    User tried to build an invalid (type incorrect) AST.
/// - Z3_IOB:           Index out of bounds.
/// - Z3_INVALID_ARG:   Invalid argument was provided.
/// - Z3_PARSER_ERROR:  An error occurred when parsing a string or file.
/// - Z3_NO_PARSER:     Parser output is not available, that is, user didn't invoke #Z3_parse_smtlib2_string or #Z3_parse_smtlib2_file.
/// - Z3_INVALID_PATTERN: Invalid pattern was used to build a quantifier.
/// - Z3_MEMOUT_FAIL:   A memory allocation failure was encountered.
/// - Z3_FILE_ACCESS_ERRROR: A file could not be accessed.
/// - Z3_INVALID_USAGE:   API call is invalid in the current state.
/// - Z3_INTERNAL_FATAL: An error internal to Z3 occurred.
/// - Z3_DEC_REF_ERROR: Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized with #Z3_inc_ref.
/// - Z3_EXCEPTION:     Internal Z3 exception. Additional details can be retrieved using #Z3_get_error_msg.
abstract class Z3_error_code {
  static const int Z3_OK = 0;
  static const int Z3_SORT_ERROR = 1;
  static const int Z3_IOB = 2;
  static const int Z3_INVALID_ARG = 3;
  static const int Z3_PARSER_ERROR = 4;
  static const int Z3_NO_PARSER = 5;
  static const int Z3_INVALID_PATTERN = 6;
  static const int Z3_MEMOUT_FAIL = 7;
  static const int Z3_FILE_ACCESS_ERROR = 8;
  static const int Z3_INTERNAL_FATAL = 9;
  static const int Z3_INVALID_USAGE = 10;
  static const int Z3_DEC_REF_ERROR = 11;
  static const int Z3_EXCEPTION = 12;
}

/// \brief A Goal is essentially a set of formulas.
/// Z3 provide APIs for building strategies/tactics for solving and transforming Goals.
/// Some of these transformations apply under/over approximations.
///
/// - Z3_GOAL_PRECISE:    Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).
/// - Z3_GOAL_UNDER:      Goal is the product of a under-approximation (sat answers are preserved).
/// - Z3_GOAL_OVER:       Goal is the product of an over-approximation (unsat answers are preserved).
/// - Z3_GOAL_UNDER_OVER: Goal is garbage (it is the product of over- and under-approximations, sat and unsat answers are not preserved).
abstract class Z3_goal_prec {
  static const int Z3_GOAL_PRECISE = 0;
  static const int Z3_GOAL_UNDER = 1;
  static const int Z3_GOAL_OVER = 2;
  static const int Z3_GOAL_UNDER_OVER = 3;
}

/// \brief Z3 string type. It is just an alias for \ccode{const char *}.
typedef Z3_string = ffi.Pointer<ffi.Char>;

/// \brief Z3 Boolean type. It is just an alias for \c bool.
typedef Z3_bool = ffi.Int;
typedef Z3_string_ptr = ffi.Pointer<Z3_string>;
typedef Z3_config = ffi.Pointer<_Z3_config>;
typedef Z3_context = ffi.Pointer<_Z3_context>;
typedef Z3_ast = ffi.Pointer<_Z3_ast>;
typedef Z3_param_descrs = ffi.Pointer<_Z3_param_descrs>;
typedef Z3_params = ffi.Pointer<_Z3_params>;
typedef Z3_symbol = ffi.Pointer<_Z3_symbol>;
typedef Z3_sort = ffi.Pointer<_Z3_sort>;
typedef Z3_func_decl = ffi.Pointer<_Z3_func_decl>;
typedef Z3_constructor = ffi.Pointer<_Z3_constructor>;
typedef Z3_constructor_list = ffi.Pointer<_Z3_constructor_list>;
typedef Z3_char_ptr = ffi.Pointer<ffi.Char>;
typedef Z3_pattern = ffi.Pointer<_Z3_pattern>;
typedef Z3_app = ffi.Pointer<_Z3_app>;
typedef Z3_model = ffi.Pointer<_Z3_model>;
typedef Z3_func_interp = ffi.Pointer<_Z3_func_interp>;
typedef Z3_ast_vector = ffi.Pointer<_Z3_ast_vector>;
typedef Z3_func_entry = ffi.Pointer<_Z3_func_entry>;
typedef Z3_error_handler
    = ffi.NativeFunction<ffi.Void Function(Z3_context, ffi.Int32)>;
typedef Z3_goal = ffi.Pointer<_Z3_goal>;
typedef Z3_tactic = ffi.Pointer<_Z3_tactic>;
typedef Z3_probe = ffi.Pointer<_Z3_probe>;
typedef Z3_apply_result = ffi.Pointer<_Z3_apply_result>;
typedef Z3_solver = ffi.Pointer<_Z3_solver>;
typedef Z3_push_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_solver_callback)>;
typedef Z3_solver_callback = ffi.Pointer<_Z3_solver_callback>;
typedef Z3_pop_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>, Z3_solver_callback, ffi.UnsignedInt)>;
typedef Z3_fresh_eh = ffi.NativeFunction<
    ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, Z3_context)>;
typedef Z3_fixed_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>, Z3_solver_callback, Z3_ast, Z3_ast)>;
typedef Z3_final_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_solver_callback)>;
typedef Z3_eq_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>, Z3_solver_callback, Z3_ast, Z3_ast)>;
typedef Z3_created_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_solver_callback, Z3_ast)>;
typedef Z3_decide_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        Z3_solver_callback,
        ffi.Pointer<Z3_ast>,
        ffi.Pointer<ffi.UnsignedInt>,
        ffi.Pointer<ffi.Int32>)>;
typedef Z3_stats = ffi.Pointer<_Z3_stats>;
typedef Z3_ast_map = ffi.Pointer<_Z3_ast_map>;
typedef Z3_rcf_num = ffi.Pointer<_Z3_rcf_num>;
typedef Z3_fixedpoint = ffi.Pointer<_Z3_fixedpoint>;

/// \brief The following utilities allows adding user-defined domains.
typedef Z3_fixedpoint_reduce_assign_callback_fptr = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_func_decl, ffi.UnsignedInt,
        ffi.Pointer<Z3_ast>, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>;
typedef Z3_fixedpoint_reduce_app_callback_fptr = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_func_decl, ffi.UnsignedInt,
        ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>;
typedef Z3_fixedpoint_new_lemma_eh = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_ast, ffi.UnsignedInt)>>;
typedef Z3_fixedpoint_predecessor_eh
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Z3_fixedpoint_unfold_eh
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Z3_optimize = ffi.Pointer<_Z3_optimize>;

/// \brief callback functions for models.
typedef Z3_model_eh
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>;

const int _STDIO_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 35;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _____fpos_t_defined = 1;

const int ____mbstate_t_defined = 1;

const int _____fpos64_t_defined = 1;

const int ____FILE_defined = 1;

const int __FILE_defined = 1;

const int __struct_FILE_defined = 1;

const int _IO_EOF_SEEN = 16;

const int _IO_ERR_SEEN = 32;

const int _IO_USER_LOCK = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 8192;

const int EOF = -1;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const String P_tmpdir = '/tmp';

const int _BITS_STDIO_LIM_H = 1;

const int L_tmpnam = 20;

const int TMP_MAX = 238328;

const int FILENAME_MAX = 4096;

const int L_ctermid = 9;

const int FOPEN_MAX = 16;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int _STDINT_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int Z3_TRUE = 1;

const int Z3_FALSE = 0;
